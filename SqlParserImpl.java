/* SqlParserImpl.java */
/* Generated By:JavaCC: Do not edit this line. SqlParserImpl.java */
package org.apache.calcite.sql.parser.impl;


import org.apache.calcite.avatica.util.Casing;
import org.apache.calcite.avatica.util.DateTimeUtils;
import org.apache.calcite.avatica.util.TimeUnit;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.runtime.CalciteContextException;
import org.apache.calcite.sql.JoinConditionType;
import org.apache.calcite.sql.JoinType;
import org.apache.calcite.sql.SqlAlter;
import org.apache.calcite.sql.SqlBinaryOperator;
import org.apache.calcite.sql.SqlCall;
import org.apache.calcite.sql.SqlCharStringLiteral;
import org.apache.calcite.sql.SqlCollation;
import org.apache.calcite.sql.SqlDataTypeSpec;
import org.apache.calcite.sql.SqlDateLiteral;
import org.apache.calcite.sql.SqlDelete;
import org.apache.calcite.sql.SqlDescribeSchema;
import org.apache.calcite.sql.SqlDescribeTable;
import org.apache.calcite.sql.SqlDynamicParam;
import org.apache.calcite.sql.SqlExplain;
import org.apache.calcite.sql.SqlExplainFormat;
import org.apache.calcite.sql.SqlExplainLevel;
import org.apache.calcite.sql.SqlFunction;
import org.apache.calcite.sql.SqlFunctionCategory;
import org.apache.calcite.sql.SqlIdentifier;
import org.apache.calcite.sql.SqlInsert;
import org.apache.calcite.sql.SqlInsertKeyword;
import org.apache.calcite.sql.SqlIntervalLiteral;
import org.apache.calcite.sql.SqlIntervalQualifier;
import org.apache.calcite.sql.SqlJdbcDataTypeName;
import org.apache.calcite.sql.SqlJdbcFunctionCall;
import org.apache.calcite.sql.SqlJoin;
import org.apache.calcite.sql.SqlJsonConstructorNullClause;
import org.apache.calcite.sql.SqlJsonEncoding;
import org.apache.calcite.sql.SqlJsonExistsErrorBehavior;
import org.apache.calcite.sql.SqlJsonEmptyOrError;
import org.apache.calcite.sql.SqlJsonQueryEmptyOrErrorBehavior;
import org.apache.calcite.sql.SqlJsonQueryWrapperBehavior;
import org.apache.calcite.sql.SqlJsonValueEmptyOrErrorBehavior;
import org.apache.calcite.sql.SqlKind;
import org.apache.calcite.sql.SqlLiteral;
import org.apache.calcite.sql.SqlMatchRecognize;
import org.apache.calcite.sql.SqlMerge;
import org.apache.calcite.sql.SqlNode;
import org.apache.calcite.sql.SqlNodeList;
import org.apache.calcite.sql.SqlNumericLiteral;
import org.apache.calcite.sql.SqlOperator;
import org.apache.calcite.sql.SqlOrderBy;
import org.apache.calcite.sql.SqlPostfixOperator;
import org.apache.calcite.sql.SqlPrefixOperator;
import org.apache.calcite.sql.SqlSampleSpec;
import org.apache.calcite.sql.SqlSelect;
import org.apache.calcite.sql.SqlSelectKeyword;
import org.apache.calcite.sql.SqlSetOption;
import org.apache.calcite.sql.SqlSnapshot;
import org.apache.calcite.sql.SqlTimeLiteral;
import org.apache.calcite.sql.SqlTimestampLiteral;
import org.apache.calcite.sql.SqlUnnestOperator;
import org.apache.calcite.sql.SqlUpdate;
import org.apache.calcite.sql.SqlUtil;
import org.apache.calcite.sql.SqlWindow;
import org.apache.calcite.sql.SqlWith;
import org.apache.calcite.sql.SqlWithItem;
import org.apache.calcite.sql.fun.SqlCase;
import org.apache.calcite.sql.fun.OracleSqlOperatorTable;
import org.apache.calcite.sql.fun.SqlStdOperatorTable;
import org.apache.calcite.sql.fun.SqlTrimFunction;
import org.apache.calcite.sql.parser.Span;
import org.apache.calcite.sql.parser.SqlAbstractParserImpl;
import org.apache.calcite.sql.parser.SqlParseException;
import org.apache.calcite.sql.parser.SqlParser;
import org.apache.calcite.sql.parser.SqlParserImplFactory;
import org.apache.calcite.sql.parser.SqlParserPos;
import org.apache.calcite.sql.parser.SqlParserUtil;
import org.apache.calcite.sql.type.SqlTypeName;
import org.apache.calcite.sql.validate.SqlConformance;
import org.apache.calcite.util.Glossary;
import org.apache.calcite.util.NlsString;
import org.apache.calcite.util.Pair;
import org.apache.calcite.util.SourceStringReader;
import org.apache.calcite.util.Util;
import org.apache.calcite.util.trace.CalciteTrace;

import org.slf4j.Logger;

import java.io.Reader;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import static org.apache.calcite.util.Static.RESOURCE;

/**
 * SQL parser, generated from Parser.jj by JavaCC.
 *
 * <p>The public wrapper for this parser is {@link SqlParser}.
 */
public class SqlParserImpl extends SqlAbstractParserImpl implements SqlParserImplConstants {
    private static final Logger LOGGER = CalciteTrace.getParserTracer();

    // Can't use quoted literal because of a bug in how JavaCC translates
    // backslash-backslash.
    private static final char BACKSLASH = 0x5c;
    private static final char DOUBLE_QUOTE = 0x22;
    private static final String DQ = DOUBLE_QUOTE + "";
    private static final String DQDQ = DQ + DQ;

    private static Metadata metadata;

    private Casing unquotedCasing;
    private Casing quotedCasing;
    private int identifierMaxLength;
    private SqlConformance conformance;

    /**
     * {@link SqlParserImplFactory} implementation for creating parser.
     */
    public static final SqlParserImplFactory FACTORY = new SqlParserImplFactory() {
        public SqlAbstractParserImpl getParser(Reader reader) {
            final SqlParserImpl parser = new SqlParserImpl(reader);
            if (reader instanceof SourceStringReader) {
                final String sql =
                    ((SourceStringReader) reader).getSourceString();
                parser.setOriginalSql(sql);
            }
          return parser;
        }
    };

    public SqlParseException normalizeException(Throwable ex)
    {
        try {
            if (ex instanceof ParseException) {
                ex = cleanupParseException((ParseException) ex);
            }
            return convertException(ex);
        } catch (ParseException e) {
            throw new AssertionError(e);
        }
    }

    public Metadata getMetadata()
    {
        synchronized (SqlParserImpl.class) {
            if (metadata == null) {
                metadata = new MetadataImpl(
                    new SqlParserImpl(new java.io.StringReader("")));
            }
            return metadata;
        }
    }

    public void setTabSize(int tabSize)
    {
        jj_input_stream.setTabSize(tabSize);
    }

    public void switchTo(String stateName)
    {
        int state = Arrays.asList(SqlParserImplTokenManager.lexStateNames)
            .indexOf(stateName);
        token_source.SwitchTo(state);
    }

    public void setQuotedCasing(Casing quotedCasing)
    {
        this.quotedCasing = quotedCasing;
    }

    public void setUnquotedCasing(Casing unquotedCasing)
    {
        this.unquotedCasing = unquotedCasing;
    }

    public void setIdentifierMaxLength(int identifierMaxLength)
    {
        this.identifierMaxLength = identifierMaxLength;
    }

    public void setConformance(SqlConformance conformance)
    {
        this.conformance = conformance;
    }

    public SqlNode parseSqlExpressionEof() throws Exception
    {
        return SqlExpressionEof();
    }

    public SqlNode parseSqlStmtEof() throws Exception
    {
        return SqlStmtEof();
    }

    private SqlNode extend(SqlNode table, SqlNodeList extendList) {
        return SqlStdOperatorTable.EXTEND.createCall(
            Span.of(table, extendList).pos(), table, extendList);
    }

  void debug_message1() throws ParseException {
    trace_call("debug_message1");
    try {LOGGER.info("{} , {}", getToken(0).image, getToken(1).image);
    } finally {
      trace_return("debug_message1");
    }
  }

  String unquotedIdentifier() throws ParseException {
    trace_call("unquotedIdentifier");
    try {return SqlParserUtil.strip(getToken(0).image, null, null, null,
        unquotedCasing);
    } finally {
      trace_return("unquotedIdentifier");
    }
  }

/**
 * Allows parser to be extended with new types of table references.  The
 * default implementation of this production is empty.
 */
  final public SqlNode ExtendedTableRef() throws ParseException {
    trace_call("ExtendedTableRef");
    try {

      UnusedExtension();
{if ("" != null) return null;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExtendedTableRef");
    }
}

/**
 * Allows an OVER clause following a table expression as an extension to
 * standard SQL syntax. The default implementation of this production is empty.
 */
  final public SqlNode TableOverOpt() throws ParseException {
    trace_call("TableOverOpt");
    try {

{if ("" != null) return null;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TableOverOpt");
    }
}

/*
 * Parses dialect-specific keywords immediately following the SELECT keyword.
 */
  final public void SqlSelectKeywords(List<SqlLiteral> keywords) throws ParseException {
    trace_call("SqlSelectKeywords");
    try {

      E();
    } finally {
      trace_return("SqlSelectKeywords");
    }
}

/*
 * Parses dialect-specific keywords immediately following the INSERT keyword.
 */
  final public void SqlInsertKeywords(List<SqlLiteral> keywords) throws ParseException {
    trace_call("SqlInsertKeywords");
    try {

      E();
    } finally {
      trace_return("SqlInsertKeywords");
    }
}

  final public SqlNode ExtendedBuiltinFunctionCall() throws ParseException {
    trace_call("ExtendedBuiltinFunctionCall");
    try {

      UnusedExtension();
{if ("" != null) return null;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExtendedBuiltinFunctionCall");
    }
}

/*
* Parse Floor/Ceil function parameters
*/
  final public SqlNode FloorCeilOptions(Span s, boolean floorFlag) throws ParseException {
    trace_call("FloorCeilOptions");
    try {
SqlNode node;
      node = StandardFloorCeilOptions(s, floorFlag);
{if ("" != null) return node;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FloorCeilOptions");
    }
}

  void E() throws ParseException {
    trace_call("E");
    try {
    } finally {
      trace_return("E");
    }
  }

  List startList(Object o) throws ParseException {
    trace_call("startList");
    try {List list = new ArrayList();
    list.add(o);
    return list;
    } finally {
      trace_return("startList");
    }
  }

  protected SqlParserPos getPos() throws ParseException {
    trace_call("getPos");
    try {return new SqlParserPos(
        token.beginLine,
        token.beginColumn,
        token.endLine,
        token.endColumn);
    } finally {
      trace_return("getPos");
    }
  }

  Span span() throws ParseException {
    trace_call("span");
    try {return Span.of(getPos());
    } finally {
      trace_return("span");
    }
  }

  void checkQueryExpression(ExprContext exprContext) throws ParseException {
    trace_call("checkQueryExpression");
    try {switch (exprContext) {
    case ACCEPT_NON_QUERY:
    case ACCEPT_SUB_QUERY:
    case ACCEPT_CURSOR:
        throw SqlUtil.newContextException(getPos(),
            RESOURCE.illegalQueryExpression());
    }
    } finally {
      trace_return("checkQueryExpression");
    }
  }

  void checkNonQueryExpression(ExprContext exprContext) throws ParseException {
    trace_call("checkNonQueryExpression");
    try {switch (exprContext) {
    case ACCEPT_QUERY:
        throw SqlUtil.newContextException(getPos(),
            RESOURCE.illegalNonQueryExpression());
    }
    } finally {
      trace_return("checkNonQueryExpression");
    }
  }

  SqlParseException convertException(Throwable ex) throws ParseException {
    trace_call("convertException");
    try {if (ex instanceof SqlParseException) {
        return (SqlParseException) ex;
    }
    SqlParserPos pos = null;
    int[][] expectedTokenSequences = null;
    String[] tokenImage = null;
    if (ex instanceof ParseException) {
        ParseException pex = (ParseException) ex;
        expectedTokenSequences = pex.expectedTokenSequences;
        tokenImage = pex.tokenImage;
        if (pex.currentToken != null) {
            final Token token = pex.currentToken.next;
            pos = new SqlParserPos(
                token.beginLine,
                token.beginColumn,
                token.endLine,
                token.endColumn);
        }
    } else if (ex instanceof TokenMgrError) {
        TokenMgrError tme = (TokenMgrError) ex;
        expectedTokenSequences = null;
        tokenImage = null;
        // Example:
        //    Lexical error at line 3, column 24.  Encountered "#" after "a".
        final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(
            "(?s)Lexical error at line ([0-9]+), column ([0-9]+).*");
        java.util.regex.Matcher matcher = pattern.matcher(ex.getMessage());
        if (matcher.matches()) {
            int line = Integer.parseInt(matcher.group(1));
            int column = Integer.parseInt(matcher.group(2));
            pos = new SqlParserPos(line, column, line, column);
        }
    } else if (ex instanceof CalciteContextException) {
        // CalciteContextException is the standard wrapper for exceptions
        // produced by the validator, but in the parser, the standard is
        // SqlParseException; so, strip it away. In case you were wondering,
        // the CalciteContextException appears because the parser
        // occasionally calls into validator-style code such as
        // SqlSpecialOperator.reduceExpr.
        CalciteContextException ece =
            (CalciteContextException) ex;
        pos = new SqlParserPos(
            ece.getPosLine(),
            ece.getPosColumn(),
            ece.getEndPosLine(),
            ece.getEndPosColumn());
        ex = ece.getCause();
    }

    return new SqlParseException(
        ex.getMessage(), pos, expectedTokenSequences, tokenImage, ex);
    } finally {
      trace_return("convertException");
    }
  }

  ParseException cleanupParseException(ParseException ex) throws ParseException {
    trace_call("cleanupParseException");
    try {if (ex.expectedTokenSequences == null) {
        return ex;
    }
    int iIdentifier = Arrays.asList(ex.tokenImage).indexOf("<IDENTIFIER>");

    // Find all sequences in the error which contain identifier. For
    // example,
    //       {<IDENTIFIER>}
    //       {A}
    //       {B, C}
    //       {D, <IDENTIFIER>}
    //       {D, A}
    //       {D, B}
    //
    // would yield
    //       {}
    //       {D}
    boolean id = false;
    final List<int[]> prefixList = new ArrayList<int[]>();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int[] seq = ex.expectedTokenSequences[i];
        int j = seq.length - 1;
        int i1 = seq[j];
        if (i1 == iIdentifier) {
            int[] prefix = new int[j];
            System.arraycopy(seq, 0, prefix, 0, j);
            prefixList.add(prefix);
        }
    }

    if (prefixList.isEmpty()) {
        return ex;
    }

    int[][] prefixes = (int[][])
        prefixList.toArray(new int[prefixList.size()][]);

    // Since <IDENTIFIER> was one of the possible productions,
    // we know that the parser will also have included all
    // of the non-reserved keywords (which are treated as
    // identifiers in non-keyword contexts).  So, now we need
    // to clean those out, since they're totally irrelevant.

    final List<int[]> list = new ArrayList<int[]>();
    Metadata metadata = getMetadata();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int [] seq = ex.expectedTokenSequences[i];
        String tokenImage = ex.tokenImage[seq[seq.length - 1]];
        String token = SqlParserUtil.getTokenVal(tokenImage);
        if (token == null  || !metadata.isNonReservedKeyword(token)) {
            list.add(seq);
            continue;
        }
        boolean match = matchesPrefix(seq, prefixes);
        if (!match) {
            list.add(seq);
        }
    }

    ex.expectedTokenSequences =
        (int [][]) list.toArray(new int [list.size()][]);
    return ex;
    } finally {
      trace_return("cleanupParseException");
    }
  }

  boolean matchesPrefix(int[] seq, int[][] prefixes) throws ParseException {
    trace_call("matchesPrefix");
    try {nextPrefix:
    for (int[] prefix : prefixes) {
        if (seq.length == prefix.length + 1) {
            for (int k = 0; k < prefix.length; k++) {
                if (prefix[k] != seq[k]) {
                    continue nextPrefix;
                }
            }
            return true;
        }
    }
    return false;
    } finally {
      trace_return("matchesPrefix");
    }
  }

/*****************************************
 * Syntactical Descriptions              *
 *****************************************/

/**
 * Parses either a row expression or a query expression with an optional
 * ORDER BY.
 *
 * <p>Postgres syntax for limit:
 *
 * <blockquote><pre>
 *    [ LIMIT { count | ALL } ]
 *    [ OFFSET start ]</pre>
 * </blockquote>
 *
 * <p>MySQL syntax for limit:
 *
 * <blockquote><pre>
 *    [ LIMIT { count | start, count } ]</pre>
 * </blockquote>
 *
 * <p>SQL:2008 syntax for limit:
 *
 * <blockquote><pre>
 *    [ OFFSET start { ROW | ROWS } ]
 *    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]</pre>
 * </blockquote>
 */
  final public SqlNode OrderedQueryOrExpr(ExprContext exprContext) throws ParseException {
    trace_call("OrderedQueryOrExpr");
    try {
SqlNode e;
    SqlNodeList orderBy = null;
    SqlNode start = null;
    SqlNode count = null;
      e = QueryOrExpr(exprContext);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ORDER:{
        // use the syntactic type of the expression we just parsed
                // to decide whether ORDER BY makes sense
                orderBy = OrderBy(e.isA(SqlKind.QUERY));
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LIMIT:{
        jj_consume_token(LIMIT);
        if (jj_2_1(2)) {
          start = UnsignedNumericLiteralOrParam();
          jj_consume_token(COMMA);
          count = UnsignedNumericLiteralOrParam();
if (!this.conformance.isLimitStartCountAllowed()) {
                    {if (true) throw new ParseException(RESOURCE.limitStartCountNotAllowed().str());}
                }
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case UNSIGNED_INTEGER_LITERAL:
          case APPROX_NUMERIC_LITERAL:
          case DECIMAL_NUMERIC_LITERAL:
          case HOOK:{
            count = UnsignedNumericLiteralOrParam();
            break;
            }
          case ALL:{
            jj_consume_token(ALL);
            break;
            }
          default:
            jj_la1[1] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OFFSET:{
        jj_consume_token(OFFSET);
        start = UnsignedNumericLiteralOrParam();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ROW:
        case ROWS:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ROW:{
            jj_consume_token(ROW);
            break;
            }
          case ROWS:{
            jj_consume_token(ROWS);
            break;
            }
          default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          ;
        }
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FETCH:{
        jj_consume_token(FETCH);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FIRST:{
          jj_consume_token(FIRST);
          break;
          }
        case NEXT:{
          jj_consume_token(NEXT);
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        count = UnsignedNumericLiteralOrParam();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ROW:{
          jj_consume_token(ROW);
          break;
          }
        case ROWS:{
          jj_consume_token(ROWS);
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(ONLY);
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        ;
      }
if (orderBy != null || start != null || count != null) {
            if (orderBy == null) {
                orderBy = SqlNodeList.EMPTY;
            }
            e = new SqlOrderBy(getPos(), e, orderBy, start, count);

        }
        {if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("OrderedQueryOrExpr");
    }
}

/**
 * Parses a leaf in a query expression (SELECT, VALUES or TABLE).
 */
  final public SqlNode LeafQuery(ExprContext exprContext) throws ParseException {
    trace_call("LeafQuery");
    try {
SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SELECT:{
// ensure a query is legal in this context
        checkQueryExpression(exprContext);
        e = SqlSelect();
{if ("" != null) return e;}
        break;
        }
      case VALUES:{
        e = TableConstructor();
{if ("" != null) return e;}
        break;
        }
      case TABLE:{
        e = ExplicitTable(getPos());
{if ("" != null) return e;}
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LeafQuery");
    }
}

/**
 * Parses a parenthesized query or single row expression.
 */
  final public SqlNode ParenthesizedExpression(ExprContext exprContext) throws ParseException {
    trace_call("ParenthesizedExpression");
    try {
SqlNode e;
      jj_consume_token(LPAREN);
// we've now seen left paren, so queries inside should
        // be allowed as sub-queries
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            exprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            exprContext = ExprContext.ACCEPT_ALL;
            break;
        }
      e = OrderedQueryOrExpr(exprContext);
      jj_consume_token(RPAREN);
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParenthesizedExpression");
    }
}

/**
 * Parses a parenthesized query or comma-list of row expressions.
 *
 * <p>REVIEW jvs 8-Feb-2004: There's a small hole in this production.  It can be
 * used to construct something like
 *
 * <blockquote><pre>
 * WHERE x IN (select count(*) from t where c=d,5)</pre>
 * </blockquote>
 *
 * <p>which should be illegal.  The above is interpreted as equivalent to
 *
 * <blockquote><pre>
 * WHERE x IN ((select count(*) from t where c=d),5)</pre>
 * </blockquote>
 *
 * <p>which is a legal use of a sub-query.  The only way to fix the hole is to
 * be able to remember whether a subexpression was parenthesized or not, which
 * means preserving parentheses in the SqlNode tree.  This is probably
 * desirable anyway for use in purely syntactic parsing applications (e.g. SQL
 * pretty-printer).  However, if this is done, it's important to also make
 * isA() on the paren node call down to its operand so that we can
 * always correctly discriminate a query from a row expression.
 */
  final public SqlNodeList ParenthesizedQueryOrCommaList(ExprContext exprContext) throws ParseException {
    trace_call("ParenthesizedQueryOrCommaList");
    try {
SqlNode e;
    List<SqlNode> list;
    ExprContext firstExprContext = exprContext;
    final Span s;
      jj_consume_token(LPAREN);
// we've now seen left paren, so a query by itself should
        // be interpreted as a sub-query
        s = span();
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        }
      e = OrderedQueryOrExpr(firstExprContext);
list = startList(e);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          break label_1;
        }
        jj_consume_token(COMMA);
// a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
        e = Expression(exprContext);
list.add(e);
      }
      jj_consume_token(RPAREN);
{if ("" != null) return new SqlNodeList(list, s.end(this));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParenthesizedQueryOrCommaList");
    }
}

/** As ParenthesizedQueryOrCommaList, but allows DEFAULT
 * in place of any of the expressions. For example,
 * {@code (x, DEFAULT, null, DEFAULT)}. */
  final public SqlNodeList ParenthesizedQueryOrCommaListWithDefault(ExprContext exprContext) throws ParseException {
    trace_call("ParenthesizedQueryOrCommaListWithDefault");
    try {
SqlNode e;
    List<SqlNode> list;
    ExprContext firstExprContext = exprContext;
    final Span s;
      jj_consume_token(LPAREN);
// we've now seen left paren, so a query by itself should
        // be interpreted as a sub-query
        s = span();
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        }
      if (jj_2_2(1)) {
        e = OrderedQueryOrExpr(firstExprContext);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DEFAULT_:{
          e = Default();
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
list = startList(e);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
// a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
        if (jj_2_3(1)) {
          e = Expression(exprContext);
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case DEFAULT_:{
            e = Default();
            break;
            }
          default:
            jj_la1[13] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
list.add(e);
      }
      jj_consume_token(RPAREN);
{if ("" != null) return new SqlNodeList(list, s.end(this));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParenthesizedQueryOrCommaListWithDefault");
    }
}

/**
 * Parses function parameter lists including DISTINCT keyword recognition,
 * DEFAULT, and named argument assignment.
 */
  final public List FunctionParameterList(ExprContext exprContext) throws ParseException {
    trace_call("FunctionParameterList");
    try {
SqlNode e = null;
    List list = new ArrayList();
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALL:
      case DISTINCT:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DISTINCT:{
          jj_consume_token(DISTINCT);
e = SqlSelectKeyword.DISTINCT.symbol(getPos());
          break;
          }
        case ALL:{
          jj_consume_token(ALL);
e = SqlSelectKeyword.ALL.symbol(getPos());
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        ;
      }
list.add(e);
      Arg0(list, exprContext);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
// a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
        Arg(list, exprContext);
      }
      jj_consume_token(RPAREN);
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionParameterList");
    }
}

  final public void Arg0(List list, ExprContext exprContext) throws ParseException {
    trace_call("Arg0");
    try {
SqlIdentifier name = null;
    SqlNode e = null;
    final ExprContext firstExprContext;
    {
        // we've now seen left paren, so queries inside should
        // be allowed as sub-queries
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        default:
            firstExprContext = exprContext;
            break;
        }
    }
      if (jj_2_4(2)) {
        name = SimpleIdentifier();
        jj_consume_token(NAMED_ARGUMENT_ASSIGNMENT);
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DEFAULT_:{
        e = Default();
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        if (jj_2_5(1)) {
          e = OrderedQueryOrExpr(firstExprContext);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
if (e != null) {
            if (name != null) {
                e = SqlStdOperatorTable.ARGUMENT_ASSIGNMENT.createCall(
                    Span.of(name, e).pos(), e, name);
            }
            list.add(e);
        }
    } finally {
      trace_return("Arg0");
    }
}

  final public void Arg(List list, ExprContext exprContext) throws ParseException {
    trace_call("Arg");
    try {
SqlIdentifier name = null;
    SqlNode e = null;
      if (jj_2_6(2)) {
        name = SimpleIdentifier();
        jj_consume_token(NAMED_ARGUMENT_ASSIGNMENT);
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DEFAULT_:{
        e = Default();
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        if (jj_2_7(1)) {
          e = Expression(exprContext);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
if (e != null) {
            if (name != null) {
                e = SqlStdOperatorTable.ARGUMENT_ASSIGNMENT.createCall(
                    Span.of(name, e).pos(), e, name);
            }
            list.add(e);
        }
    } finally {
      trace_return("Arg");
    }
}

  final public SqlNode Default() throws ParseException {
    trace_call("Default");
    try {

      jj_consume_token(DEFAULT_);
{if ("" != null) return SqlStdOperatorTable.DEFAULT.createCall(getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Default");
    }
}

/**
 * Parses a query (SELECT, UNION, INTERSECT, EXCEPT, VALUES, TABLE) followed by
 * the end-of-file symbol.
 */
  final public SqlNode SqlQueryEof() throws ParseException {
    trace_call("SqlQueryEof");
    try {
SqlNode query;
      query = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
      jj_consume_token(0);
{if ("" != null) return query;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlQueryEof");
    }
}

/**
 * Parses an SQL statement.
 */
  final public SqlNode SqlStmt() throws ParseException {
    trace_call("SqlStmt");
    try {
SqlNode stmt;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RESET:
      case SET:{
        stmt = SqlSetOption(Span.of(), null);
        break;
        }
      case ALTER:{
        stmt = SqlAlter();
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        if (jj_2_8(1)) {
          stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EXPLAIN:{
            stmt = SqlExplain();
            break;
            }
          case DESCRIBE:{
            stmt = SqlDescribe();
            break;
            }
          case INSERT:
          case UPSERT:{
            stmt = SqlInsert();
            break;
            }
          case DELETE:{
            stmt = SqlDelete();
            break;
            }
          case UPDATE:{
            stmt = SqlUpdate();
            break;
            }
          case MERGE:{
            stmt = SqlMerge();
            break;
            }
          case CALL:{
            stmt = SqlProcedureCall();
            break;
            }
          default:
            jj_la1[20] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
{if ("" != null) return stmt;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlStmt");
    }
}

/**
 * Parses an SQL statement followed by the end-of-file symbol.
 */
  final public SqlNode SqlStmtEof() throws ParseException {
    trace_call("SqlStmtEof");
    try {
SqlNode stmt;
      stmt = SqlStmt();
      jj_consume_token(0);
{if ("" != null) return stmt;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlStmtEof");
    }
}

/**
 * Parses a leaf SELECT expression without ORDER BY.
 */
  final public SqlSelect SqlSelect() throws ParseException {
    trace_call("SqlSelect");
    try {
final List<SqlLiteral> keywords = new ArrayList<SqlLiteral>();
    final SqlNodeList keywordList;
    List<SqlNode> selectList;
    final SqlNode fromClause;
    final SqlNode where;
    final SqlNodeList groupBy;
    final SqlNode having;
    final SqlNodeList windowDecls;
    final Span s;
      jj_consume_token(SELECT);
s = span();
      SqlSelectKeywords(keywords);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STREAM:{
        jj_consume_token(STREAM);
keywords.add(SqlSelectKeyword.STREAM.symbol(getPos()));
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALL:
      case DISTINCT:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DISTINCT:{
          jj_consume_token(DISTINCT);
keywords.add(SqlSelectKeyword.DISTINCT.symbol(getPos()));
          break;
          }
        case ALL:{
          jj_consume_token(ALL);
keywords.add(SqlSelectKeyword.ALL.symbol(getPos()));
          break;
          }
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        ;
      }
keywordList = new SqlNodeList(keywords, s.addAll(keywords).pos());
      selectList = SelectList();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FROM:{
        jj_consume_token(FROM);
        fromClause = FromClause();
        where = WhereOpt();
        groupBy = GroupByOpt();
        having = HavingOpt();
        windowDecls = WindowOpt();
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        E();
fromClause = null;
            where = null;
            groupBy = null;
            having = null;
            windowDecls = null;
      }
{if ("" != null) return new SqlSelect(s.end(this), keywordList,
            new SqlNodeList(selectList, Span.of(selectList).pos()),
            fromClause, where, groupBy, having, windowDecls, null, null, null);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlSelect");
    }
}

/*
 * Abstract production:
 *
 *    void SqlSelectKeywords(List keywords)
 *
 * Parses dialect-specific keywords immediately following the SELECT keyword.
 */

/**
 * Parses an EXPLAIN PLAN statement.
 */
  final public SqlNode SqlExplain() throws ParseException {
    trace_call("SqlExplain");
    try {
SqlNode stmt;
    SqlExplainLevel detailLevel = SqlExplainLevel.EXPPLAN_ATTRIBUTES;
    SqlExplain.Depth depth;
    final SqlExplainFormat format;
      jj_consume_token(EXPLAIN);
      jj_consume_token(PLAN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXCLUDING:
      case INCLUDING:{
        detailLevel = ExplainDetailLevel();
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      depth = ExplainDepth();
      if (jj_2_9(2)) {
        jj_consume_token(AS);
        jj_consume_token(XML);
format = SqlExplainFormat.XML;
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AS:{
          jj_consume_token(AS);
          jj_consume_token(JSON);
format = SqlExplainFormat.JSON;
          break;
          }
        default:
          jj_la1[26] = jj_gen;
format = SqlExplainFormat.TEXT;
        }
      }
      jj_consume_token(FOR);
      stmt = SqlQueryOrDml();
{if ("" != null) return new SqlExplain(getPos(),
            stmt,
            detailLevel.symbol(SqlParserPos.ZERO),
            depth.symbol(SqlParserPos.ZERO),
            format.symbol(SqlParserPos.ZERO),
            nDynamicParams);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlExplain");
    }
}

/** Parses a query (SELECT or VALUES)
 * or DML statement (INSERT, UPDATE, DELETE, MERGE). */
  final public SqlNode SqlQueryOrDml() throws ParseException {
    trace_call("SqlQueryOrDml");
    try {
SqlNode stmt;
      if (jj_2_10(1)) {
        stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INSERT:
        case UPSERT:{
          stmt = SqlInsert();
          break;
          }
        case DELETE:{
          stmt = SqlDelete();
          break;
          }
        case UPDATE:{
          stmt = SqlUpdate();
          break;
          }
        case MERGE:{
          stmt = SqlMerge();
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
{if ("" != null) return stmt;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlQueryOrDml");
    }
}

/**
 * Parses WITH TYPE | WITH IMPLEMENTATION | WITHOUT IMPLEMENTATION modifier for
 * EXPLAIN PLAN.
 */
  final public SqlExplain.Depth ExplainDepth() throws ParseException {
    trace_call("ExplainDepth");
    try {

      if (jj_2_11(2)) {
        jj_consume_token(WITH);
        jj_consume_token(TYPE);
{if ("" != null) return SqlExplain.Depth.TYPE;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case WITH:{
          jj_consume_token(WITH);
          jj_consume_token(IMPLEMENTATION);
{if ("" != null) return SqlExplain.Depth.PHYSICAL;}
          break;
          }
        case WITHOUT:{
          jj_consume_token(WITHOUT);
          jj_consume_token(IMPLEMENTATION);
{if ("" != null) return SqlExplain.Depth.LOGICAL;}
          break;
          }
        default:
          jj_la1[28] = jj_gen;
{if ("" != null) return SqlExplain.Depth.PHYSICAL;}
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExplainDepth");
    }
}

/**
 * Parses INCLUDING ALL ATTRIBUTES modifier for EXPLAIN PLAN.
 */
  final public SqlExplainLevel ExplainDetailLevel() throws ParseException {
    trace_call("ExplainDetailLevel");
    try {
SqlExplainLevel level = SqlExplainLevel.EXPPLAN_ATTRIBUTES;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXCLUDING:{
        jj_consume_token(EXCLUDING);
        jj_consume_token(ATTRIBUTES);
level = SqlExplainLevel.NO_ATTRIBUTES;
        break;
        }
      case INCLUDING:{
        jj_consume_token(INCLUDING);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL:{
          jj_consume_token(ALL);
level = SqlExplainLevel.ALL_ATTRIBUTES;
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          ;
        }
        jj_consume_token(ATTRIBUTES);

        break;
        }
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return level;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExplainDetailLevel");
    }
}

/**
 * Parses a DESCRIBE statement.
 */
  final public SqlNode SqlDescribe() throws ParseException {
    trace_call("SqlDescribe");
    try {
final Span s;
   final SqlIdentifier table;
   final SqlIdentifier column;
   final SqlIdentifier id;
   final SqlNode stmt;
      jj_consume_token(DESCRIBE);
s = span();
      if (jj_2_12(2)) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DATABASE:{
          jj_consume_token(DATABASE);
          break;
          }
        case CATALOG:{
          jj_consume_token(CATALOG);
          break;
          }
        case SCHEMA:{
          jj_consume_token(SCHEMA);
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        id = CompoundIdentifier();
// DESCRIBE DATABASE and DESCRIBE CATALOG currently do the same as
            // DESCRIBE SCHEMA but should be different. See
            //   [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
            {if ("" != null) return new SqlDescribeSchema(s.end(id), id);}
      } else if (jj_2_13(2147483647)) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TABLE:{
          jj_consume_token(TABLE);
          break;
          }
        default:
          jj_la1[32] = jj_gen;
          ;
        }
        table = CompoundIdentifier();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          column = SimpleIdentifier();
          break;
          }
        default:
          jj_la1[33] = jj_gen;
          E();
column = null;
        }
{if ("" != null) return new SqlDescribeTable(s.add(table).addIf(column).pos(),
                table, column);}
      } else if (jj_2_14(1)) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case STATEMENT:{
          jj_consume_token(STATEMENT);
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          ;
        }
        stmt = SqlQueryOrDml();
// DESCRIBE STATEMENT currently does the same as EXPLAIN. See
            //   [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
            final SqlExplainLevel detailLevel = SqlExplainLevel.EXPPLAN_ATTRIBUTES;
            final SqlExplain.Depth depth = SqlExplain.Depth.PHYSICAL;
            final SqlExplainFormat format = SqlExplainFormat.TEXT;
            {if ("" != null) return new SqlExplain(s.end(stmt),
                stmt,
                detailLevel.symbol(SqlParserPos.ZERO),
                depth.symbol(SqlParserPos.ZERO),
                format.symbol(SqlParserPos.ZERO),
                nDynamicParams);}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlDescribe");
    }
}

/**
 * Parses a CALL statement.
 */
  final public SqlNode SqlProcedureCall() throws ParseException {
    trace_call("SqlProcedureCall");
    try {
final Span s;
    SqlNode routineCall;
      jj_consume_token(CALL);
s = span();
      routineCall = NamedRoutineCall(SqlFunctionCategory.USER_DEFINED_PROCEDURE,
              ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return SqlStdOperatorTable.PROCEDURE_CALL.createCall(
            s.end(routineCall), routineCall);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlProcedureCall");
    }
}

  final public SqlNode NamedRoutineCall(SqlFunctionCategory routineType,
    ExprContext exprContext) throws ParseException {
    trace_call("NamedRoutineCall");
    try {
SqlIdentifier name;
    final List<SqlNode> list = new ArrayList<SqlNode>();
    final Span s;
      name = CompoundIdentifier();
s = span();
      jj_consume_token(LPAREN);
      if (jj_2_15(1)) {
        Arg0(list, exprContext);
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[35] = jj_gen;
            break label_4;
          }
          jj_consume_token(COMMA);
// a comma-list can't appear where only a query is expected
                checkNonQueryExpression(exprContext);
          Arg(list, exprContext);
        }
      } else {
        ;
      }
      jj_consume_token(RPAREN);
{if ("" != null) return createCall(name, s.end(this), routineType, null, list);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NamedRoutineCall");
    }
}

/**
 * Parses an INSERT statement.
 */
  final public SqlNode SqlInsert() throws ParseException {
    trace_call("SqlInsert");
    try {
final List<SqlLiteral> keywords = new ArrayList<SqlLiteral>();
    final SqlNodeList keywordList;
    SqlNode table;
    SqlNodeList extendList = null;
    SqlNode source;
    SqlNodeList columnList = null;
    final Span s;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INSERT:{
        jj_consume_token(INSERT);
        break;
        }
      case UPSERT:{
        jj_consume_token(UPSERT);
keywords.add(SqlInsertKeyword.UPSERT.symbol(getPos()));
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
s = span();
      SqlInsertKeywords(keywords);
keywordList = new SqlNodeList(keywords, s.addAll(keywords).pos());
      jj_consume_token(INTO);
      table = CompoundIdentifier();
      if (jj_2_16(5)) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXTEND:{
          jj_consume_token(EXTEND);
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        extendList = ExtendList();
table = extend(table, extendList);
      } else {
        ;
      }
      if (jj_2_17(2)) {
final Pair<SqlNodeList, SqlNodeList> p;
        p = ParenthesizedCompoundIdentifierList();
if (p.right.size() > 0) {
                table = extend(table, p.right);
            }
            if (p.left.size() > 0) {
                columnList = p.left;
            }
      } else {
        ;
      }
      source = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY);
{if ("" != null) return new SqlInsert(s.end(source), keywordList, table, source,
            columnList);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlInsert");
    }
}

/*
 * Abstract production:
 *
 *    void SqlInsertKeywords(List keywords)
 *
 * Parses dialect-specific keywords immediately following the INSERT keyword.
 */

/**
 * Parses a DELETE statement.
 */
  final public SqlNode SqlDelete() throws ParseException {
    trace_call("SqlDelete");
    try {
SqlNode table;
    SqlNodeList extendList = null;
    SqlIdentifier alias = null;
    final SqlNode condition;
    final Span s;
      jj_consume_token(DELETE);
s = span();
      jj_consume_token(FROM);
      table = CompoundIdentifier();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXTEND:
      case LPAREN:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXTEND:{
          jj_consume_token(EXTEND);
          break;
          }
        default:
          jj_la1[38] = jj_gen;
          ;
        }
        extendList = ExtendList();
table = extend(table, extendList);
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case AS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AS:{
          jj_consume_token(AS);
          break;
          }
        default:
          jj_la1[40] = jj_gen;
          ;
        }
        alias = SimpleIdentifier();
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      condition = WhereOpt();
{if ("" != null) return new SqlDelete(s.add(table).addIf(extendList).addIf(alias)
            .addIf(condition).pos(), table, condition, null, alias);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlDelete");
    }
}

/**
 * Parses an UPDATE statement.
 */
  final public SqlNode SqlUpdate() throws ParseException {
    trace_call("SqlUpdate");
    try {
SqlNode table;
    SqlNodeList extendList = null;
    SqlIdentifier alias = null;
    SqlNode condition;
    SqlNodeList sourceExpressionList;
    SqlNodeList targetColumnList;
    SqlIdentifier id;
    SqlNode exp;
    final Span s;
      jj_consume_token(UPDATE);
s = span();
      table = CompoundIdentifier();
targetColumnList = new SqlNodeList(s.pos());
        sourceExpressionList = new SqlNodeList(s.pos());
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXTEND:
      case LPAREN:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXTEND:{
          jj_consume_token(EXTEND);
          break;
          }
        default:
          jj_la1[42] = jj_gen;
          ;
        }
        extendList = ExtendList();
table = extend(table, extendList);
        break;
        }
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case AS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AS:{
          jj_consume_token(AS);
          break;
          }
        default:
          jj_la1[44] = jj_gen;
          ;
        }
        alias = SimpleIdentifier();
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        ;
      }
      jj_consume_token(SET);
      id = SimpleIdentifier();
targetColumnList.add(id);
      jj_consume_token(EQ);
      exp = Expression(ExprContext.ACCEPT_SUB_QUERY);
// TODO:  support DEFAULT also
        sourceExpressionList.add(exp);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[46] = jj_gen;
          break label_5;
        }
        jj_consume_token(COMMA);
        id = SimpleIdentifier();
targetColumnList.add(id);
        jj_consume_token(EQ);
        exp = Expression(ExprContext.ACCEPT_SUB_QUERY);
sourceExpressionList.add(exp);
      }
      condition = WhereOpt();
{if ("" != null) return new SqlUpdate(s.addAll(targetColumnList)
            .addAll(sourceExpressionList).addIf(condition).pos(), table,
            targetColumnList, sourceExpressionList, condition, null, alias);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlUpdate");
    }
}

/**
 * Parses a MERGE statement.
 */
  final public SqlNode SqlMerge() throws ParseException {
    trace_call("SqlMerge");
    try {
SqlNode table;
    SqlNodeList extendList = null;
    SqlIdentifier alias = null;
    SqlNode sourceTableRef;
    SqlNode condition;
    SqlUpdate updateCall = null;
    SqlInsert insertCall = null;
    final Span s;
      jj_consume_token(MERGE);
s = span();
      jj_consume_token(INTO);
      table = CompoundIdentifier();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXTEND:
      case LPAREN:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXTEND:{
          jj_consume_token(EXTEND);
          break;
          }
        default:
          jj_la1[47] = jj_gen;
          ;
        }
        extendList = ExtendList();
table = extend(table, extendList);
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case AS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AS:{
          jj_consume_token(AS);
          break;
          }
        default:
          jj_la1[49] = jj_gen;
          ;
        }
        alias = SimpleIdentifier();
        break;
        }
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      jj_consume_token(USING);
      sourceTableRef = TableRef();
      jj_consume_token(ON);
      condition = Expression(ExprContext.ACCEPT_SUB_QUERY);
      if (jj_2_18(2)) {
        updateCall = WhenMatchedClause(table, alias);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case WHEN:{
          insertCall = WhenNotMatchedClause(table);
          break;
          }
        default:
          jj_la1[51] = jj_gen;
          ;
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case WHEN:{
          insertCall = WhenNotMatchedClause(table);
          break;
          }
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
{if ("" != null) return new SqlMerge(s.addIf(updateCall).addIf(insertCall).pos(), table,
            condition, sourceTableRef, updateCall, insertCall, null, alias);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlMerge");
    }
}

  final public SqlUpdate WhenMatchedClause(SqlNode table, SqlIdentifier alias) throws ParseException {
    trace_call("WhenMatchedClause");
    try {
SqlIdentifier id;
    final Span s;
    final SqlNodeList updateColumnList = new SqlNodeList(SqlParserPos.ZERO);
    SqlNode exp;
    final SqlNodeList updateExprList = new SqlNodeList(SqlParserPos.ZERO);
      jj_consume_token(WHEN);
s = span();
      jj_consume_token(MATCHED);
      jj_consume_token(THEN);
      jj_consume_token(UPDATE);
      jj_consume_token(SET);
      id = SimpleIdentifier();
updateColumnList.add(id);
      jj_consume_token(EQ);
      exp = Expression(ExprContext.ACCEPT_SUB_QUERY);
updateExprList.add(exp);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[53] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA);
        id = SimpleIdentifier();
updateColumnList.add(id);
        jj_consume_token(EQ);
        exp = Expression(ExprContext.ACCEPT_SUB_QUERY);
updateExprList.add(exp);
      }
{if ("" != null) return new SqlUpdate(s.addAll(updateExprList).pos(), table,
            updateColumnList, updateExprList, null, null, alias);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WhenMatchedClause");
    }
}

  final public SqlInsert WhenNotMatchedClause(SqlNode table) throws ParseException {
    trace_call("WhenNotMatchedClause");
    try {
final Span insertSpan, valuesSpan;
    final List<SqlLiteral> keywords = new ArrayList<SqlLiteral>();
    final SqlNodeList keywordList;
    SqlNodeList insertColumnList = null;
    SqlNode rowConstructor;
    SqlNode insertValues;
      jj_consume_token(WHEN);
      jj_consume_token(NOT);
      jj_consume_token(MATCHED);
      jj_consume_token(THEN);
      jj_consume_token(INSERT);
insertSpan = span();
      SqlInsertKeywords(keywords);
keywordList = new SqlNodeList(keywords, insertSpan.end(this));
      if (jj_2_19(2)) {
        insertColumnList = ParenthesizedSimpleIdentifierList();
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        jj_consume_token(LPAREN);
        break;
        }
      default:
        jj_la1[54] = jj_gen;
        ;
      }
      jj_consume_token(VALUES);
valuesSpan = span();
      rowConstructor = RowConstructor();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RPAREN:{
        jj_consume_token(RPAREN);
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        ;
      }
// TODO zfong 5/26/06: note that extra parentheses are accepted above
        // around the VALUES clause as a hack for unparse, but this is
        // actually invalid SQL; should fix unparse
        insertValues = SqlStdOperatorTable.VALUES.createCall(
            valuesSpan.end(this), rowConstructor);
        {if ("" != null) return new SqlInsert(insertSpan.end(this), keywordList,
            table, insertValues, insertColumnList);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WhenNotMatchedClause");
    }
}

/**
 * Parses the select list of a SELECT statement.
 */
  final public List<SqlNode> SelectList() throws ParseException {
    trace_call("SelectList");
    try {
final List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode item;
      item = SelectItem();
list.add(item);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[56] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        item = SelectItem();
list.add(item);
      }
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SelectList");
    }
}

/**
 * Parses one item in a select list.
 */
  final public SqlNode SelectItem() throws ParseException {
    trace_call("SelectItem");
    try {
SqlNode e;
    final SqlIdentifier id;
      e = SelectExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case AS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AS:{
          jj_consume_token(AS);
          break;
          }
        default:
          jj_la1[57] = jj_gen;
          ;
        }
        id = SimpleIdentifier();
e = SqlStdOperatorTable.AS.createCall(span().end(e), e, id);
        break;
        }
      default:
        jj_la1[58] = jj_gen;
        ;
      }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SelectItem");
    }
}

/**
 * Parses one unaliased expression in a select list.
 */
  final public SqlNode SelectExpression() throws ParseException {
    trace_call("SelectExpression");
    try {
SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STAR:{
        jj_consume_token(STAR);
{if ("" != null) return SqlIdentifier.star(getPos());}
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        if (jj_2_20(1)) {
          e = Expression(ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return e;}
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SelectExpression");
    }
}

  final public SqlLiteral Natural() throws ParseException {
    trace_call("Natural");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NATURAL:{
        jj_consume_token(NATURAL);
{if ("" != null) return SqlLiteral.createBoolean(true, getPos());}
        break;
        }
      default:
        jj_la1[60] = jj_gen;
{if ("" != null) return SqlLiteral.createBoolean(false, getPos());}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Natural");
    }
}

  final public SqlLiteral JoinType() throws ParseException {
    trace_call("JoinType");
    try {
JoinType joinType;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case JOIN:{
        jj_consume_token(JOIN);
joinType = JoinType.INNER;
        break;
        }
      case INNER:{
        jj_consume_token(INNER);
        jj_consume_token(JOIN);
joinType = JoinType.INNER;
        break;
        }
      case LEFT:{
        jj_consume_token(LEFT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OUTER:{
          jj_consume_token(OUTER);
          break;
          }
        default:
          jj_la1[61] = jj_gen;
          ;
        }
        jj_consume_token(JOIN);
joinType = JoinType.LEFT;
        break;
        }
      case RIGHT:{
        jj_consume_token(RIGHT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OUTER:{
          jj_consume_token(OUTER);
          break;
          }
        default:
          jj_la1[62] = jj_gen;
          ;
        }
        jj_consume_token(JOIN);
joinType = JoinType.RIGHT;
        break;
        }
      case FULL:{
        jj_consume_token(FULL);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OUTER:{
          jj_consume_token(OUTER);
          break;
          }
        default:
          jj_la1[63] = jj_gen;
          ;
        }
        jj_consume_token(JOIN);
joinType = JoinType.FULL;
        break;
        }
      case CROSS:{
        jj_consume_token(CROSS);
        jj_consume_token(JOIN);
joinType = JoinType.CROSS;
        break;
        }
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return joinType.symbol(getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JoinType");
    }
}

/** Matches "LEFT JOIN t ON ...", "RIGHT JOIN t USING ...", "JOIN t". */
  final public SqlNode JoinTable(SqlNode e) throws ParseException {
    trace_call("JoinTable");
    try {
SqlNode e2, condition;
    final SqlLiteral natural, joinType, on, using;
    SqlNodeList list;
      natural = Natural();
      joinType = JoinType();
      e2 = TableRef();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ON:{
        jj_consume_token(ON);
on = JoinConditionType.ON.symbol(getPos());
        condition = Expression(ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return new SqlJoin(joinType.getParserPosition(),
                e,
                natural,
                joinType,
                e2,
                on,
                condition);}
        break;
        }
      case USING:{
        jj_consume_token(USING);
using = JoinConditionType.USING.symbol(getPos());
        list = ParenthesizedSimpleIdentifierList();
{if ("" != null) return new SqlJoin(joinType.getParserPosition(),
                e,
                natural,
                joinType,
                e2,
                using,
                new SqlNodeList(list.getList(), Span.of(using).end(this)));}
        break;
        }
      default:
        jj_la1[65] = jj_gen;
{if ("" != null) return new SqlJoin(joinType.getParserPosition(),
                e,
                natural,
                joinType,
                e2,
                JoinConditionType.NONE.symbol(joinType.getParserPosition()),
                null);}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JoinTable");
    }
}

// TODO jvs 15-Nov-2003:  SQL standard allows parentheses in the FROM list for
// building up non-linear join trees (e.g. OUTER JOIN two tables, and then INNER
// JOIN the result).  Also note that aliases on parenthesized FROM expressions
// "hide" all table names inside the parentheses (without aliases, they're
// visible).
//
// We allow CROSS JOIN to have a join condition, even though that is not valid
// SQL; the validator will catch it.
/**
 * Parses the FROM clause for a SELECT.
 *
 * <p>FROM is mandatory in standard SQL, optional in dialects such as MySQL,
 * PostgreSQL. The parser allows SELECT without FROM, but the validator fails
 * if conformance is, say, STRICT_2003.
 */
  final public SqlNode FromClause() throws ParseException {
    trace_call("FromClause");
    try {
SqlNode e, e2, condition;
    SqlLiteral natural, joinType, joinConditionType;
    SqlNodeList list;
    SqlParserPos pos;
      e = TableRef();
      label_8:
      while (true) {
        if (jj_2_21(2)) {
          ;
        } else {
          break label_8;
        }
        if (jj_2_22(2)) {
          natural = Natural();
          joinType = JoinType();
          e2 = TableRef();
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ON:{
            jj_consume_token(ON);
joinConditionType = JoinConditionType.ON.symbol(getPos());
            condition = Expression(ExprContext.ACCEPT_SUB_QUERY);
e = new SqlJoin(joinType.getParserPosition(),
                        e,
                        natural,
                        joinType,
                        e2,
                        joinConditionType,
                        condition);
            break;
            }
          case USING:{
            jj_consume_token(USING);
joinConditionType = JoinConditionType.USING.symbol(getPos());
            list = ParenthesizedSimpleIdentifierList();
e = new SqlJoin(joinType.getParserPosition(),
                        e,
                        natural,
                        joinType,
                        e2,
                        joinConditionType,
                        new SqlNodeList(list.getList(), Span.of(joinConditionType).end(this)));
            break;
            }
          default:
            jj_la1[66] = jj_gen;
e = new SqlJoin(joinType.getParserPosition(),
                        e,
                        natural,
                        joinType,
                        e2,
                        JoinConditionType.NONE.symbol(joinType.getParserPosition()),
                        null);
          }
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            jj_consume_token(COMMA);
joinType = JoinType.COMMA.symbol(getPos());
            e2 = TableRef();
e = new SqlJoin(joinType.getParserPosition(),
                    e,
                    SqlLiteral.createBoolean(false, joinType.getParserPosition()),
                    joinType,
                    e2,
                    JoinConditionType.NONE.symbol(SqlParserPos.ZERO),
                    null);
            break;
            }
          case CROSS:{
            jj_consume_token(CROSS);
joinType = JoinType.CROSS.symbol(getPos());
            jj_consume_token(APPLY);
            e2 = TableRef2(true);
if (!this.conformance.isApplyAllowed()) {
                    {if (true) throw new ParseException(RESOURCE.applyNotAllowed().str());}
                }
                e = new SqlJoin(joinType.getParserPosition(),
                    e,
                    SqlLiteral.createBoolean(false, joinType.getParserPosition()),
                    joinType,
                    e2,
                    JoinConditionType.NONE.symbol(SqlParserPos.ZERO),
                    null);
            break;
            }
          case OUTER:{
            jj_consume_token(OUTER);
joinType = JoinType.LEFT.symbol(getPos());
            jj_consume_token(APPLY);
            e2 = TableRef2(true);
if (!this.conformance.isApplyAllowed()) {
                    {if (true) throw new ParseException(RESOURCE.applyNotAllowed().str());}
                }
                e = new SqlJoin(joinType.getParserPosition(),
                    e,
                    SqlLiteral.createBoolean(false, joinType.getParserPosition()),
                    joinType,
                    e2,
                    JoinConditionType.ON.symbol(SqlParserPos.ZERO),
                    SqlLiteral.createBoolean(true, joinType.getParserPosition()));
            break;
            }
          default:
            jj_la1[67] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FromClause");
    }
}

/**
 * Parses a table reference in a FROM clause, not lateral unless LATERAL
 * is explicitly specified.
 */
  final public SqlNode TableRef() throws ParseException {
    trace_call("TableRef");
    try {
final SqlNode e;
      e = TableRef2(false);
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TableRef");
    }
}

/**
 * Parses a table reference in a FROM clause.
 */
  final public SqlNode TableRef2(boolean lateral) throws ParseException {
    trace_call("TableRef2");
    try {
SqlNode tableRef;
    final SqlNode over;
    final SqlNode snapshot;
    final SqlNode match;
    SqlNodeList extendList = null;
    final SqlIdentifier alias;
    final Span s, s2;
    SqlNodeList args;
    SqlNode sample;
    boolean isBernoulli;
    SqlNumericLiteral samplePercentage;
    boolean isRepeatable = false;
    int repeatableSeed = 0;
    SqlNodeList columnAliasList = null;
    SqlUnnestOperator unnestOp = SqlStdOperatorTable.UNNEST;
      if (jj_2_23(2)) {
        tableRef = CompoundIdentifier();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXTEND:
        case LPAREN:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EXTEND:{
            jj_consume_token(EXTEND);
            break;
            }
          default:
            jj_la1[68] = jj_gen;
            ;
          }
          extendList = ExtendList();
tableRef = extend(tableRef, extendList);
          break;
          }
        default:
          jj_la1[69] = jj_gen;
          ;
        }
        over = TableOverOpt();
if (over != null) {
                tableRef = SqlStdOperatorTable.OVER.createCall(
                    getPos(), tableRef, over);
            }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FOR:{
          snapshot = Snapshot(tableRef);
tableRef = SqlStdOperatorTable.LATERAL.createCall(
                    getPos(), snapshot);
          break;
          }
        default:
          jj_la1[70] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MATCH_RECOGNIZE:{
          tableRef = MatchRecognize(tableRef);
          break;
          }
        default:
          jj_la1[71] = jj_gen;
          ;
        }
      } else if (jj_2_24(2)) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LATERAL:{
          jj_consume_token(LATERAL);
lateral = true;
          break;
          }
        default:
          jj_la1[72] = jj_gen;
          ;
        }
        tableRef = ParenthesizedExpression(ExprContext.ACCEPT_QUERY);
        over = TableOverOpt();
if (over != null) {
                tableRef = SqlStdOperatorTable.OVER.createCall(
                    getPos(), tableRef, over);
            }
            if (lateral) {
                tableRef = SqlStdOperatorTable.LATERAL.createCall(
                    getPos(), tableRef);
            }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MATCH_RECOGNIZE:{
          tableRef = MatchRecognize(tableRef);
          break;
          }
        default:
          jj_la1[73] = jj_gen;
          ;
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UNNEST:{
          jj_consume_token(UNNEST);
s = span();
          args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUB_QUERY);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case WITH:{
            jj_consume_token(WITH);
            jj_consume_token(ORDINALITY);
unnestOp = SqlStdOperatorTable.UNNEST_WITH_ORDINALITY;
            break;
            }
          default:
            jj_la1[74] = jj_gen;
            ;
          }
tableRef = unnestOp.createCall(s.end(this), args.toArray());
          break;
          }
        case LATERAL:
        case TABLE:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LATERAL:{
            jj_consume_token(LATERAL);
lateral = true;
            break;
            }
          default:
            jj_la1[75] = jj_gen;
            ;
          }
          jj_consume_token(TABLE);
s = span();
          jj_consume_token(LPAREN);
          tableRef = TableFunctionCall(s.pos());
          jj_consume_token(RPAREN);
if (lateral) {
                tableRef = SqlStdOperatorTable.LATERAL.createCall(
                    s.end(this), tableRef);
            }
          break;
          }
        default:
          jj_la1[76] = jj_gen;
          if (jj_2_25(1)) {
            tableRef = ExtendedTableRef();
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case AS:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case AS:{
          jj_consume_token(AS);
          break;
          }
        default:
          jj_la1[77] = jj_gen;
          ;
        }
        alias = SimpleIdentifier();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          columnAliasList = ParenthesizedSimpleIdentifierList();
          break;
          }
        default:
          jj_la1[78] = jj_gen;
          ;
        }
if (columnAliasList == null) {
                tableRef = SqlStdOperatorTable.AS.createCall(
                    Span.of(tableRef).end(this), tableRef, alias);
            } else {
                List<SqlNode> idList = new ArrayList<SqlNode>();
                idList.add(tableRef);
                idList.add(alias);
                idList.addAll(columnAliasList.getList());
                tableRef = SqlStdOperatorTable.AS.createCall(
                    Span.of(tableRef).end(this), idList);
            }
        break;
        }
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TABLESAMPLE:{
        jj_consume_token(TABLESAMPLE);
s2 = span();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SUBSTITUTE:{
          jj_consume_token(SUBSTITUTE);
          jj_consume_token(LPAREN);
          sample = StringLiteral();
          jj_consume_token(RPAREN);
String sampleName =
                    SqlLiteral.unchain(sample).getValueAs(String.class);
                SqlSampleSpec sampleSpec = SqlSampleSpec.createNamed(sampleName);
                final SqlLiteral sampleLiteral =
                    SqlLiteral.createSample(sampleSpec, s2.end(this));
                tableRef = SqlStdOperatorTable.TABLESAMPLE.createCall(
                    s2.add(tableRef).end(this), tableRef, sampleLiteral);
          break;
          }
        case BERNOULLI:
        case SYSTEM:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case BERNOULLI:{
            jj_consume_token(BERNOULLI);
isBernoulli = true;
            break;
            }
          case SYSTEM:{
            jj_consume_token(SYSTEM);
isBernoulli = false;
            break;
            }
          default:
            jj_la1[80] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(LPAREN);
          samplePercentage = UnsignedNumericLiteral();
          jj_consume_token(RPAREN);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case REPEATABLE:{
            jj_consume_token(REPEATABLE);
            jj_consume_token(LPAREN);
            repeatableSeed = IntLiteral();
            jj_consume_token(RPAREN);
isRepeatable = true;
            break;
            }
          default:
            jj_la1[81] = jj_gen;
            ;
          }
final BigDecimal ONE_HUNDRED = BigDecimal.valueOf(100L);
                BigDecimal rate = samplePercentage.bigDecimalValue();
                if (rate.compareTo(BigDecimal.ZERO) < 0
                    || rate.compareTo(ONE_HUNDRED) > 0)
                {
                    {if (true) throw new ParseException(RESOURCE.invalidSampleSize().str());}
                }

                // Treat TABLESAMPLE(0) and TABLESAMPLE(100) as no table
                // sampling at all.  Not strictly correct: TABLESAMPLE(0)
                // should produce no output, but it simplifies implementation
                // to know that some amount of sampling will occur.
                // In practice values less than ~1E-43% are treated as 0.0 and
                // values greater than ~99.999997% are treated as 1.0
                float fRate = rate.divide(ONE_HUNDRED).floatValue();
                if (fRate > 0.0f && fRate < 1.0f) {
                    SqlSampleSpec tableSampleSpec =
                    isRepeatable
                        ? SqlSampleSpec.createTableSample(
                            isBernoulli, fRate, repeatableSeed)
                        : SqlSampleSpec.createTableSample(isBernoulli, fRate);

                    SqlLiteral tableSampleLiteral =
                        SqlLiteral.createSample(tableSampleSpec, s2.end(this));
                    tableRef = SqlStdOperatorTable.TABLESAMPLE.createCall(
                        s2.end(this), tableRef, tableSampleLiteral);
                }
          break;
          }
        default:
          jj_la1[82] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[83] = jj_gen;
        ;
      }
{if ("" != null) return tableRef;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TableRef2");
    }
}

  final public SqlNodeList ExtendList() throws ParseException {
    trace_call("ExtendList");
    try {
final Span s;
    List<SqlNode> list = new ArrayList<SqlNode>();
      jj_consume_token(LPAREN);
s = span();
      ColumnType(list);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[84] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        ColumnType(list);
      }
      jj_consume_token(RPAREN);
{if ("" != null) return new SqlNodeList(list, s.end(this));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExtendList");
    }
}

  final public void ColumnType(List<SqlNode> list) throws ParseException {
    trace_call("ColumnType");
    try {
SqlIdentifier name;
    SqlDataTypeSpec type;
    boolean nullable = true;
      name = CompoundIdentifier();
      type = DataType();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT:{
        jj_consume_token(NOT);
        jj_consume_token(NULL);
nullable = false;
        break;
        }
      default:
        jj_la1[85] = jj_gen;
        ;
      }
list.add(name);
        list.add(type.withNullable(nullable));
    } finally {
      trace_return("ColumnType");
    }
}

/**
 * Parses a compound identifier with optional type.
 */
  final public void CompoundIdentifierType(List<SqlNode> list, List<SqlNode> extendList) throws ParseException {
    trace_call("CompoundIdentifierType");
    try {
final SqlIdentifier name;
    SqlDataTypeSpec type = null;
    boolean nullable = true;
      name = CompoundIdentifier();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case ANY:
      case APPLY:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BIGINT:
      case BINARY:
      case BOOLEAN:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHAR:
      case CHARACTER:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DEC:
      case DECADE:
      case DECIMAL:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOUBLE:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FLOAT:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INT:
      case INTEGER:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MULTISET:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case NUMERIC:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case REAL:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SMALLINT:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIME:
      case TIMESTAMP:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TINYINT:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VARBINARY:
      case VARCHAR:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        type = DataType();
if (!this.conformance.allowExtend()) {
                {if (true) throw new ParseException(RESOURCE.extendNotAllowed().str());}
            }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NOT:{
          jj_consume_token(NOT);
          jj_consume_token(NULL);
nullable = false;
          break;
          }
        default:
          jj_la1[86] = jj_gen;
          ;
        }
        break;
        }
      default:
        jj_la1[87] = jj_gen;
        ;
      }
if (type != null) {
           extendList.add(name);
           extendList.add(type.withNullable(nullable));
       }
       list.add(name);
    } finally {
      trace_return("CompoundIdentifierType");
    }
}

  final public SqlNode TableFunctionCall(SqlParserPos pos) throws ParseException {
    trace_call("TableFunctionCall");
    try {
SqlNode call;
    SqlFunctionCategory funcType = SqlFunctionCategory.USER_DEFINED_TABLE_FUNCTION;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SPECIFIC:{
        jj_consume_token(SPECIFIC);
funcType = SqlFunctionCategory.USER_DEFINED_TABLE_SPECIFIC_FUNCTION;
        break;
        }
      default:
        jj_la1[88] = jj_gen;
        ;
      }
      call = NamedRoutineCall(funcType, ExprContext.ACCEPT_CURSOR);
{if ("" != null) return SqlStdOperatorTable.COLLECTION_TABLE.createCall(pos, call);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TableFunctionCall");
    }
}

/**
 * Abstract production:
 *    SqlNode ExtendedTableRef()
 *
 * <p>Allows parser to be extended with new types of table references.  The
 * default implementation of this production is empty.
 */

/*
 * Abstract production:
 *
 *    SqlNode TableOverOpt()
 *
 * Allows an OVER clause following a table expression as an extension to
 * standard SQL syntax. The default implementation of this production is empty.
 */

/**
 * Parses an explicit TABLE t reference.
 */
  final public SqlNode ExplicitTable(SqlParserPos pos) throws ParseException {
    trace_call("ExplicitTable");
    try {
SqlNode tableRef;
      jj_consume_token(TABLE);
      tableRef = CompoundIdentifier();
{if ("" != null) return SqlStdOperatorTable.EXPLICIT_TABLE.createCall(pos, tableRef);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExplicitTable");
    }
}

/**
 * Parses a VALUES leaf query expression.
 */
  final public SqlNode TableConstructor() throws ParseException {
    trace_call("TableConstructor");
    try {
SqlNodeList rowConstructorList;
    final Span s;
      jj_consume_token(VALUES);
s = span();
      rowConstructorList = RowConstructorList(s);
{if ("" != null) return SqlStdOperatorTable.VALUES.createCall(
            s.end(this), rowConstructorList.toArray());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TableConstructor");
    }
}

/**
 * Parses one or more rows in a VALUES expression.
 */
  final public SqlNodeList RowConstructorList(Span s) throws ParseException {
    trace_call("RowConstructorList");
    try {
List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode rowConstructor;
      rowConstructor = RowConstructor();
list.add(rowConstructor);
      label_10:
      while (true) {
        if (jj_2_26(2)) {
          ;
        } else {
          break label_10;
        }
        jj_consume_token(COMMA);
        rowConstructor = RowConstructor();
list.add(rowConstructor);
      }
{if ("" != null) return new SqlNodeList(list, s.end(this));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RowConstructorList");
    }
}

/**
 * Parses a row constructor in the context of a VALUES expression.
 */
  final public SqlNode RowConstructor() throws ParseException {
    trace_call("RowConstructor");
    try {
SqlNodeList valueList;
    SqlNode value;
    final Span s;
      if (jj_2_27(3)) {
        jj_consume_token(LPAREN);
s = span();
        jj_consume_token(ROW);
        valueList = ParenthesizedQueryOrCommaListWithDefault(ExprContext.ACCEPT_NONCURSOR);
        jj_consume_token(RPAREN);
s.add(this);
      } else if (jj_2_28(3)) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ROW:{
          jj_consume_token(ROW);
s = span();
          break;
          }
        default:
          jj_la1[89] = jj_gen;
s = Span.of();
        }
        valueList = ParenthesizedQueryOrCommaListWithDefault(ExprContext.ACCEPT_NONCURSOR);
      } else if (jj_2_29(1)) {
        value = Expression(ExprContext.ACCEPT_NONCURSOR);
// NOTE: A bare value here is standard SQL syntax, believe it or
            // not.  Taken together with multi-row table constructors, it leads
            // to very easy mistakes if you forget the parentheses on a
            // single-row constructor.  This is also the reason for the
            // LOOKAHEAD in RowConstructorList().  It would be so much more
            // reasonable to require parentheses.  Sigh.
            s = Span.of(value);
            valueList = new SqlNodeList(Collections.singletonList(value),
                value.getParserPosition());
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
// REVIEW jvs 8-Feb-2004: Should we discriminate between scalar
        // sub-queries inside of ROW and row sub-queries?  The standard does,
        // but the distinction seems to be purely syntactic.
        {if ("" != null) return SqlStdOperatorTable.ROW.createCall(s.end(valueList),
            valueList.toArray());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("RowConstructor");
    }
}

/**
 * Parses the optional WHERE clause for SELECT, DELETE, and UPDATE.
 */
  final public SqlNode WhereOpt() throws ParseException {
    trace_call("WhereOpt");
    try {
SqlNode condition;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WHERE:{
        jj_consume_token(WHERE);
        condition = Expression(ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return condition;}
        break;
        }
      default:
        jj_la1[90] = jj_gen;
{if ("" != null) return null;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WhereOpt");
    }
}

/**
 * Parses the optional GROUP BY clause for SELECT.
 */
  final public SqlNodeList GroupByOpt() throws ParseException {
    trace_call("GroupByOpt");
    try {
List<SqlNode> list = new ArrayList<SqlNode>();
    final Span s;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case GROUP:{
        jj_consume_token(GROUP);
s = span();
        jj_consume_token(BY);
        list = GroupingElementList();
{if ("" != null) return new SqlNodeList(list, s.addAll(list).pos());}
        break;
        }
      default:
        jj_la1[91] = jj_gen;
{if ("" != null) return null;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GroupByOpt");
    }
}

  final public List<SqlNode> GroupingElementList() throws ParseException {
    trace_call("GroupingElementList");
    try {
List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode e;
      e = GroupingElement();
list.add(e);
      label_11:
      while (true) {
        if (jj_2_30(2)) {
          ;
        } else {
          break label_11;
        }
        jj_consume_token(COMMA);
        e = GroupingElement();
list.add(e);
      }
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GroupingElementList");
    }
}

  final public SqlNode GroupingElement() throws ParseException {
    trace_call("GroupingElement");
    try {
List<SqlNode> list;
    final SqlNodeList nodes;
    final SqlNode e;
    final Span s;
      if (jj_2_31(2)) {
        jj_consume_token(GROUPING);
s = span();
        jj_consume_token(SETS);
        jj_consume_token(LPAREN);
        list = GroupingElementList();
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.GROUPING_SETS.createCall(s.end(this), list);}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ROLLUP:{
          jj_consume_token(ROLLUP);
s = span();
          jj_consume_token(LPAREN);
          nodes = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY);
          jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.ROLLUP.createCall(s.end(this),
            nodes.getList());}
          break;
          }
        case CUBE:{
          jj_consume_token(CUBE);
s = span();
          jj_consume_token(LPAREN);
          nodes = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY);
          jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.CUBE.createCall(s.end(this),
            nodes.getList());}
          break;
          }
        default:
          jj_la1[92] = jj_gen;
          if (jj_2_32(3)) {
            jj_consume_token(LPAREN);
            jj_consume_token(RPAREN);
{if ("" != null) return new SqlNodeList(getPos());}
          } else if (jj_2_33(1)) {
            e = Expression(ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return e;}
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("GroupingElement");
    }
}

/**
 * Parses a list of expressions separated by commas.
 */
  final public SqlNodeList ExpressionCommaList(final Span s,
    ExprContext exprContext) throws ParseException {
    trace_call("ExpressionCommaList");
    try {
List<SqlNode> list;
    SqlNode e;
      e = Expression(exprContext);
list = startList(e);
      label_12:
      while (true) {
        if (jj_2_34(2)) {
          ;
        } else {
          break label_12;
        }
        jj_consume_token(COMMA);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
list.add(e);
      }
{if ("" != null) return new SqlNodeList(list, s.addAll(list).pos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ExpressionCommaList");
    }
}

/**
 * Parses the optional HAVING clause for SELECT.
 */
  final public SqlNode HavingOpt() throws ParseException {
    trace_call("HavingOpt");
    try {
SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case HAVING:{
        jj_consume_token(HAVING);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return e;}
        break;
        }
      default:
        jj_la1[93] = jj_gen;
{if ("" != null) return null;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("HavingOpt");
    }
}

/**
 * Parses the optional WINDOW clause for SELECT
 */
  final public SqlNodeList WindowOpt() throws ParseException {
    trace_call("WindowOpt");
    try {
SqlIdentifier id;
    SqlWindow e;
    List<SqlNode> list;
    final Span s;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WINDOW:{
        jj_consume_token(WINDOW);
s = span();
        id = SimpleIdentifier();
        jj_consume_token(AS);
        e = WindowSpecification();
e.setDeclName(id);
        list = startList(e);
        label_13:
        while (true) {
          if (jj_2_35(2)) {
            ;
          } else {
            break label_13;
          }
          jj_consume_token(COMMA);
          id = SimpleIdentifier();
          jj_consume_token(AS);
          e = WindowSpecification();
e.setDeclName(id);
            list.add(e);
        }
{if ("" != null) return new SqlNodeList(list, s.addAll(list).pos());}
        break;
        }
      default:
        jj_la1[94] = jj_gen;
{if ("" != null) return null;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WindowOpt");
    }
}

/**
 * Parses a window specification.
 */
  final public SqlWindow WindowSpecification() throws ParseException {
    trace_call("WindowSpecification");
    try {
SqlIdentifier id;
    List list;
    SqlNodeList partitionList;
    SqlNodeList orderList;
    SqlLiteral isRows = SqlLiteral.createBoolean(false, SqlParserPos.ZERO);
    SqlNode lowerBound = null, upperBound = null;
    SqlParserPos startPos;
    final Span s, s1, s2;
    SqlLiteral allowPartial = null;
      jj_consume_token(LPAREN);
s = span();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        id = SimpleIdentifier();
        break;
        }
      default:
        jj_la1[95] = jj_gen;
id = null;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PARTITION:{
        jj_consume_token(PARTITION);
s1 = span();
        jj_consume_token(BY);
        partitionList = ExpressionCommaList(s1, ExprContext.ACCEPT_NON_QUERY);
        break;
        }
      default:
        jj_la1[96] = jj_gen;
partitionList = SqlNodeList.EMPTY;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ORDER:{
        orderList = OrderBy(true);
        break;
        }
      default:
        jj_la1[97] = jj_gen;
orderList = SqlNodeList.EMPTY;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RANGE:
      case ROWS:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ROWS:{
          jj_consume_token(ROWS);
isRows = SqlLiteral.createBoolean(true, getPos());
          break;
          }
        case RANGE:{
          jj_consume_token(RANGE);
isRows = SqlLiteral.createBoolean(false, getPos());
          break;
          }
        default:
          jj_la1[98] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BETWEEN:{
          jj_consume_token(BETWEEN);
          lowerBound = WindowRange();
          jj_consume_token(AND);
          upperBound = WindowRange();
          break;
          }
        default:
          jj_la1[99] = jj_gen;
          if (jj_2_36(1)) {
            lowerBound = WindowRange();
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
        }
      default:
        jj_la1[100] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ALLOW:
      case DISALLOW:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALLOW:{
          jj_consume_token(ALLOW);
s2 = span();
          jj_consume_token(PARTIAL);
allowPartial = SqlLiteral.createBoolean(true, s2.end(this));
          break;
          }
        case DISALLOW:{
          jj_consume_token(DISALLOW);
s2 = span();
          jj_consume_token(PARTIAL);
allowPartial = SqlLiteral.createBoolean(false, s2.end(this));
          break;
          }
        default:
          jj_la1[101] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[102] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
{if ("" != null) return SqlWindow.create(
            null, id, partitionList, orderList,
            isRows, lowerBound, upperBound, allowPartial, s.end(this));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WindowSpecification");
    }
}

  final public SqlNode WindowRange() throws ParseException {
    trace_call("WindowRange");
    try {
final SqlNode e;
    final Span s;
      if (jj_2_37(2)) {
        jj_consume_token(CURRENT);
s = span();
        jj_consume_token(ROW);
{if ("" != null) return SqlWindow.createCurrentRow(s.end(this));}
      } else if (jj_2_38(2)) {
        jj_consume_token(UNBOUNDED);
s = span();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PRECEDING:{
          jj_consume_token(PRECEDING);
{if ("" != null) return SqlWindow.createUnboundedPreceding(s.end(this));}
          break;
          }
        case FOLLOWING:{
          jj_consume_token(FOLLOWING);
{if ("" != null) return SqlWindow.createUnboundedFollowing(s.end(this));}
          break;
          }
        default:
          jj_la1[103] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else if (jj_2_39(1)) {
        e = Expression(ExprContext.ACCEPT_NON_QUERY);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PRECEDING:{
          jj_consume_token(PRECEDING);
{if ("" != null) return SqlWindow.createPreceding(e, getPos());}
          break;
          }
        case FOLLOWING:{
          jj_consume_token(FOLLOWING);
{if ("" != null) return SqlWindow.createFollowing(e, getPos());}
          break;
          }
        default:
          jj_la1[104] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WindowRange");
    }
}

/**
 * Parses an ORDER BY clause.
 */
  final public SqlNodeList OrderBy(boolean accept) throws ParseException {
    trace_call("OrderBy");
    try {
List<SqlNode> list;
    SqlNode e;
    final Span s;
      jj_consume_token(ORDER);
s = span();
        if (!accept) {
            // Someone told us ORDER BY wasn't allowed here.  So why
            // did they bother calling us?  To get the correct
            // parser position for error reporting.
            {if (true) throw SqlUtil.newContextException(s.pos(), RESOURCE.illegalOrderBy());}
        }
      jj_consume_token(BY);
      e = OrderItem();
list = startList(e);
      label_14:
      while (true) {
        if (jj_2_40(2)) {
          ;
        } else {
          break label_14;
        }
        jj_consume_token(COMMA);
        e = OrderItem();
list.add(e);
      }
{if ("" != null) return new SqlNodeList(list, s.addAll(list).pos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("OrderBy");
    }
}

/**
 * Parses one list item in an ORDER BY clause.
 */
  final public SqlNode OrderItem() throws ParseException {
    trace_call("OrderItem");
    try {
SqlNode e;
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASC:
      case DESC:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ASC:{
          jj_consume_token(ASC);
          break;
          }
        case DESC:{
          jj_consume_token(DESC);
e = SqlStdOperatorTable.DESC.createCall(getPos(), e);
          break;
          }
        default:
          jj_la1[105] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[106] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NULLS:{
        if (jj_2_41(2)) {
          jj_consume_token(NULLS);
          jj_consume_token(FIRST);
e = SqlStdOperatorTable.NULLS_FIRST.createCall(getPos(), e);
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case NULLS:{
            jj_consume_token(NULLS);
            jj_consume_token(LAST);
e = SqlStdOperatorTable.NULLS_LAST.createCall(getPos(), e);
            break;
            }
          default:
            jj_la1[107] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
        }
      default:
        jj_la1[108] = jj_gen;
        ;
      }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("OrderItem");
    }
}

/**
 * Parses a FOR SYSTEM_TIME clause following a table expression.
 */
  final public SqlSnapshot Snapshot(SqlNode tableRef) throws ParseException {
    trace_call("Snapshot");
    try {
final Span s;
    final SqlNode e;
      jj_consume_token(FOR);
s = span();
      jj_consume_token(SYSTEM_TIME);
      jj_consume_token(AS);
      jj_consume_token(OF);
      e = Expression(ExprContext.ACCEPT_NON_QUERY);
{if ("" != null) return new SqlSnapshot(s.end(this), tableRef, e);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Snapshot");
    }
}

/**
 * Parses a MATCH_RECOGNIZE clause following a table expression.
 */
  final public SqlMatchRecognize MatchRecognize(SqlNode tableRef) throws ParseException {
    trace_call("MatchRecognize");
    try {
final Span s, s0, s1, s2;
    SqlNodeList measureList = SqlNodeList.EMPTY;
    SqlNodeList partitionList = SqlNodeList.EMPTY;
    SqlNodeList orderList = SqlNodeList.EMPTY;
    SqlNode pattern;
    SqlLiteral interval;
    SqlNodeList patternDefList;
    final SqlNode after;
    SqlParserPos pos;
    final SqlNode var;
    final SqlLiteral rowsPerMatch;
    SqlNodeList subsetList = SqlNodeList.EMPTY;
    SqlLiteral isStrictStarts = SqlLiteral.createBoolean(false, getPos());
    SqlLiteral isStrictEnds = SqlLiteral.createBoolean(false, getPos());
      jj_consume_token(MATCH_RECOGNIZE);
s = span();
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PARTITION:{
        jj_consume_token(PARTITION);
s2 = span();
        jj_consume_token(BY);
        partitionList = ExpressionCommaList(s2, ExprContext.ACCEPT_NON_QUERY);
        break;
        }
      default:
        jj_la1[109] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ORDER:{
        orderList = OrderBy(true);
        break;
        }
      default:
        jj_la1[110] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MEASURES:{
        jj_consume_token(MEASURES);
        measureList = MeasureColumnCommaList(span());
        break;
        }
      default:
        jj_la1[111] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ONE:{
        jj_consume_token(ONE);
s0 = span();
        jj_consume_token(ROW);
        jj_consume_token(PER);
        jj_consume_token(MATCH);
rowsPerMatch = SqlMatchRecognize.RowsPerMatchOption.ONE_ROW.symbol(s0.end(this));
        break;
        }
      case ALL:{
        jj_consume_token(ALL);
s0 = span();
        jj_consume_token(ROWS);
        jj_consume_token(PER);
        jj_consume_token(MATCH);
rowsPerMatch = SqlMatchRecognize.RowsPerMatchOption.ALL_ROWS.symbol(s0.end(this));
        break;
        }
      default:
        jj_la1[112] = jj_gen;
rowsPerMatch = null;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AFTER:{
        jj_consume_token(AFTER);
s1 = span();
        jj_consume_token(MATCH);
        jj_consume_token(SKIP_);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TO:{
          jj_consume_token(TO);
          if (jj_2_42(2)) {
            jj_consume_token(NEXT);
            jj_consume_token(ROW);
after = SqlMatchRecognize.AfterOption.SKIP_TO_NEXT_ROW
                        .symbol(s1.end(this));
          } else if (jj_2_43(2)) {
            jj_consume_token(FIRST);
            var = SimpleIdentifier();
after = SqlMatchRecognize.SKIP_TO_FIRST.createCall(
                        s1.end(var), var);
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case A:
            case ABSENT:
            case ABSOLUTE:
            case ACTION:
            case ADA:
            case ADD:
            case ADMIN:
            case AFTER:
            case ALWAYS:
            case APPLY:
            case ASC:
            case ASSERTION:
            case ASSIGNMENT:
            case ATTRIBUTE:
            case ATTRIBUTES:
            case BEFORE:
            case BERNOULLI:
            case BREADTH:
            case C:
            case CASCADE:
            case CATALOG:
            case CATALOG_NAME:
            case CENTURY:
            case CHAIN:
            case CHARACTER_SET_CATALOG:
            case CHARACTER_SET_NAME:
            case CHARACTER_SET_SCHEMA:
            case CHARACTERISTICS:
            case CHARACTERS:
            case CLASS_ORIGIN:
            case COBOL:
            case COLLATION:
            case COLLATION_CATALOG:
            case COLLATION_NAME:
            case COLLATION_SCHEMA:
            case COLUMN_NAME:
            case COMMAND_FUNCTION:
            case COMMAND_FUNCTION_CODE:
            case COMMITTED:
            case CONDITIONAL:
            case CONDITION_NUMBER:
            case CONNECTION:
            case CONNECTION_NAME:
            case CONSTRAINT_CATALOG:
            case CONSTRAINT_NAME:
            case CONSTRAINT_SCHEMA:
            case CONSTRAINTS:
            case CONSTRUCTOR:
            case CONTINUE:
            case CURSOR_NAME:
            case DATA:
            case DATABASE:
            case DATETIME_INTERVAL_CODE:
            case DATETIME_INTERVAL_PRECISION:
            case DECADE:
            case DEFAULTS:
            case DEFERRABLE:
            case DEFERRED:
            case DEFINED:
            case DEFINER:
            case DEGREE:
            case DEPTH:
            case DERIVED:
            case DESC:
            case DESCRIPTION:
            case DESCRIPTOR:
            case DIAGNOSTICS:
            case DISPATCH:
            case DOMAIN:
            case DOW:
            case DOY:
            case DYNAMIC_FUNCTION:
            case DYNAMIC_FUNCTION_CODE:
            case ENCODING:
            case EPOCH:
            case ERROR:
            case EXCEPTION:
            case EXCLUDE:
            case EXCLUDING:
            case FINAL:
            case FIRST:
            case FOLLOWING:
            case FORMAT:
            case FORTRAN:
            case FOUND:
            case FRAC_SECOND:
            case G:
            case GENERAL:
            case GENERATED:
            case GEOMETRY:
            case GO:
            case GOTO:
            case GRANTED:
            case HIERARCHY:
            case IMMEDIATE:
            case IMMEDIATELY:
            case IMPLEMENTATION:
            case INCLUDING:
            case INCREMENT:
            case INITIALLY:
            case INPUT:
            case INSTANCE:
            case INSTANTIABLE:
            case INVOKER:
            case ISODOW:
            case ISOYEAR:
            case ISOLATION:
            case JAVA:
            case JSON:
            case JSON_PRETTY:
            case JSON_TYPE:
            case JSON_DEPTH:
            case K:
            case KEY:
            case KEY_MEMBER:
            case KEY_TYPE:
            case LABEL:
            case LAST:
            case LENGTH:
            case LEVEL:
            case LIBRARY:
            case LOCATOR:
            case M:
            case MAP:
            case MATCHED:
            case MAXVALUE:
            case MESSAGE_LENGTH:
            case MESSAGE_OCTET_LENGTH:
            case MESSAGE_TEXT:
            case MICROSECOND:
            case MILLISECOND:
            case MILLENNIUM:
            case MINVALUE:
            case MORE_:
            case MUMPS:
            case NAME:
            case NAMES:
            case NANOSECOND:
            case NESTING:
            case NORMALIZED:
            case NULLABLE:
            case NULLS:
            case NUMBER:
            case OBJECT:
            case OCTETS:
            case OPTION:
            case OPTIONS:
            case ORDERING:
            case ORDINALITY:
            case OTHERS:
            case OUTPUT:
            case OVERRIDING:
            case PAD:
            case PARAMETER_MODE:
            case PARAMETER_NAME:
            case PARAMETER_ORDINAL_POSITION:
            case PARAMETER_SPECIFIC_CATALOG:
            case PARAMETER_SPECIFIC_NAME:
            case PARAMETER_SPECIFIC_SCHEMA:
            case PARTIAL:
            case PASCAL:
            case PASSING:
            case PASSTHROUGH:
            case PAST:
            case PATH:
            case PLACING:
            case PLAN:
            case PLI:
            case PRECEDING:
            case PRESERVE:
            case PRIOR:
            case PRIVILEGES:
            case PUBLIC:
            case QUARTER:
            case READ:
            case RELATIVE:
            case REPEATABLE:
            case REPLACE:
            case RESTART:
            case RESTRICT:
            case RETURNED_CARDINALITY:
            case RETURNED_LENGTH:
            case RETURNED_OCTET_LENGTH:
            case RETURNED_SQLSTATE:
            case RETURNING:
            case ROLE:
            case ROUTINE:
            case ROUTINE_CATALOG:
            case ROUTINE_NAME:
            case ROUTINE_SCHEMA:
            case ROW_COUNT:
            case SCALAR:
            case SCALE:
            case SCHEMA:
            case SCHEMA_NAME:
            case SCOPE_CATALOGS:
            case SCOPE_NAME:
            case SCOPE_SCHEMA:
            case SECTION:
            case SECURITY:
            case SELF:
            case SEQUENCE:
            case SERIALIZABLE:
            case SERVER:
            case SERVER_NAME:
            case SESSION:
            case SETS:
            case SIMPLE:
            case SIZE:
            case SOURCE:
            case SPACE:
            case SPECIFIC_NAME:
            case SQL_BIGINT:
            case SQL_BINARY:
            case SQL_BIT:
            case SQL_BLOB:
            case SQL_BOOLEAN:
            case SQL_CHAR:
            case SQL_CLOB:
            case SQL_DATE:
            case SQL_DECIMAL:
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_INTEGER:
            case SQL_INTERVAL_DAY:
            case SQL_INTERVAL_DAY_TO_HOUR:
            case SQL_INTERVAL_DAY_TO_MINUTE:
            case SQL_INTERVAL_DAY_TO_SECOND:
            case SQL_INTERVAL_HOUR:
            case SQL_INTERVAL_HOUR_TO_MINUTE:
            case SQL_INTERVAL_HOUR_TO_SECOND:
            case SQL_INTERVAL_MINUTE:
            case SQL_INTERVAL_MINUTE_TO_SECOND:
            case SQL_INTERVAL_MONTH:
            case SQL_INTERVAL_SECOND:
            case SQL_INTERVAL_YEAR:
            case SQL_INTERVAL_YEAR_TO_MONTH:
            case SQL_LONGVARBINARY:
            case SQL_LONGVARCHAR:
            case SQL_LONGVARNCHAR:
            case SQL_NCHAR:
            case SQL_NCLOB:
            case SQL_NUMERIC:
            case SQL_NVARCHAR:
            case SQL_REAL:
            case SQL_SMALLINT:
            case SQL_TIME:
            case SQL_TIMESTAMP:
            case SQL_TINYINT:
            case SQL_TSI_DAY:
            case SQL_TSI_FRAC_SECOND:
            case SQL_TSI_HOUR:
            case SQL_TSI_MICROSECOND:
            case SQL_TSI_MINUTE:
            case SQL_TSI_MONTH:
            case SQL_TSI_QUARTER:
            case SQL_TSI_SECOND:
            case SQL_TSI_WEEK:
            case SQL_TSI_YEAR:
            case SQL_VARBINARY:
            case SQL_VARCHAR:
            case STATE:
            case STATEMENT:
            case STRUCTURE:
            case STYLE:
            case SUBCLASS_ORIGIN:
            case SUBSTITUTE:
            case TABLE_NAME:
            case TEMPORARY:
            case TIES:
            case TIMESTAMPADD:
            case TIMESTAMPDIFF:
            case TOP_LEVEL_COUNT:
            case TRANSACTION:
            case TRANSACTIONS_ACTIVE:
            case TRANSACTIONS_COMMITTED:
            case TRANSACTIONS_ROLLED_BACK:
            case TRANSFORM:
            case TRANSFORMS:
            case TRIGGER_CATALOG:
            case TRIGGER_NAME:
            case TRIGGER_SCHEMA:
            case TYPE:
            case UNBOUNDED:
            case UNCOMMITTED:
            case UNCONDITIONAL:
            case UNDER:
            case UNNAMED:
            case USAGE:
            case USER_DEFINED_TYPE_CATALOG:
            case USER_DEFINED_TYPE_CODE:
            case USER_DEFINED_TYPE_NAME:
            case USER_DEFINED_TYPE_SCHEMA:
            case UTF8:
            case UTF16:
            case UTF32:
            case VERSION:
            case VIEW:
            case WEEK:
            case WORK:
            case WRAPPER:
            case WRITE:
            case XML:
            case ZONE:
            case BRACKET_QUOTED_IDENTIFIER:
            case QUOTED_IDENTIFIER:
            case BACK_QUOTED_IDENTIFIER:
            case IDENTIFIER:
            case UNICODE_QUOTED_IDENTIFIER:{
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case LAST:{
                jj_consume_token(LAST);
                break;
                }
              default:
                jj_la1[113] = jj_gen;
                ;
              }
              var = SimpleIdentifier();
after = SqlMatchRecognize.SKIP_TO_LAST.createCall(
                        s1.end(var), var);
              break;
              }
            default:
              jj_la1[114] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
          }
        case PAST:{
          jj_consume_token(PAST);
          jj_consume_token(LAST);
          jj_consume_token(ROW);
after = SqlMatchRecognize.AfterOption.SKIP_PAST_LAST_ROW
                     .symbol(s1.end(this));
          break;
          }
        default:
          jj_la1[115] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[116] = jj_gen;
after = null;
      }
      jj_consume_token(PATTERN);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CARET:{
        jj_consume_token(CARET);
isStrictStarts = SqlLiteral.createBoolean(true, getPos());
        break;
        }
      default:
        jj_la1[117] = jj_gen;
isStrictStarts = SqlLiteral.createBoolean(false, getPos());
      }
      pattern = PatternExpression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOLLAR:{
        jj_consume_token(DOLLAR);
isStrictEnds = SqlLiteral.createBoolean(true, getPos());
        break;
        }
      default:
        jj_la1[118] = jj_gen;
isStrictEnds = SqlLiteral.createBoolean(false, getPos());
      }
      jj_consume_token(RPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITHIN:{
        jj_consume_token(WITHIN);
        interval = IntervalLiteral();
        break;
        }
      default:
        jj_la1[119] = jj_gen;
interval = null;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SUBSET:{
        jj_consume_token(SUBSET);
        subsetList = SubsetDefinitionCommaList(span());
        break;
        }
      default:
        jj_la1[120] = jj_gen;
        ;
      }
      jj_consume_token(DEFINE);
      patternDefList = PatternDefinitionCommaList(span());
      jj_consume_token(RPAREN);
{if ("" != null) return new SqlMatchRecognize(s.end(this), tableRef,
            pattern, isStrictStarts, isStrictEnds, patternDefList, measureList,
            after, subsetList, rowsPerMatch, partitionList, orderList, interval);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MatchRecognize");
    }
}

  final public SqlNodeList MeasureColumnCommaList(Span s) throws ParseException {
    trace_call("MeasureColumnCommaList");
    try {
SqlNode e;
    final List<SqlNode> eList = new ArrayList<SqlNode>();
      e = MeasureColumn();
eList.add(e);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[121] = jj_gen;
          break label_15;
        }
        jj_consume_token(COMMA);
        e = MeasureColumn();
eList.add(e);
      }
{if ("" != null) return new SqlNodeList(eList, s.addAll(eList).pos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MeasureColumnCommaList");
    }
}

  final public SqlNode MeasureColumn() throws ParseException {
    trace_call("MeasureColumn");
    try {
SqlNode e;
    SqlIdentifier alias;
      e = Expression(ExprContext.ACCEPT_NON_QUERY);
      jj_consume_token(AS);
      alias = SimpleIdentifier();
{if ("" != null) return SqlStdOperatorTable.AS.createCall(Span.of(e).end(this), e, alias);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MeasureColumn");
    }
}

  final public SqlNode PatternExpression() throws ParseException {
    trace_call("PatternExpression");
    try {
SqlNode left;
    SqlNode right;
      left = PatternTerm();
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VERTICAL_BAR:{
          ;
          break;
          }
        default:
          jj_la1[122] = jj_gen;
          break label_16;
        }
        jj_consume_token(VERTICAL_BAR);
        right = PatternTerm();
left = SqlStdOperatorTable.PATTERN_ALTER.createCall(
                Span.of(left).end(right), left, right);
      }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PatternExpression");
    }
}

  final public SqlNode PatternTerm() throws ParseException {
    trace_call("PatternTerm");
    try {
SqlNode left;
    SqlNode right;
      left = PatternFactor();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PERMUTE:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case LPAREN:
        case LBRACE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[123] = jj_gen;
          break label_17;
        }
        right = PatternFactor();
left = SqlStdOperatorTable.PATTERN_CONCAT.createCall(
                Span.of(left).end(right), left, right);
      }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PatternTerm");
    }
}

  final public SqlNode PatternFactor() throws ParseException {
    trace_call("PatternFactor");
    try {
SqlNode e;
    SqlNode extra;
    SqlLiteral startNum = null;
    SqlLiteral endNum = null;
    SqlLiteral reluctant = SqlLiteral.createBoolean(false, SqlParserPos.ZERO);
      e = PatternPrimary();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:
      case HOOK:
      case PLUS:
      case STAR:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case STAR:{
          jj_consume_token(STAR);
startNum = SqlLiteral.createExactNumeric("0", SqlParserPos.ZERO);
                endNum = SqlLiteral.createExactNumeric("-1", SqlParserPos.ZERO);
          break;
          }
        case PLUS:{
          jj_consume_token(PLUS);
startNum = SqlLiteral.createExactNumeric("1", SqlParserPos.ZERO);
                endNum = SqlLiteral.createExactNumeric("-1", SqlParserPos.ZERO);
          break;
          }
        case HOOK:{
          jj_consume_token(HOOK);
startNum = SqlLiteral.createExactNumeric("0", SqlParserPos.ZERO);
                endNum = SqlLiteral.createExactNumeric("1", SqlParserPos.ZERO);
          break;
          }
        case LBRACE:{
          jj_consume_token(LBRACE);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case UNSIGNED_INTEGER_LITERAL:
          case APPROX_NUMERIC_LITERAL:
          case DECIMAL_NUMERIC_LITERAL:{
            startNum = UnsignedNumericLiteral();
endNum = startNum;
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case COMMA:{
              jj_consume_token(COMMA);
endNum = SqlLiteral.createExactNumeric("-1", SqlParserPos.ZERO);
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case UNSIGNED_INTEGER_LITERAL:
              case APPROX_NUMERIC_LITERAL:
              case DECIMAL_NUMERIC_LITERAL:{
                endNum = UnsignedNumericLiteral();
                break;
                }
              default:
                jj_la1[124] = jj_gen;
                ;
              }
              break;
              }
            default:
              jj_la1[125] = jj_gen;
              ;
            }
            jj_consume_token(RBRACE);
            break;
            }
          case COMMA:{
startNum = SqlLiteral.createExactNumeric("-1", SqlParserPos.ZERO);
            jj_consume_token(COMMA);
            endNum = UnsignedNumericLiteral();
            jj_consume_token(RBRACE);
            break;
            }
          case MINUS:{
            jj_consume_token(MINUS);
            extra = PatternExpression();
            jj_consume_token(MINUS);
            jj_consume_token(RBRACE);
extra = SqlStdOperatorTable.PATTERN_EXCLUDE.createCall(
                        Span.of(extra).end(this), extra);
                    e = SqlStdOperatorTable.PATTERN_CONCAT.createCall(
                        Span.of(e).end(this), e, extra);
                    {if ("" != null) return e;}
            break;
            }
          default:
            jj_la1[126] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[127] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case HOOK:{
          jj_consume_token(HOOK);
if (startNum.intValue(true) != endNum.intValue(true)) {
                    reluctant = SqlLiteral.createBoolean(true, SqlParserPos.ZERO);
                }
          break;
          }
        default:
          jj_la1[128] = jj_gen;
          ;
        }
        break;
        }
      default:
        jj_la1[129] = jj_gen;
        ;
      }
if (startNum == null) {
            {if ("" != null) return e;}
        } else {
            {if ("" != null) return SqlStdOperatorTable.PATTERN_QUANTIFIER.createCall(
                span().end(e), e, startNum, endNum, reluctant);}
        }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PatternFactor");
    }
}

  final public SqlNode PatternPrimary() throws ParseException {
    trace_call("PatternPrimary");
    try {
final Span s;
    SqlNode e;
    List<SqlNode> eList;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        e = SimpleIdentifier();
        break;
        }
      case LPAREN:{
        jj_consume_token(LPAREN);
        e = PatternExpression();
        jj_consume_token(RPAREN);
        break;
        }
      case LBRACE:{
        jj_consume_token(LBRACE);
s = span();
        jj_consume_token(MINUS);
        e = PatternExpression();
        jj_consume_token(MINUS);
        jj_consume_token(RBRACE);
e = SqlStdOperatorTable.PATTERN_EXCLUDE.createCall(s.end(this), e);
        break;
        }
      case PERMUTE:{
        jj_consume_token(PERMUTE);
s = span();
        jj_consume_token(LPAREN);
        e = PatternExpression();
eList = new ArrayList<SqlNode>();
                eList.add(e);
        label_18:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[130] = jj_gen;
            break label_18;
          }
          jj_consume_token(COMMA);
          e = PatternExpression();
eList.add(e);
        }
        jj_consume_token(RPAREN);
e = SqlStdOperatorTable.PATTERN_PERMUTE.createCall(
                    s.end(this), eList);
        break;
        }
      default:
        jj_la1[131] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PatternPrimary");
    }
}

  final public SqlNodeList SubsetDefinitionCommaList(Span s) throws ParseException {
    trace_call("SubsetDefinitionCommaList");
    try {
SqlNode e;
    final List<SqlNode> eList = new ArrayList<SqlNode>();
      e = SubsetDefinition();
eList.add(e);
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[132] = jj_gen;
          break label_19;
        }
        jj_consume_token(COMMA);
        e = SubsetDefinition();
eList.add(e);
      }
{if ("" != null) return new SqlNodeList(eList, s.addAll(eList).pos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SubsetDefinitionCommaList");
    }
}

  final public SqlNode SubsetDefinition() throws ParseException {
    trace_call("SubsetDefinition");
    try {
final SqlNode var;
    final SqlNodeList varList;
      var = SimpleIdentifier();
      jj_consume_token(EQ);
      jj_consume_token(LPAREN);
      varList = ExpressionCommaList(span(), ExprContext.ACCEPT_NON_QUERY);
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.EQUALS.createCall(span().end(var), var,
            varList);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SubsetDefinition");
    }
}

  final public SqlNodeList PatternDefinitionCommaList(Span s) throws ParseException {
    trace_call("PatternDefinitionCommaList");
    try {
SqlNode e;
    final List<SqlNode> eList = new ArrayList<SqlNode>();
      e = PatternDefinition();
eList.add(e);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[133] = jj_gen;
          break label_20;
        }
        jj_consume_token(COMMA);
        e = PatternDefinition();
eList.add(e);
      }
{if ("" != null) return new SqlNodeList(eList, s.addAll(eList).pos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PatternDefinitionCommaList");
    }
}

  final public SqlNode PatternDefinition() throws ParseException {
    trace_call("PatternDefinition");
    try {
final SqlNode var;
    final SqlNode e;
      var = SimpleIdentifier();
      jj_consume_token(AS);
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return SqlStdOperatorTable.AS.createCall(Span.of(var, e).pos(), e, var);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PatternDefinition");
    }
}

// ----------------------------------------------------------------------------
// Expressions

/**
 * Parses a SQL expression (such as might occur in a WHERE clause) followed by
 * the end-of-file symbol.
 */
  final public SqlNode SqlExpressionEof() throws ParseException {
    trace_call("SqlExpressionEof");
    try {
SqlNode e;
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
      jj_consume_token(0);
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlExpressionEof");
    }
}

/**
 * Parses either a row expression or a query expression without ORDER BY.
 */
  final public SqlNode QueryOrExpr(ExprContext exprContext) throws ParseException {
    trace_call("QueryOrExpr");
    try {
SqlNodeList withList = null;
    SqlNode e;
    SqlOperator op;
    SqlParserPos pos;
    SqlParserPos withPos;
    List<Object> list;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITH:{
        withList = WithList();
        break;
        }
      default:
        jj_la1[134] = jj_gen;
        ;
      }
      e = LeafQueryOrExpr(exprContext);
list = startList(e);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXCEPT:
        case INTERSECT:
        case SET_MINUS:
        case UNION:{
          ;
          break;
          }
        default:
          jj_la1[135] = jj_gen;
          break label_21;
        }
if (!e.isA(SqlKind.QUERY)) {
                // whoops, expression we just parsed wasn't a query,
                // but we're about to see something like UNION, so
                // force an exception retroactively
                checkNonQueryExpression(ExprContext.ACCEPT_QUERY);
            }
        op = BinaryQueryOperator();
// ensure a query is legal in this context
            pos = getPos();
            checkQueryExpression(exprContext);
        e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY);
list.add(new SqlParserUtil.ToTreeListItem(op, pos));
            list.add(e);
      }
e = SqlParserUtil.toTree(list);
        if (withList != null) {
            e = new SqlWith(withList.getParserPosition(), withList, e);
        }
        {if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("QueryOrExpr");
    }
}

  final public SqlNodeList WithList() throws ParseException {
    trace_call("WithList");
    try {
SqlWithItem withItem;
    SqlParserPos pos;
    SqlNodeList list;
      jj_consume_token(WITH);
list = new SqlNodeList(getPos());
      withItem = WithItem();
list.add(withItem);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[136] = jj_gen;
          break label_22;
        }
        jj_consume_token(COMMA);
        withItem = WithItem();
list.add(withItem);
      }
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WithList");
    }
}

  final public SqlWithItem WithItem() throws ParseException {
    trace_call("WithItem");
    try {
SqlIdentifier id;
    SqlNodeList columnList = null;
    SqlNode definition;
      id = SimpleIdentifier();
      if (jj_2_44(2)) {
        columnList = ParenthesizedSimpleIdentifierList();
      } else {
        ;
      }
      jj_consume_token(AS);
      definition = ParenthesizedExpression(ExprContext.ACCEPT_QUERY);
{if ("" != null) return new SqlWithItem(id.getParserPosition(), id, columnList,
            definition);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("WithItem");
    }
}

/**
 * Parses either a row expression, a leaf query expression, or
 * a parenthesized expression of any kind.
 */
  final public SqlNode LeafQueryOrExpr(ExprContext exprContext) throws ParseException {
    trace_call("LeafQueryOrExpr");
    try {
SqlNode e;
      if (jj_2_45(1)) {
        e = Expression(exprContext);
{if ("" != null) return e;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SELECT:
        case TABLE:
        case VALUES:{
          e = LeafQuery(exprContext);
{if ("" != null) return e;}
          break;
          }
        default:
          jj_la1[137] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("LeafQueryOrExpr");
    }
}

/**
 * Parses a row expression or a parenthesized expression of any kind.
 */
  final public SqlNode Expression(ExprContext exprContext) throws ParseException {
    trace_call("Expression");
    try {
List<Object> list;
    SqlNode e;
      list = Expression2(exprContext);
e = SqlParserUtil.toTree(list);
        {if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expression");
    }
}

// TODO jvs 15-Nov-2003:  ANY/ALL
  final public 
void Expression2b(ExprContext exprContext, List<Object> list) throws ParseException {
    trace_call("Expression2b");
    try {
SqlNode e;
    SqlOperator op;
    SqlIdentifier p;
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXISTS:
        case NOT:
        case PLUS:
        case MINUS:{
          ;
          break;
          }
        default:
          jj_la1[138] = jj_gen;
          break label_23;
        }
        op = PrefixRowOperator();
checkNonQueryExpression(exprContext);
            list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
      }
      e = Expression3(exprContext);
list.add(e);
      label_24:
      while (true) {
        if (jj_2_46(2)) {
          ;
        } else {
          break label_24;
        }
        jj_consume_token(DOT);
        p = SimpleIdentifier();
list.add(
                new SqlParserUtil.ToTreeListItem(
                    SqlStdOperatorTable.DOT, getPos()));
            list.add(p);
      }
    } finally {
      trace_return("Expression2b");
    }
}

/**
 * Parses a binary row expression, or a parenthesized expression of any
 * kind.
 *
 * <p>The result is as a flat list of operators and operands. The top-level
 * call to get an expression should call {@link #Expression}, but lower-level
 * calls should call this, to give the parser the opportunity to associate
 * operator calls.
 *
 * <p>For example 'a = b like c = d' should come out '((a = b) like c) = d'
 * because LIKE and '=' have the same precedence, but tends to come out as '(a
 * = b) like (c = d)' because (a = b) and (c = d) are parsed as separate
 * expressions.
 */
  final public List<Object> Expression2(ExprContext exprContext) throws ParseException {
    trace_call("Expression2");
    try {
final List<Object> list = new ArrayList();
    List<Object> list2;
    final List<Object> list3 = new ArrayList();
    SqlNodeList nodeList;
    SqlNode e;
    SqlOperator op;
    SqlIdentifier p;
    final Span s = span();
      Expression2b(exprContext, list);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:
      case BETWEEN:
      case CONTAINS:
      case EQUALS:
      case IMMEDIATELY:
      case IN:
      case IS:
      case LIKE:
      case MEMBER:
      case MULTISET:
      case NOT:
      case OR:
      case OVERLAPS:
      case PRECEDES:
      case SIMILAR:
      case SUBMULTISET:
      case SUCCEEDS:
      case LBRACKET:
      case EQ:
      case GT:
      case LT:
      case LE:
      case GE:
      case NE:
      case NE2:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case PERCENT_REMAINDER:
      case CONCAT:{
        label_25:
        while (true) {
          if (jj_2_49(2)) {
checkNonQueryExpression(exprContext);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case NOT:{
              jj_consume_token(NOT);
              jj_consume_token(IN);
op = SqlStdOperatorTable.NOT_IN;
              break;
              }
            case IN:{
              jj_consume_token(IN);
op = SqlStdOperatorTable.IN;
              break;
              }
            case EQ:
            case GT:
            case LT:
            case LE:
            case GE:
            case NE:
            case NE2:{
final SqlKind k;
              k = comp();
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case SOME:{
                jj_consume_token(SOME);
op = SqlStdOperatorTable.some(k);
                break;
                }
              case ANY:{
                jj_consume_token(ANY);
op = SqlStdOperatorTable.some(k);
                break;
                }
              case ALL:{
                jj_consume_token(ALL);
op = SqlStdOperatorTable.all(k);
                break;
                }
              default:
                jj_la1[139] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
              }
            default:
              jj_la1[140] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
s.clear().add(this);
            nodeList = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_NONCURSOR);
list.add(new SqlParserUtil.ToTreeListItem(op, s.pos()));
                    s.add(nodeList);
                    // special case for stuff like IN (s1 UNION s2)
                    if (nodeList.size() == 1) {
                        SqlNode item = nodeList.get(0);
                        if (item.isA(SqlKind.QUERY)) {
                            list.add(item);
                        } else {
                            list.add(nodeList);
                        }
                    } else {
                        list.add(nodeList);
                    }
          } else if (jj_2_50(2)) {
checkNonQueryExpression(exprContext);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case NOT:{
              jj_consume_token(NOT);
              jj_consume_token(BETWEEN);
op = SqlStdOperatorTable.NOT_BETWEEN;
                        s.clear().add(this);
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case ASYMMETRIC:
              case SYMMETRIC:{
                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                case SYMMETRIC:{
                  jj_consume_token(SYMMETRIC);
op = SqlStdOperatorTable.SYMMETRIC_NOT_BETWEEN;
                  break;
                  }
                case ASYMMETRIC:{
                  jj_consume_token(ASYMMETRIC);
                  break;
                  }
                default:
                  jj_la1[141] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
                break;
                }
              default:
                jj_la1[142] = jj_gen;
                ;
              }
              break;
              }
            case BETWEEN:{
              jj_consume_token(BETWEEN);
op = SqlStdOperatorTable.BETWEEN;
                        s.clear().add(this);
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case ASYMMETRIC:
              case SYMMETRIC:{
                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                case SYMMETRIC:{
                  jj_consume_token(SYMMETRIC);
op = SqlStdOperatorTable.SYMMETRIC_BETWEEN;
                  break;
                  }
                case ASYMMETRIC:{
                  jj_consume_token(ASYMMETRIC);
                  break;
                  }
                default:
                  jj_la1[143] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
                }
                break;
                }
              default:
                jj_la1[144] = jj_gen;
                ;
              }
              break;
              }
            default:
              jj_la1[145] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            Expression2b(ExprContext.ACCEPT_SUB_QUERY, list3);
list.add(new SqlParserUtil.ToTreeListItem(op, s.pos()));
                    list.addAll(list3);
                    list3.clear();
          } else if (jj_2_51(2)) {
checkNonQueryExpression(exprContext);
                    s.clear().add(this);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case NOT:{
              jj_consume_token(NOT);
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case LIKE:{
                jj_consume_token(LIKE);
op = SqlStdOperatorTable.NOT_LIKE;
                break;
                }
              case SIMILAR:{
                jj_consume_token(SIMILAR);
                jj_consume_token(TO);
op = SqlStdOperatorTable.NOT_SIMILAR_TO;
                break;
                }
              default:
                jj_la1[146] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
              }
            case LIKE:{
              jj_consume_token(LIKE);
op = SqlStdOperatorTable.LIKE;
              break;
              }
            case SIMILAR:{
              jj_consume_token(SIMILAR);
              jj_consume_token(TO);
op = SqlStdOperatorTable.SIMILAR_TO;
              break;
              }
            default:
              jj_la1[147] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            list2 = Expression2(ExprContext.ACCEPT_SUB_QUERY);
list.add(new SqlParserUtil.ToTreeListItem(op, s.pos()));
                    list.addAll(list2);
            if (jj_2_47(2)) {
              jj_consume_token(ESCAPE);
              e = Expression3(ExprContext.ACCEPT_SUB_QUERY);
s.clear().add(this);
                        list.add(
                            new SqlParserUtil.ToTreeListItem(
                                SqlStdOperatorTable.ESCAPE, s.pos()));
                        list.add(e);
            } else {
              ;
            }
          } else if (jj_2_52(3)) {
            op = BinaryRowOperator();
checkNonQueryExpression(exprContext);
                    list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
            Expression2b(ExprContext.ACCEPT_SUB_QUERY, list);
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case LBRACKET:{
              jj_consume_token(LBRACKET);
              e = Expression(ExprContext.ACCEPT_SUB_QUERY);
              jj_consume_token(RBRACKET);
list.add(
                        new SqlParserUtil.ToTreeListItem(
                            SqlStdOperatorTable.ITEM, getPos()));
                    list.add(e);
              label_26:
              while (true) {
                if (jj_2_48(2)) {
                  ;
                } else {
                  break label_26;
                }
                jj_consume_token(DOT);
                p = SimpleIdentifier();
list.add(
                            new SqlParserUtil.ToTreeListItem(
                                SqlStdOperatorTable.DOT, getPos()));
                        list.add(p);
              }
              break;
              }
            case IS:{
checkNonQueryExpression(exprContext);
              op = PostfixRowOperator();
list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
              break;
              }
            default:
              jj_la1[148] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          if (jj_2_53(2)) {
            ;
          } else {
            break label_25;
          }
        }
{if ("" != null) return list;}
        break;
        }
      default:
        jj_la1[149] = jj_gen;
{if ("" != null) return list;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expression2");
    }
}

/** Parses a comparison operator inside a SOME / ALL predicate. */
  final public SqlKind comp() throws ParseException {
    trace_call("comp");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
        jj_consume_token(LT);
{if ("" != null) return SqlKind.LESS_THAN;}
        break;
        }
      case LE:{
        jj_consume_token(LE);
{if ("" != null) return SqlKind.LESS_THAN_OR_EQUAL;}
        break;
        }
      case GT:{
        jj_consume_token(GT);
{if ("" != null) return SqlKind.GREATER_THAN;}
        break;
        }
      case GE:{
        jj_consume_token(GE);
{if ("" != null) return SqlKind.GREATER_THAN_OR_EQUAL;}
        break;
        }
      case EQ:{
        jj_consume_token(EQ);
{if ("" != null) return SqlKind.EQUALS;}
        break;
        }
      case NE:{
        jj_consume_token(NE);
{if ("" != null) return SqlKind.NOT_EQUALS;}
        break;
        }
      case NE2:{
        jj_consume_token(NE2);
if (!this.conformance.isBangEqualAllowed()) {
            {if (true) throw new ParseException(RESOURCE.bangEqualNotAllowed().str());}
        }
        {if ("" != null) return SqlKind.NOT_EQUALS;}
        break;
        }
      default:
        jj_la1[150] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("comp");
    }
}

/**
 * Parses a unary row expression, or a parenthesized expression of any
 * kind.
 */
  final public SqlNode Expression3(ExprContext exprContext) throws ParseException {
    trace_call("Expression3");
    try {
final SqlNode e;
    final SqlNodeList list;
    final SqlNodeList list1;
    final SqlNodeList list2;
    final SqlOperator op;
    final Span s;
    Span rowSpan = null;
      if (jj_2_55(2)) {
        e = AtomicRowExpression();
checkNonQueryExpression(exprContext);
        {if ("" != null) return e;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CURSOR:{
          e = CursorExpression(exprContext);
{if ("" != null) return e;}
          break;
          }
        default:
          jj_la1[152] = jj_gen;
          if (jj_2_56(3)) {
            jj_consume_token(ROW);
s = span();
            list = ParenthesizedSimpleIdentifierList();
if (exprContext != ExprContext.ACCEPT_ALL
            && exprContext != ExprContext.ACCEPT_CURSOR
            && !this.conformance.allowExplicitRowValueConstructor())
        {
            {if (true) throw SqlUtil.newContextException(s.end(list),
                RESOURCE.illegalRowExpression());}
        }
        {if ("" != null) return SqlStdOperatorTable.ROW.createCall(list);}
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case ROW:
            case LPAREN:{
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case ROW:{
                jj_consume_token(ROW);
rowSpan = span();
                break;
                }
              default:
                jj_la1[151] = jj_gen;
                ;
              }
              list1 = ParenthesizedQueryOrCommaList(exprContext);
if (rowSpan != null) {
            // interpret as row constructor
            {if ("" != null) return SqlStdOperatorTable.ROW.createCall(rowSpan.end(list1),
                list1.toArray());}
        }
              if (jj_2_54(2)) {
                e = IntervalQualifier();
if ((list1.size() == 1)
                    && list1.get(0) instanceof SqlCall)
                {
                    final SqlCall call = (SqlCall) list1.get(0);
                    if (call.getKind() == SqlKind.MINUS
                            && call.operandCount() == 2) {
                        List<SqlNode> list3 = startList(call.operand(0));
                        list3.add(call.operand(1));
                        list3.add(e);
                        {if ("" != null) return SqlStdOperatorTable.MINUS_DATE.createCall(
                            Span.of(list1).end(this), list3);}
                     }
                }
                {if (true) throw SqlUtil.newContextException(span().end(list1),
                    RESOURCE.illegalMinusDate());}
              } else {
                ;
              }
if (list1.size() == 1) {
            // interpret as single value or query
            {if ("" != null) return list1.get(0);}
        } else {
            // interpret as row constructor
            {if ("" != null) return SqlStdOperatorTable.ROW.createCall(span().end(list1),
                list1.toArray());}
        }
              break;
              }
            default:
              jj_la1[153] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Expression3");
    }
}

  final public SqlOperator periodOperator() throws ParseException {
    trace_call("periodOperator");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OVERLAPS:{
        jj_consume_token(OVERLAPS);
{if ("" != null) return SqlStdOperatorTable.OVERLAPS;}
        break;
        }
      default:
        jj_la1[154] = jj_gen;
        if (jj_2_57(2)) {
          jj_consume_token(IMMEDIATELY);
          jj_consume_token(PRECEDES);
{if ("" != null) return SqlStdOperatorTable.IMMEDIATELY_PRECEDES;}
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case PRECEDES:{
            jj_consume_token(PRECEDES);
{if ("" != null) return SqlStdOperatorTable.PRECEDES;}
            break;
            }
          case IMMEDIATELY:{
            jj_consume_token(IMMEDIATELY);
            jj_consume_token(SUCCEEDS);
{if ("" != null) return SqlStdOperatorTable.IMMEDIATELY_SUCCEEDS;}
            break;
            }
          case SUCCEEDS:{
            jj_consume_token(SUCCEEDS);
{if ("" != null) return SqlStdOperatorTable.SUCCEEDS;}
            break;
            }
          case EQUALS:{
            jj_consume_token(EQUALS);
{if ("" != null) return SqlStdOperatorTable.PERIOD_EQUALS;}
            break;
            }
          default:
            jj_la1[155] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("periodOperator");
    }
}

/**
 * Parses a COLLATE clause
 */
  final public SqlCollation CollateClause() throws ParseException {
    trace_call("CollateClause");
    try {

      jj_consume_token(COLLATE);
      jj_consume_token(COLLATION_ID);
{if ("" != null) return new SqlCollation(
            getToken(0).image, SqlCollation.Coercibility.EXPLICIT);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CollateClause");
    }
}

/**
 * Numeric literal or parameter; used in LIMIT, OFFSET and FETCH clauses.
 */
  final public SqlNode UnsignedNumericLiteralOrParam() throws ParseException {
    trace_call("UnsignedNumericLiteralOrParam");
    try {
final SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNSIGNED_INTEGER_LITERAL:
      case APPROX_NUMERIC_LITERAL:
      case DECIMAL_NUMERIC_LITERAL:{
        e = UnsignedNumericLiteral();
        break;
        }
      case HOOK:{
        e = DynamicParam();
        break;
        }
      default:
        jj_la1[156] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnsignedNumericLiteralOrParam");
    }
}

/**
 * Parses an atomic row expression.
 */
  final public SqlNode AtomicRowExpression() throws ParseException {
    trace_call("AtomicRowExpression");
    try {
final SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DATE:
      case FALSE:
      case INTERVAL:
      case NULL:
      case TIME:
      case TIMESTAMP:
      case TRUE:
      case UNKNOWN:
      case UNSIGNED_INTEGER_LITERAL:
      case APPROX_NUMERIC_LITERAL:
      case DECIMAL_NUMERIC_LITERAL:
      case BINARY_STRING_LITERAL:
      case QUOTED_STRING:
      case PREFIXED_STRING_LITERAL:
      case UNICODE_STRING_LITERAL:
      case LBRACE_D:
      case LBRACE_T:
      case LBRACE_TS:
      case PLUS:
      case MINUS:{
        e = Literal();
        break;
        }
      case HOOK:{
        e = DynamicParam();
        break;
        }
      default:
        jj_la1[157] = jj_gen;
        if (jj_2_58(2)) {
          e = BuiltinFunctionCall();
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACE_FN:{
            e = JdbcFunctionCall();
            break;
            }
          case MULTISET:{
            e = MultisetConstructor();
            break;
            }
          case ARRAY:{
            e = ArrayConstructor();
            break;
            }
          default:
            jj_la1[158] = jj_gen;
            if (jj_2_59(3)) {
              e = MapConstructor();
            } else {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case PERIOD:{
                e = PeriodConstructor();
                break;
                }
              default:
                jj_la1[159] = jj_gen;
                if (jj_2_60(2147483647)) {
                  e = NamedFunctionCall();
                } else {
                  switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                  case CURRENT_CATALOG:
                  case CURRENT_DATE:
                  case CURRENT_DEFAULT_TRANSFORM_GROUP:
                  case CURRENT_PATH:
                  case CURRENT_ROLE:
                  case CURRENT_SCHEMA:
                  case CURRENT_TIME:
                  case CURRENT_TIMESTAMP:
                  case CURRENT_USER:
                  case LOCALTIME:
                  case LOCALTIMESTAMP:
                  case SESSION_USER:
                  case SYSTEM_USER:
                  case USER:{
                    e = ContextVariable();
                    break;
                    }
                  case A:
                  case ABSENT:
                  case ABSOLUTE:
                  case ACTION:
                  case ADA:
                  case ADD:
                  case ADMIN:
                  case AFTER:
                  case ALWAYS:
                  case APPLY:
                  case ASC:
                  case ASSERTION:
                  case ASSIGNMENT:
                  case ATTRIBUTE:
                  case ATTRIBUTES:
                  case BEFORE:
                  case BERNOULLI:
                  case BREADTH:
                  case C:
                  case CASCADE:
                  case CATALOG:
                  case CATALOG_NAME:
                  case CENTURY:
                  case CHAIN:
                  case CHARACTER_SET_CATALOG:
                  case CHARACTER_SET_NAME:
                  case CHARACTER_SET_SCHEMA:
                  case CHARACTERISTICS:
                  case CHARACTERS:
                  case CLASS_ORIGIN:
                  case COBOL:
                  case COLLATION:
                  case COLLATION_CATALOG:
                  case COLLATION_NAME:
                  case COLLATION_SCHEMA:
                  case COLUMN_NAME:
                  case COMMAND_FUNCTION:
                  case COMMAND_FUNCTION_CODE:
                  case COMMITTED:
                  case CONDITIONAL:
                  case CONDITION_NUMBER:
                  case CONNECTION:
                  case CONNECTION_NAME:
                  case CONSTRAINT_CATALOG:
                  case CONSTRAINT_NAME:
                  case CONSTRAINT_SCHEMA:
                  case CONSTRAINTS:
                  case CONSTRUCTOR:
                  case CONTINUE:
                  case CURSOR_NAME:
                  case DATA:
                  case DATABASE:
                  case DATETIME_INTERVAL_CODE:
                  case DATETIME_INTERVAL_PRECISION:
                  case DECADE:
                  case DEFAULTS:
                  case DEFERRABLE:
                  case DEFERRED:
                  case DEFINED:
                  case DEFINER:
                  case DEGREE:
                  case DEPTH:
                  case DERIVED:
                  case DESC:
                  case DESCRIPTION:
                  case DESCRIPTOR:
                  case DIAGNOSTICS:
                  case DISPATCH:
                  case DOMAIN:
                  case DOW:
                  case DOY:
                  case DYNAMIC_FUNCTION:
                  case DYNAMIC_FUNCTION_CODE:
                  case ENCODING:
                  case EPOCH:
                  case ERROR:
                  case EXCEPTION:
                  case EXCLUDE:
                  case EXCLUDING:
                  case FINAL:
                  case FIRST:
                  case FOLLOWING:
                  case FORMAT:
                  case FORTRAN:
                  case FOUND:
                  case FRAC_SECOND:
                  case G:
                  case GENERAL:
                  case GENERATED:
                  case GEOMETRY:
                  case GO:
                  case GOTO:
                  case GRANTED:
                  case HIERARCHY:
                  case IMMEDIATE:
                  case IMMEDIATELY:
                  case IMPLEMENTATION:
                  case INCLUDING:
                  case INCREMENT:
                  case INITIALLY:
                  case INPUT:
                  case INSTANCE:
                  case INSTANTIABLE:
                  case INVOKER:
                  case ISODOW:
                  case ISOYEAR:
                  case ISOLATION:
                  case JAVA:
                  case JSON:
                  case JSON_PRETTY:
                  case JSON_TYPE:
                  case JSON_DEPTH:
                  case K:
                  case KEY:
                  case KEY_MEMBER:
                  case KEY_TYPE:
                  case LABEL:
                  case LAST:
                  case LENGTH:
                  case LEVEL:
                  case LIBRARY:
                  case LOCATOR:
                  case M:
                  case MAP:
                  case MATCHED:
                  case MAXVALUE:
                  case MESSAGE_LENGTH:
                  case MESSAGE_OCTET_LENGTH:
                  case MESSAGE_TEXT:
                  case MICROSECOND:
                  case MILLISECOND:
                  case MILLENNIUM:
                  case MINVALUE:
                  case MORE_:
                  case MUMPS:
                  case NAME:
                  case NAMES:
                  case NANOSECOND:
                  case NESTING:
                  case NORMALIZED:
                  case NULLABLE:
                  case NULLS:
                  case NUMBER:
                  case OBJECT:
                  case OCTETS:
                  case OPTION:
                  case OPTIONS:
                  case ORDERING:
                  case ORDINALITY:
                  case OTHERS:
                  case OUTPUT:
                  case OVERRIDING:
                  case PAD:
                  case PARAMETER_MODE:
                  case PARAMETER_NAME:
                  case PARAMETER_ORDINAL_POSITION:
                  case PARAMETER_SPECIFIC_CATALOG:
                  case PARAMETER_SPECIFIC_NAME:
                  case PARAMETER_SPECIFIC_SCHEMA:
                  case PARTIAL:
                  case PASCAL:
                  case PASSING:
                  case PASSTHROUGH:
                  case PAST:
                  case PATH:
                  case PLACING:
                  case PLAN:
                  case PLI:
                  case PRECEDING:
                  case PRESERVE:
                  case PRIOR:
                  case PRIVILEGES:
                  case PUBLIC:
                  case QUARTER:
                  case READ:
                  case RELATIVE:
                  case REPEATABLE:
                  case REPLACE:
                  case RESTART:
                  case RESTRICT:
                  case RETURNED_CARDINALITY:
                  case RETURNED_LENGTH:
                  case RETURNED_OCTET_LENGTH:
                  case RETURNED_SQLSTATE:
                  case RETURNING:
                  case ROLE:
                  case ROUTINE:
                  case ROUTINE_CATALOG:
                  case ROUTINE_NAME:
                  case ROUTINE_SCHEMA:
                  case ROW_COUNT:
                  case SCALAR:
                  case SCALE:
                  case SCHEMA:
                  case SCHEMA_NAME:
                  case SCOPE_CATALOGS:
                  case SCOPE_NAME:
                  case SCOPE_SCHEMA:
                  case SECTION:
                  case SECURITY:
                  case SELF:
                  case SEQUENCE:
                  case SERIALIZABLE:
                  case SERVER:
                  case SERVER_NAME:
                  case SESSION:
                  case SETS:
                  case SIMPLE:
                  case SIZE:
                  case SOURCE:
                  case SPACE:
                  case SPECIFIC_NAME:
                  case SQL_BIGINT:
                  case SQL_BINARY:
                  case SQL_BIT:
                  case SQL_BLOB:
                  case SQL_BOOLEAN:
                  case SQL_CHAR:
                  case SQL_CLOB:
                  case SQL_DATE:
                  case SQL_DECIMAL:
                  case SQL_DOUBLE:
                  case SQL_FLOAT:
                  case SQL_INTEGER:
                  case SQL_INTERVAL_DAY:
                  case SQL_INTERVAL_DAY_TO_HOUR:
                  case SQL_INTERVAL_DAY_TO_MINUTE:
                  case SQL_INTERVAL_DAY_TO_SECOND:
                  case SQL_INTERVAL_HOUR:
                  case SQL_INTERVAL_HOUR_TO_MINUTE:
                  case SQL_INTERVAL_HOUR_TO_SECOND:
                  case SQL_INTERVAL_MINUTE:
                  case SQL_INTERVAL_MINUTE_TO_SECOND:
                  case SQL_INTERVAL_MONTH:
                  case SQL_INTERVAL_SECOND:
                  case SQL_INTERVAL_YEAR:
                  case SQL_INTERVAL_YEAR_TO_MONTH:
                  case SQL_LONGVARBINARY:
                  case SQL_LONGVARCHAR:
                  case SQL_LONGVARNCHAR:
                  case SQL_NCHAR:
                  case SQL_NCLOB:
                  case SQL_NUMERIC:
                  case SQL_NVARCHAR:
                  case SQL_REAL:
                  case SQL_SMALLINT:
                  case SQL_TIME:
                  case SQL_TIMESTAMP:
                  case SQL_TINYINT:
                  case SQL_TSI_DAY:
                  case SQL_TSI_FRAC_SECOND:
                  case SQL_TSI_HOUR:
                  case SQL_TSI_MICROSECOND:
                  case SQL_TSI_MINUTE:
                  case SQL_TSI_MONTH:
                  case SQL_TSI_QUARTER:
                  case SQL_TSI_SECOND:
                  case SQL_TSI_WEEK:
                  case SQL_TSI_YEAR:
                  case SQL_VARBINARY:
                  case SQL_VARCHAR:
                  case STATE:
                  case STATEMENT:
                  case STRUCTURE:
                  case STYLE:
                  case SUBCLASS_ORIGIN:
                  case SUBSTITUTE:
                  case TABLE_NAME:
                  case TEMPORARY:
                  case TIES:
                  case TIMESTAMPADD:
                  case TIMESTAMPDIFF:
                  case TOP_LEVEL_COUNT:
                  case TRANSACTION:
                  case TRANSACTIONS_ACTIVE:
                  case TRANSACTIONS_COMMITTED:
                  case TRANSACTIONS_ROLLED_BACK:
                  case TRANSFORM:
                  case TRANSFORMS:
                  case TRIGGER_CATALOG:
                  case TRIGGER_NAME:
                  case TRIGGER_SCHEMA:
                  case TYPE:
                  case UNBOUNDED:
                  case UNCOMMITTED:
                  case UNCONDITIONAL:
                  case UNDER:
                  case UNNAMED:
                  case USAGE:
                  case USER_DEFINED_TYPE_CATALOG:
                  case USER_DEFINED_TYPE_CODE:
                  case USER_DEFINED_TYPE_NAME:
                  case USER_DEFINED_TYPE_SCHEMA:
                  case UTF8:
                  case UTF16:
                  case UTF32:
                  case VERSION:
                  case VIEW:
                  case WEEK:
                  case WORK:
                  case WRAPPER:
                  case WRITE:
                  case XML:
                  case ZONE:
                  case BRACKET_QUOTED_IDENTIFIER:
                  case QUOTED_IDENTIFIER:
                  case BACK_QUOTED_IDENTIFIER:
                  case IDENTIFIER:
                  case UNICODE_QUOTED_IDENTIFIER:{
                    e = CompoundIdentifier();
                    break;
                    }
                  case NEW:{
                    e = NewSpecification();
                    break;
                    }
                  case CASE:{
                    e = CaseExpression();
                    break;
                    }
                  case CURRENT:
                  case NEXT:{
                    e = SequenceExpression();
                    break;
                    }
                  default:
                    jj_la1[160] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                  }
                }
              }
            }
          }
        }
      }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("AtomicRowExpression");
    }
}

  final public SqlNode CaseExpression() throws ParseException {
    trace_call("CaseExpression");
    try {
final Span whenSpan = Span.of();
    final Span thenSpan = Span.of();
    final Span s;
    SqlNode e;
    SqlNode caseIdentifier = null;
    SqlNode elseClause = null;
    List<SqlNode> whenList = new ArrayList<SqlNode>();
    List<SqlNode> thenList = new ArrayList<SqlNode>();
      jj_consume_token(CASE);
s = span();
      if (jj_2_61(1)) {
        caseIdentifier = Expression(ExprContext.ACCEPT_SUB_QUERY);
      } else {
        ;
      }
      label_27:
      while (true) {
        jj_consume_token(WHEN);
whenSpan.add(this);
        e = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY);
if (((SqlNodeList) e).size() == 1) {
                e = ((SqlNodeList) e).get(0);
            }
            whenList.add(e);
        jj_consume_token(THEN);
thenSpan.add(this);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
thenList.add(e);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case WHEN:{
          ;
          break;
          }
        default:
          jj_la1[161] = jj_gen;
          break label_27;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSE:{
        jj_consume_token(ELSE);
        elseClause = Expression(ExprContext.ACCEPT_SUB_QUERY);
        break;
        }
      default:
        jj_la1[162] = jj_gen;
        ;
      }
      jj_consume_token(END);
{if ("" != null) return SqlCase.createSwitched(s.end(this), caseIdentifier,
            new SqlNodeList(whenList, whenSpan.addAll(whenList).pos()),
            new SqlNodeList(thenList, thenSpan.addAll(thenList).pos()),
            elseClause);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CaseExpression");
    }
}

  final public SqlCall SequenceExpression() throws ParseException {
    trace_call("SequenceExpression");
    try {
final Span s;
    final SqlOperator f;
    final SqlNode sequenceRef;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NEXT:{
        jj_consume_token(NEXT);
f = SqlStdOperatorTable.NEXT_VALUE; s = span();
        break;
        }
      case CURRENT:{
        jj_consume_token(CURRENT);
f = SqlStdOperatorTable.CURRENT_VALUE; s = span();
        break;
        }
      default:
        jj_la1[163] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(VALUE);
      jj_consume_token(FOR);
      sequenceRef = CompoundIdentifier();
{if ("" != null) return f.createCall(s.end(sequenceRef), sequenceRef);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SequenceExpression");
    }
}

/**
 * Parses "SET &lt;NAME&gt; = VALUE" or "RESET &lt;NAME&gt;", without a leading
 * "ALTER &lt;SCOPE&gt;".
 */
  final public SqlSetOption SqlSetOption(Span s, String scope) throws ParseException {
    trace_call("SqlSetOption");
    try {
SqlIdentifier name;
    final SqlNode val;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SET:{
        jj_consume_token(SET);
s.add(this);
        name = CompoundIdentifier();
        jj_consume_token(EQ);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DATE:
        case FALSE:
        case INTERVAL:
        case NULL:
        case TIME:
        case TIMESTAMP:
        case TRUE:
        case UNKNOWN:
        case UNSIGNED_INTEGER_LITERAL:
        case APPROX_NUMERIC_LITERAL:
        case DECIMAL_NUMERIC_LITERAL:
        case BINARY_STRING_LITERAL:
        case QUOTED_STRING:
        case PREFIXED_STRING_LITERAL:
        case UNICODE_STRING_LITERAL:
        case LBRACE_D:
        case LBRACE_T:
        case LBRACE_TS:
        case PLUS:
        case MINUS:{
          val = Literal();
          break;
          }
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          val = SimpleIdentifier();
          break;
          }
        case ON:{
          jj_consume_token(ON);
// OFF is handled by SimpleIdentifier, ON handled here.
                val = new SqlIdentifier(token.image.toUpperCase(Locale.ROOT),
                    getPos());
          break;
          }
        default:
          jj_la1[164] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return new SqlSetOption(s.end(val), scope, name, val);}
        break;
        }
      case RESET:{
        jj_consume_token(RESET);
s.add(this);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          name = CompoundIdentifier();
          break;
          }
        case ALL:{
          jj_consume_token(ALL);
name = new SqlIdentifier(token.image.toUpperCase(Locale.ROOT),
                    getPos());
          break;
          }
        default:
          jj_la1[165] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return new SqlSetOption(s.end(name), scope, name, null);}
        break;
        }
      default:
        jj_la1[166] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlSetOption");
    }
}

/**
 * Parses an expression for setting or resetting an option in SQL, such as QUOTED_IDENTIFIERS,
 * or explain plan level (physical/logical).
 */
  final public SqlAlter SqlAlter() throws ParseException {
    trace_call("SqlAlter");
    try {
final Span s;
    final String scope;
    final SqlAlter alterNode;
      jj_consume_token(ALTER);
s = span();
      scope = Scope();
      alterNode = SqlSetOption(s, scope);
{if ("" != null) return alterNode;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlAlter");
    }
}

  final public String Scope() throws ParseException {
    trace_call("Scope");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SYSTEM:{
        jj_consume_token(SYSTEM);
        break;
        }
      case SESSION:{
        jj_consume_token(SESSION);
        break;
        }
      default:
        jj_la1[167] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return token.image.toUpperCase(Locale.ROOT);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Scope");
    }
}

/**
 * Parses a literal expression, allowing continued string literals.
 * Usually returns an SqlLiteral, but a continued string literal
 * is an SqlCall expression, which concatenates 2 or more string
 * literals; the validator reduces this.
 */
  final public SqlNode Literal() throws ParseException {
    trace_call("Literal");
    try {
SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNSIGNED_INTEGER_LITERAL:
      case APPROX_NUMERIC_LITERAL:
      case DECIMAL_NUMERIC_LITERAL:
      case PLUS:
      case MINUS:{
        e = NumericLiteral();
        break;
        }
      case BINARY_STRING_LITERAL:
      case QUOTED_STRING:
      case PREFIXED_STRING_LITERAL:
      case UNICODE_STRING_LITERAL:{
        e = StringLiteral();
        break;
        }
      case FALSE:
      case NULL:
      case TRUE:
      case UNKNOWN:{
        e = SpecialLiteral();
        break;
        }
      case DATE:
      case TIME:
      case TIMESTAMP:
      case LBRACE_D:
      case LBRACE_T:
      case LBRACE_TS:{
        e = DateTimeLiteral();
        break;
        }
      case INTERVAL:{
        e = IntervalLiteral();
        break;
        }
      default:
        jj_la1[168] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Literal");
    }
}

/** Parses a unsigned numeric literal */
  final public SqlNumericLiteral UnsignedNumericLiteral() throws ParseException {
    trace_call("UnsignedNumericLiteral");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNSIGNED_INTEGER_LITERAL:{
        jj_consume_token(UNSIGNED_INTEGER_LITERAL);
{if ("" != null) return SqlLiteral.createExactNumeric(token.image, getPos());}
        break;
        }
      case DECIMAL_NUMERIC_LITERAL:{
        jj_consume_token(DECIMAL_NUMERIC_LITERAL);
{if ("" != null) return SqlLiteral.createExactNumeric(token.image, getPos());}
        break;
        }
      case APPROX_NUMERIC_LITERAL:{
        jj_consume_token(APPROX_NUMERIC_LITERAL);
{if ("" != null) return SqlLiteral.createApproxNumeric(token.image, getPos());}
        break;
        }
      default:
        jj_la1[169] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnsignedNumericLiteral");
    }
}

/** Parses a numeric literal (can be signed) */
  final public SqlLiteral NumericLiteral() throws ParseException {
    trace_call("NumericLiteral");
    try {
final SqlNumericLiteral num;
    final Span s;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        jj_consume_token(PLUS);
        num = UnsignedNumericLiteral();
{if ("" != null) return num;}
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
s = span();
        num = UnsignedNumericLiteral();
{if ("" != null) return SqlLiteral.createNegative(num, s.end(this));}
        break;
        }
      case UNSIGNED_INTEGER_LITERAL:
      case APPROX_NUMERIC_LITERAL:
      case DECIMAL_NUMERIC_LITERAL:{
        num = UnsignedNumericLiteral();
{if ("" != null) return num;}
        break;
        }
      default:
        jj_la1[170] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NumericLiteral");
    }
}

/** Parse a special literal keyword */
  final public SqlLiteral SpecialLiteral() throws ParseException {
    trace_call("SpecialLiteral");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TRUE:{
        jj_consume_token(TRUE);
{if ("" != null) return SqlLiteral.createBoolean(true, getPos());}
        break;
        }
      case FALSE:{
        jj_consume_token(FALSE);
{if ("" != null) return SqlLiteral.createBoolean(false, getPos());}
        break;
        }
      case UNKNOWN:{
        jj_consume_token(UNKNOWN);
{if ("" != null) return SqlLiteral.createUnknown(getPos());}
        break;
        }
      case NULL:{
        jj_consume_token(NULL);
{if ("" != null) return SqlLiteral.createNull(getPos());}
        break;
        }
      default:
        jj_la1[171] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SpecialLiteral");
    }
}

/**
 * Parses a string literal. The literal may be continued onto several
 * lines.  For a simple literal, the result is an SqlLiteral.  For a continued
 * literal, the result is an SqlCall expression, which concatenates 2 or more
 * string literals; the validator reduces this.
 *
 * @see SqlLiteral#unchain(SqlNode)
 * @see SqlLiteral#stringValue(SqlNode)
 *
 * @return a literal expression
 */
  final public SqlNode StringLiteral() throws ParseException {
    trace_call("StringLiteral");
    try {
String p;
    int nfrags = 0;
    List<SqlLiteral> frags = null;
    char unicodeEscapeChar = 0;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BINARY_STRING_LITERAL:{
        jj_consume_token(BINARY_STRING_LITERAL);
try {
            p = SqlParserUtil.trim(token.image, "xX'");
            frags = startList(SqlLiteral.createBinaryString(p, getPos()));
            nfrags++;
        } catch (NumberFormatException ex) {
            {if (true) throw SqlUtil.newContextException(getPos(),
                RESOURCE.illegalBinaryString(token.image));}
        }
        label_28:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case QUOTED_STRING:{
            ;
            break;
            }
          default:
            jj_la1[172] = jj_gen;
            break label_28;
          }
          jj_consume_token(QUOTED_STRING);
try {
                p = SqlParserUtil.trim(token.image, "'"); // no embedded quotes
                frags.add(SqlLiteral.createBinaryString(p, getPos()));
                nfrags++;
            } catch (NumberFormatException ex) {
                {if (true) throw SqlUtil.newContextException(getPos(),
                    RESOURCE.illegalBinaryString(token.image));}
            }
        }
assert (nfrags > 0);
        if (nfrags == 1) {
            {if ("" != null) return frags.get(0);} // just the head fragment
        } else {
            SqlParserPos pos2 = SqlParserPos.sum(frags);
            {if ("" != null) return SqlStdOperatorTable.LITERAL_CHAIN.createCall(pos2, frags);}
        }
        break;
        }
      case QUOTED_STRING:
      case PREFIXED_STRING_LITERAL:
      case UNICODE_STRING_LITERAL:{
String charSet = null;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PREFIXED_STRING_LITERAL:{
          jj_consume_token(PREFIXED_STRING_LITERAL);
charSet = SqlParserUtil.getCharacterSet(token.image);
          break;
          }
        case QUOTED_STRING:{
          jj_consume_token(QUOTED_STRING);
          break;
          }
        case UNICODE_STRING_LITERAL:{
          jj_consume_token(UNICODE_STRING_LITERAL);
// TODO jvs 2-Feb-2009:  support the explicit specification of
            // a character set for Unicode string literals, per SQL:2003
            unicodeEscapeChar = BACKSLASH;
            charSet = "UTF16";
          break;
          }
        default:
          jj_la1[173] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
p = SqlParserUtil.parseString(token.image);
        SqlCharStringLiteral literal;
        try {
            literal = SqlLiteral.createCharString(p, charSet, getPos());
        } catch (java.nio.charset.UnsupportedCharsetException e) {
            {if (true) throw SqlUtil.newContextException(getPos(),
                RESOURCE.unknownCharacterSet(charSet));}
        }
        frags = startList(literal);
        nfrags++;
        label_29:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case QUOTED_STRING:{
            ;
            break;
            }
          default:
            jj_la1[174] = jj_gen;
            break label_29;
          }
          jj_consume_token(QUOTED_STRING);
p = SqlParserUtil.parseString(token.image);
            try {
                literal = SqlLiteral.createCharString(p, charSet, getPos());
            } catch (java.nio.charset.UnsupportedCharsetException e) {
                {if (true) throw SqlUtil.newContextException(getPos(),
                    RESOURCE.unknownCharacterSet(charSet));}
            }
            frags.add(literal);
            nfrags++;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UESCAPE:{
          jj_consume_token(UESCAPE);
          jj_consume_token(QUOTED_STRING);
if (unicodeEscapeChar == 0) {
                {if (true) throw SqlUtil.newContextException(getPos(),
                    RESOURCE.unicodeEscapeUnexpected());}
            }
            String s = SqlParserUtil.parseString(token.image);
            unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s);
          break;
          }
        default:
          jj_la1[175] = jj_gen;
          ;
        }
assert nfrags > 0;
        if (nfrags == 1) {
            // just the head fragment
            SqlLiteral lit = (SqlLiteral) frags.get(0);
            {if ("" != null) return lit.unescapeUnicode(unicodeEscapeChar);}
        } else {
            SqlNode[] rands = (SqlNode[]) frags.toArray(new SqlNode[nfrags]);
            for (int i = 0; i < rands.length; ++i) {
                rands[i] = ((SqlLiteral) rands[i]).unescapeUnicode(
                    unicodeEscapeChar);
            }
            SqlParserPos pos2 = SqlParserPos.sum(rands);
            {if ("" != null) return SqlStdOperatorTable.LITERAL_CHAIN.createCall(pos2, rands);}
        }
        break;
        }
      default:
        jj_la1[176] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StringLiteral");
    }
}

/**
 * Parses a date/time literal.
 */
  final public SqlLiteral DateTimeLiteral() throws ParseException {
    trace_call("DateTimeLiteral");
    try {
final String  p;
    final Span s;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE_D:{
        jj_consume_token(LBRACE_D);
        jj_consume_token(QUOTED_STRING);
p = token.image;
        jj_consume_token(RBRACE);
{if ("" != null) return SqlParserUtil.parseDateLiteral(p, getPos());}
        break;
        }
      case LBRACE_T:{
        jj_consume_token(LBRACE_T);
        jj_consume_token(QUOTED_STRING);
p = token.image;
        jj_consume_token(RBRACE);
{if ("" != null) return SqlParserUtil.parseTimeLiteral(p, getPos());}
        break;
        }
      case LBRACE_TS:{
        jj_consume_token(LBRACE_TS);
s = span();
        jj_consume_token(QUOTED_STRING);
p = token.image;
        jj_consume_token(RBRACE);
{if ("" != null) return SqlParserUtil.parseTimestampLiteral(p, s.end(this));}
        break;
        }
      case DATE:{
        jj_consume_token(DATE);
s = span();
        jj_consume_token(QUOTED_STRING);
{if ("" != null) return SqlParserUtil.parseDateLiteral(token.image, s.end(this));}
        break;
        }
      case TIME:{
        jj_consume_token(TIME);
s = span();
        jj_consume_token(QUOTED_STRING);
{if ("" != null) return SqlParserUtil.parseTimeLiteral(token.image, s.end(this));}
        break;
        }
      case TIMESTAMP:{
        jj_consume_token(TIMESTAMP);
s = span();
        jj_consume_token(QUOTED_STRING);
{if ("" != null) return SqlParserUtil.parseTimestampLiteral(token.image, s.end(this));}
        break;
        }
      default:
        jj_la1[177] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DateTimeLiteral");
    }
}

/** Parses a MULTISET constructor */
  final public SqlNode MultisetConstructor() throws ParseException {
    trace_call("MultisetConstructor");
    try {
List<SqlNode> args;
    SqlNode e;
    final Span s;
      jj_consume_token(MULTISET);
s = span();
      if (jj_2_62(2)) {
        jj_consume_token(LPAREN);
        // by sub query "MULTISET(SELECT * FROM T)"
                e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY);
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.MULTISET_QUERY.createCall(
                s.end(this), e);}
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LBRACKET:{
          jj_consume_token(LBRACKET);
          // TODO: do trigraph as well ??( ??)
                  e = Expression(ExprContext.ACCEPT_NON_QUERY);
args = startList(e);
          label_30:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case COMMA:{
              ;
              break;
              }
            default:
              jj_la1[178] = jj_gen;
              break label_30;
            }
            jj_consume_token(COMMA);
            e = Expression(ExprContext.ACCEPT_NON_QUERY);
args.add(e);
          }
          jj_consume_token(RBRACKET);
{if ("" != null) return SqlStdOperatorTable.MULTISET_VALUE.createCall(
                s.end(this), args);}
          break;
          }
        default:
          jj_la1[179] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MultisetConstructor");
    }
}

/** Parses an ARRAY constructor */
  final public SqlNode ArrayConstructor() throws ParseException {
    trace_call("ArrayConstructor");
    try {
SqlNodeList args;
    SqlNode e;
    final Span s;
      jj_consume_token(ARRAY);
s = span();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        jj_consume_token(LPAREN);
        // by sub query "MULTISET(SELECT * FROM T)"
                e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY);
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.ARRAY_QUERY.createCall(
                s.end(this), e);}
        break;
        }
      case LBRACKET:{
        jj_consume_token(LBRACKET);
        if (jj_2_63(1)) {
          args = ExpressionCommaList(s, ExprContext.ACCEPT_NON_QUERY);
        } else {
args = SqlNodeList.EMPTY;
        }
        jj_consume_token(RBRACKET);
{if ("" != null) return SqlStdOperatorTable.ARRAY_VALUE_CONSTRUCTOR.createCall(
                s.end(this), args.getList());}
        break;
        }
      default:
        jj_la1[180] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ArrayConstructor");
    }
}

/** Parses a MAP constructor */
  final public SqlNode MapConstructor() throws ParseException {
    trace_call("MapConstructor");
    try {
SqlNodeList args;
    SqlNode e;
    final Span s;
      jj_consume_token(MAP);
s = span();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        jj_consume_token(LPAREN);
        // by sub query "MAP (SELECT empno, deptno FROM emp)"
                e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY);
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.MAP_QUERY.createCall(
                s.end(this), e);}
        break;
        }
      case LBRACKET:{
        jj_consume_token(LBRACKET);
        if (jj_2_64(1)) {
          args = ExpressionCommaList(s, ExprContext.ACCEPT_NON_QUERY);
        } else {
args = SqlNodeList.EMPTY;
        }
        jj_consume_token(RBRACKET);
{if ("" != null) return SqlStdOperatorTable.MAP_VALUE_CONSTRUCTOR.createCall(
                s.end(this), args.getList());}
        break;
        }
      default:
        jj_la1[181] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MapConstructor");
    }
}

/** Parses a PERIOD constructor */
  final public SqlNode PeriodConstructor() throws ParseException {
    trace_call("PeriodConstructor");
    try {
final SqlNode e0, e1;
    final Span s;
      jj_consume_token(PERIOD);
s = span();
      jj_consume_token(LPAREN);
      e0 = Expression(ExprContext.ACCEPT_SUB_QUERY);
      jj_consume_token(COMMA);
      e1 = Expression(ExprContext.ACCEPT_SUB_QUERY);
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.ROW.createCall(s.end(this), e0, e1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PeriodConstructor");
    }
}

/**
 * Parses an interval literal.
 */
  final public SqlLiteral IntervalLiteral() throws ParseException {
    trace_call("IntervalLiteral");
    try {
final String p;
    final SqlIntervalQualifier intervalQualifier;
    int sign = 1;
    final Span s;
      jj_consume_token(INTERVAL);
s = span();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MINUS:{
          jj_consume_token(MINUS);
sign = -1;
          break;
          }
        case PLUS:{
          jj_consume_token(PLUS);
sign = 1;
          break;
          }
        default:
          jj_la1[182] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[183] = jj_gen;
        ;
      }
      jj_consume_token(QUOTED_STRING);
p = token.image;
      intervalQualifier = IntervalQualifier();
{if ("" != null) return SqlParserUtil.parseIntervalLiteral(s.end(intervalQualifier),
            sign, p, intervalQualifier);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IntervalLiteral");
    }
}

  final public SqlIntervalQualifier IntervalQualifier() throws ParseException {
    trace_call("IntervalQualifier");
    try {
TimeUnit start;
    TimeUnit end = null;
    int startPrec = RelDataType.PRECISION_NOT_SPECIFIED;
    int secondFracPrec = RelDataType.PRECISION_NOT_SPECIFIED;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case YEAR:{
        jj_consume_token(YEAR);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          jj_consume_token(LPAREN);
          startPrec = UnsignedIntLiteral();
          jj_consume_token(RPAREN);
          break;
          }
        default:
          jj_la1[184] = jj_gen;
          ;
        }
        if (jj_2_65(2)) {
          jj_consume_token(TO);
          jj_consume_token(MONTH);
end = TimeUnit.MONTH;
        } else {
          ;
        }
start = TimeUnit.YEAR;
        break;
        }
      case MONTH:{
        jj_consume_token(MONTH);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          jj_consume_token(LPAREN);
          startPrec = UnsignedIntLiteral();
          jj_consume_token(RPAREN);
          break;
          }
        default:
          jj_la1[185] = jj_gen;
          ;
        }
start = TimeUnit.MONTH;
        break;
        }
      case DAY:{
        jj_consume_token(DAY);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          jj_consume_token(LPAREN);
          startPrec = UnsignedIntLiteral();
          jj_consume_token(RPAREN);
          break;
          }
        default:
          jj_la1[186] = jj_gen;
          ;
        }
        if (jj_2_66(2)) {
          jj_consume_token(TO);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case HOUR:{
            jj_consume_token(HOUR);
end = TimeUnit.HOUR;
            break;
            }
          case MINUTE:{
            jj_consume_token(MINUTE);
end = TimeUnit.MINUTE;
            break;
            }
          case SECOND:{
            jj_consume_token(SECOND);
end = TimeUnit.SECOND;
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case LPAREN:{
              jj_consume_token(LPAREN);
              secondFracPrec = UnsignedIntLiteral();
              jj_consume_token(RPAREN);
              break;
              }
            default:
              jj_la1[187] = jj_gen;
              ;
            }
            break;
            }
          default:
            jj_la1[188] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          ;
        }
start = TimeUnit.DAY;
        break;
        }
      case HOUR:{
        jj_consume_token(HOUR);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          jj_consume_token(LPAREN);
          startPrec = UnsignedIntLiteral();
          jj_consume_token(RPAREN);
          break;
          }
        default:
          jj_la1[189] = jj_gen;
          ;
        }
        if (jj_2_67(2)) {
          jj_consume_token(TO);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case MINUTE:{
            jj_consume_token(MINUTE);
end = TimeUnit.MINUTE;
            break;
            }
          case SECOND:{
            jj_consume_token(SECOND);
end = TimeUnit.SECOND;
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case LPAREN:{
              jj_consume_token(LPAREN);
              secondFracPrec = UnsignedIntLiteral();
              jj_consume_token(RPAREN);
              break;
              }
            default:
              jj_la1[190] = jj_gen;
              ;
            }
            break;
            }
          default:
            jj_la1[191] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          ;
        }
start = TimeUnit.HOUR;
        break;
        }
      case MINUTE:{
        jj_consume_token(MINUTE);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          jj_consume_token(LPAREN);
          startPrec = UnsignedIntLiteral();
          jj_consume_token(RPAREN);
          break;
          }
        default:
          jj_la1[192] = jj_gen;
          ;
        }
        if (jj_2_68(2)) {
          jj_consume_token(TO);
          jj_consume_token(SECOND);
end = TimeUnit.SECOND;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LPAREN:{
            jj_consume_token(LPAREN);
            secondFracPrec = UnsignedIntLiteral();
            jj_consume_token(RPAREN);
            break;
            }
          default:
            jj_la1[193] = jj_gen;
            ;
          }
        } else {
          ;
        }
start = TimeUnit.MINUTE;
        break;
        }
      case SECOND:{
        jj_consume_token(SECOND);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          jj_consume_token(LPAREN);
          startPrec = UnsignedIntLiteral();
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            jj_consume_token(COMMA);
            secondFracPrec = UnsignedIntLiteral();
            break;
            }
          default:
            jj_la1[194] = jj_gen;
            ;
          }
          jj_consume_token(RPAREN);
          break;
          }
        default:
          jj_la1[195] = jj_gen;
          ;
        }
start = TimeUnit.SECOND;
        break;
        }
      default:
        jj_la1[196] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return new SqlIntervalQualifier(start,
            startPrec,
            end,
            secondFracPrec,
            getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IntervalQualifier");
    }
}

/**
 * Parses time unit for EXTRACT, CEIL and FLOOR functions.
 */
  final public TimeUnit TimeUnit() throws ParseException {
    trace_call("TimeUnit");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MICROSECOND:{
        jj_consume_token(MICROSECOND);
{if ("" != null) return TimeUnit.MICROSECOND;}
        break;
        }
      case MILLISECOND:{
        jj_consume_token(MILLISECOND);
{if ("" != null) return TimeUnit.MILLISECOND;}
        break;
        }
      case SECOND:{
        jj_consume_token(SECOND);
{if ("" != null) return TimeUnit.SECOND;}
        break;
        }
      case MINUTE:{
        jj_consume_token(MINUTE);
{if ("" != null) return TimeUnit.MINUTE;}
        break;
        }
      case HOUR:{
        jj_consume_token(HOUR);
{if ("" != null) return TimeUnit.HOUR;}
        break;
        }
      case DAY:{
        jj_consume_token(DAY);
{if ("" != null) return TimeUnit.DAY;}
        break;
        }
      case DOW:{
        jj_consume_token(DOW);
{if ("" != null) return TimeUnit.DOW;}
        break;
        }
      case DOY:{
        jj_consume_token(DOY);
{if ("" != null) return TimeUnit.DOY;}
        break;
        }
      case ISODOW:{
        jj_consume_token(ISODOW);
{if ("" != null) return TimeUnit.ISODOW;}
        break;
        }
      case ISOYEAR:{
        jj_consume_token(ISOYEAR);
{if ("" != null) return TimeUnit.ISOYEAR;}
        break;
        }
      case WEEK:{
        jj_consume_token(WEEK);
{if ("" != null) return TimeUnit.WEEK;}
        break;
        }
      case MONTH:{
        jj_consume_token(MONTH);
{if ("" != null) return TimeUnit.MONTH;}
        break;
        }
      case QUARTER:{
        jj_consume_token(QUARTER);
{if ("" != null) return TimeUnit.QUARTER;}
        break;
        }
      case YEAR:{
        jj_consume_token(YEAR);
{if ("" != null) return TimeUnit.YEAR;}
        break;
        }
      case EPOCH:{
        jj_consume_token(EPOCH);
{if ("" != null) return TimeUnit.EPOCH;}
        break;
        }
      case DECADE:{
        jj_consume_token(DECADE);
{if ("" != null) return TimeUnit.DECADE;}
        break;
        }
      case CENTURY:{
        jj_consume_token(CENTURY);
{if ("" != null) return TimeUnit.CENTURY;}
        break;
        }
      case MILLENNIUM:{
        jj_consume_token(MILLENNIUM);
{if ("" != null) return TimeUnit.MILLENNIUM;}
        break;
        }
      default:
        jj_la1[197] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TimeUnit");
    }
}

  final public TimeUnit TimestampInterval() throws ParseException {
    trace_call("TimestampInterval");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FRAC_SECOND:{
        jj_consume_token(FRAC_SECOND);
{if ("" != null) return TimeUnit.MICROSECOND;}
        break;
        }
      case MICROSECOND:{
        jj_consume_token(MICROSECOND);
{if ("" != null) return TimeUnit.MICROSECOND;}
        break;
        }
      case NANOSECOND:{
        jj_consume_token(NANOSECOND);
{if ("" != null) return TimeUnit.NANOSECOND;}
        break;
        }
      case SQL_TSI_FRAC_SECOND:{
        jj_consume_token(SQL_TSI_FRAC_SECOND);
{if ("" != null) return TimeUnit.NANOSECOND;}
        break;
        }
      case SQL_TSI_MICROSECOND:{
        jj_consume_token(SQL_TSI_MICROSECOND);
{if ("" != null) return TimeUnit.MICROSECOND;}
        break;
        }
      case SECOND:{
        jj_consume_token(SECOND);
{if ("" != null) return TimeUnit.SECOND;}
        break;
        }
      case SQL_TSI_SECOND:{
        jj_consume_token(SQL_TSI_SECOND);
{if ("" != null) return TimeUnit.SECOND;}
        break;
        }
      case MINUTE:{
        jj_consume_token(MINUTE);
{if ("" != null) return TimeUnit.MINUTE;}
        break;
        }
      case SQL_TSI_MINUTE:{
        jj_consume_token(SQL_TSI_MINUTE);
{if ("" != null) return TimeUnit.MINUTE;}
        break;
        }
      case HOUR:{
        jj_consume_token(HOUR);
{if ("" != null) return TimeUnit.HOUR;}
        break;
        }
      case SQL_TSI_HOUR:{
        jj_consume_token(SQL_TSI_HOUR);
{if ("" != null) return TimeUnit.HOUR;}
        break;
        }
      case DAY:{
        jj_consume_token(DAY);
{if ("" != null) return TimeUnit.DAY;}
        break;
        }
      case SQL_TSI_DAY:{
        jj_consume_token(SQL_TSI_DAY);
{if ("" != null) return TimeUnit.DAY;}
        break;
        }
      case WEEK:{
        jj_consume_token(WEEK);
{if ("" != null) return TimeUnit.WEEK;}
        break;
        }
      case SQL_TSI_WEEK:{
        jj_consume_token(SQL_TSI_WEEK);
{if ("" != null) return TimeUnit.WEEK;}
        break;
        }
      case MONTH:{
        jj_consume_token(MONTH);
{if ("" != null) return TimeUnit.MONTH;}
        break;
        }
      case SQL_TSI_MONTH:{
        jj_consume_token(SQL_TSI_MONTH);
{if ("" != null) return TimeUnit.MONTH;}
        break;
        }
      case QUARTER:{
        jj_consume_token(QUARTER);
{if ("" != null) return TimeUnit.QUARTER;}
        break;
        }
      case SQL_TSI_QUARTER:{
        jj_consume_token(SQL_TSI_QUARTER);
{if ("" != null) return TimeUnit.QUARTER;}
        break;
        }
      case YEAR:{
        jj_consume_token(YEAR);
{if ("" != null) return TimeUnit.YEAR;}
        break;
        }
      case SQL_TSI_YEAR:{
        jj_consume_token(SQL_TSI_YEAR);
{if ("" != null) return TimeUnit.YEAR;}
        break;
        }
      default:
        jj_la1[198] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TimestampInterval");
    }
}

/**
 * Parses a dynamic parameter marker.
 */
  final public SqlDynamicParam DynamicParam() throws ParseException {
    trace_call("DynamicParam");
    try {

      jj_consume_token(HOOK);
{if ("" != null) return new SqlDynamicParam(nDynamicParams++, getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DynamicParam");
    }
}

/**
 * Parses one segment of an identifier that may be composite.
 *
 * <p>Each time it reads an identifier it writes one element to each list;
 * the entry in {@code positions} records its position and whether the
 * segment was quoted.
 */
  final public void IdentifierSegment(List<String> names, List<SqlParserPos> positions) throws ParseException {
    trace_call("IdentifierSegment");
    try {
final String id;
    char unicodeEscapeChar = BACKSLASH;
    final SqlParserPos pos;
    final Span span;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
id = unquotedIdentifier();
            pos = getPos();
        break;
        }
      case QUOTED_IDENTIFIER:{
        jj_consume_token(QUOTED_IDENTIFIER);
id = SqlParserUtil.strip(getToken(0).image, DQ, DQ, DQDQ,
                quotedCasing);
            pos = getPos().withQuoting(true);
        break;
        }
      case BACK_QUOTED_IDENTIFIER:{
        jj_consume_token(BACK_QUOTED_IDENTIFIER);
id = SqlParserUtil.strip(getToken(0).image, "`", "`", "``",
                quotedCasing);
            pos = getPos().withQuoting(true);
        break;
        }
      case BRACKET_QUOTED_IDENTIFIER:{
        jj_consume_token(BRACKET_QUOTED_IDENTIFIER);
id = SqlParserUtil.strip(getToken(0).image, "[", "]", "]]",
                quotedCasing);
            pos = getPos().withQuoting(true);
        break;
        }
      case UNICODE_QUOTED_IDENTIFIER:{
        jj_consume_token(UNICODE_QUOTED_IDENTIFIER);
span = span();
            String image = getToken(0).image;
            image = image.substring(image.indexOf('"'));
            image = SqlParserUtil.strip(image, DQ, DQ, DQDQ, quotedCasing);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UESCAPE:{
          jj_consume_token(UESCAPE);
          jj_consume_token(QUOTED_STRING);
String s = SqlParserUtil.parseString(token.image);
                unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s);
          break;
          }
        default:
          jj_la1[199] = jj_gen;
          ;
        }
pos = span.end(this).withQuoting(true);
            SqlLiteral lit = SqlLiteral.createCharString(image, "UTF16", pos);
            lit = lit.unescapeUnicode(unicodeEscapeChar);
            id = lit.toValue();
        break;
        }
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:{
        id = NonReservedKeyWord();
pos = getPos();
        break;
        }
      default:
        jj_la1[200] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
if (id.length() > this.identifierMaxLength) {
            {if (true) throw SqlUtil.newContextException(pos,
                RESOURCE.identifierTooLong(id, this.identifierMaxLength));}
        }
        names.add(id);
        if (positions != null) {
            positions.add(pos);
        }
    } finally {
      trace_return("IdentifierSegment");
    }
}

/**
 * Parses a simple identifier as a String.
 */
  final public String Identifier() throws ParseException {
    trace_call("Identifier");
    try {
final List<String> names = new ArrayList<String>();
      IdentifierSegment(names, null);
{if ("" != null) return names.get(0);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("Identifier");
    }
}

/**
 * Parses a simple identifier as an SqlIdentifier.
 */
  final public SqlIdentifier SimpleIdentifier() throws ParseException {
    trace_call("SimpleIdentifier");
    try {
final List<String> names = new ArrayList<String>();
    final List<SqlParserPos> positions = new ArrayList<SqlParserPos>();
      IdentifierSegment(names, positions);
{if ("" != null) return new SqlIdentifier(names.get(0), positions.get(0));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SimpleIdentifier");
    }
}

/**
 * Parses a comma-separated list of simple identifiers.
 */
  final public void SimpleIdentifierCommaList(List<SqlNode> list) throws ParseException {
    trace_call("SimpleIdentifierCommaList");
    try {
SqlIdentifier id;
      id = SimpleIdentifier();
list.add(id);
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[201] = jj_gen;
          break label_31;
        }
        jj_consume_token(COMMA);
        id = SimpleIdentifier();
list.add(id);
      }
    } finally {
      trace_return("SimpleIdentifierCommaList");
    }
}

/**
  * List of simple identifiers in parentheses. The position extends from the
  * open parenthesis to the close parenthesis.
  */
  final public SqlNodeList ParenthesizedSimpleIdentifierList() throws ParseException {
    trace_call("ParenthesizedSimpleIdentifierList");
    try {
final Span s;
    final List<SqlNode> list = new ArrayList<SqlNode>();
      jj_consume_token(LPAREN);
s = span();
      SimpleIdentifierCommaList(list);
      jj_consume_token(RPAREN);
{if ("" != null) return new SqlNodeList(list, s.end(this));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParenthesizedSimpleIdentifierList");
    }
}

/**
 * Parses a compound identifier.
 */
  final public SqlIdentifier CompoundIdentifier() throws ParseException {
    trace_call("CompoundIdentifier");
    try {
final List<String> nameList = new ArrayList<String>();
    final List<SqlParserPos> posList = new ArrayList<SqlParserPos>();
    boolean star = false;
      IdentifierSegment(nameList, posList);
      label_32:
      while (true) {
        if (jj_2_69(2)) {
          ;
        } else {
          break label_32;
        }
        jj_consume_token(DOT);
        IdentifierSegment(nameList, posList);
      }
      if (jj_2_70(2)) {
        jj_consume_token(DOT);
        jj_consume_token(STAR);
star = true;
            nameList.add("");
            posList.add(getPos());
      } else {
        ;
      }
SqlParserPos pos = SqlParserPos.sum(posList);
        if (star) {
            {if ("" != null) return SqlIdentifier.star(nameList, pos, posList);}
        }
        {if ("" != null) return new SqlIdentifier(nameList, null, pos, posList);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CompoundIdentifier");
    }
}

/**
 * Parses a comma-separated list of compound identifiers.
 */
  final public void CompoundIdentifierTypeCommaList(List<SqlNode> list, List<SqlNode> extendList) throws ParseException {
    trace_call("CompoundIdentifierTypeCommaList");
    try {

      CompoundIdentifierType(list, extendList);
      label_33:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[202] = jj_gen;
          break label_33;
        }
        jj_consume_token(COMMA);
        CompoundIdentifierType(list, extendList);
      }
    } finally {
      trace_return("CompoundIdentifierTypeCommaList");
    }
}

/**
 * List of compound identifiers in parentheses. The position extends from the
 * open parenthesis to the close parenthesis.
 */
  final public Pair<SqlNodeList, SqlNodeList> ParenthesizedCompoundIdentifierList() throws ParseException {
    trace_call("ParenthesizedCompoundIdentifierList");
    try {
final Span s;
    final List<SqlNode> list = new ArrayList<SqlNode>();
    final List<SqlNode> extendList = new ArrayList<SqlNode>();
      jj_consume_token(LPAREN);
s = span();
      CompoundIdentifierTypeCommaList(list, extendList);
      jj_consume_token(RPAREN);
{if ("" != null) return Pair.of(new SqlNodeList(list, s.end(this)), new SqlNodeList(extendList, s.end(this)));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ParenthesizedCompoundIdentifierList");
    }
}

/**
 * Parses a NEW UDT(...) expression.
 */
  final public SqlNode NewSpecification() throws ParseException {
    trace_call("NewSpecification");
    try {
final Span s;
    final SqlNode routineCall;
      jj_consume_token(NEW);
s = span();
      routineCall = NamedRoutineCall(SqlFunctionCategory.USER_DEFINED_CONSTRUCTOR,
                  ExprContext.ACCEPT_SUB_QUERY);
{if ("" != null) return SqlStdOperatorTable.NEW.createCall(s.end(routineCall), routineCall);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NewSpecification");
    }
}

//TODO: real parse errors.
  final public int UnsignedIntLiteral() throws ParseException {
    trace_call("UnsignedIntLiteral");
    try {
Token t;
      t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
try {
            {if ("" != null) return Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw generateParseException();}
        }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("UnsignedIntLiteral");
    }
}

  final public int IntLiteral() throws ParseException {
    trace_call("IntLiteral");
    try {
Token t;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNSIGNED_INTEGER_LITERAL:
      case PLUS:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UNSIGNED_INTEGER_LITERAL:{
          t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
          break;
          }
        case PLUS:{
          jj_consume_token(PLUS);
          t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
          break;
          }
        default:
          jj_la1[203] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
try {
            {if ("" != null) return Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw generateParseException();}
        }
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
        t = jj_consume_token(UNSIGNED_INTEGER_LITERAL);
try {
            {if ("" != null) return -Integer.parseInt(t.image);}
        } catch (NumberFormatException ex) {
            {if (true) throw generateParseException();}
        }
        break;
        }
      default:
        jj_la1[204] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("IntLiteral");
    }
}

// Type name with optional scale and precision
  final public SqlDataTypeSpec DataType() throws ParseException {
    trace_call("DataType");
    try {
final SqlIdentifier typeName;
    SqlIdentifier collectionTypeName = null;
    int scale = -1;
    int precision = -1;
    String charSetName = null;
    final Span s;
      typeName = TypeName();
s = span();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        jj_consume_token(LPAREN);
        precision = UnsignedIntLiteral();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          jj_consume_token(COMMA);
          scale = UnsignedIntLiteral();
          break;
          }
        default:
          jj_la1[205] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
        }
      default:
        jj_la1[206] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CHARACTER:{
        jj_consume_token(CHARACTER);
        jj_consume_token(SET);
        charSetName = Identifier();
        break;
        }
      default:
        jj_la1[207] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTISET:{
        collectionTypeName = CollectionsTypeName();
        break;
        }
      default:
        jj_la1[208] = jj_gen;
        ;
      }
if (null != collectionTypeName) {
            {if ("" != null) return new SqlDataTypeSpec(
                collectionTypeName,
                typeName,
                precision,
                scale,
                charSetName,
                s.end(collectionTypeName));}
        }
        {if ("" != null) return new SqlDataTypeSpec(
            typeName,
            precision,
            scale,
            charSetName,
            null,
            s.end(this));}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("DataType");
    }
}

// Some SQL type names need special handling due to the fact that they have
// spaces in them but are not quoted.
  final public SqlIdentifier TypeName() throws ParseException {
    trace_call("TypeName");
    try {
final SqlTypeName sqlTypeName;
    final SqlIdentifier typeName;
    final Span s = Span.of();
      if (jj_2_71(2)) {
        sqlTypeName = SqlTypeName(s);
typeName = new SqlIdentifier(sqlTypeName.name(), s.end(this));
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MULTISET:{
          typeName = CollectionsTypeName();
          break;
          }
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          typeName = CompoundIdentifier();
          break;
          }
        default:
          jj_la1[209] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
{if ("" != null) return typeName;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TypeName");
    }
}

// Types used for JDBC and ODBC scalar conversion function
  final public SqlTypeName SqlTypeName(Span s) throws ParseException {
    trace_call("SqlTypeName");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CHAR:
      case CHARACTER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CHARACTER:{
          jj_consume_token(CHARACTER);
          break;
          }
        case CHAR:{
          jj_consume_token(CHAR);
          break;
          }
        default:
          jj_la1[210] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
s.add(this);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VARYING:{
          jj_consume_token(VARYING);
{if ("" != null) return SqlTypeName.VARCHAR;}
          break;
          }
        default:
          jj_la1[211] = jj_gen;
{if ("" != null) return SqlTypeName.CHAR;}
        }
        break;
        }
      case VARCHAR:{
        jj_consume_token(VARCHAR);
{if ("" != null) return SqlTypeName.VARCHAR;}
        break;
        }
      case DATE:{
        jj_consume_token(DATE);
{if ("" != null) return SqlTypeName.DATE;}
        break;
        }
      case TIME:{
        jj_consume_token(TIME);
{if ("" != null) return SqlTypeName.TIME;}
        break;
        }
      case TIMESTAMP:{
        jj_consume_token(TIMESTAMP);
{if ("" != null) return SqlTypeName.TIMESTAMP;}
        break;
        }
      case GEOMETRY:{
        jj_consume_token(GEOMETRY);
if (!this.conformance.allowGeometry()) {
            {if (true) throw new ParseException(RESOURCE.geometryDisabled().str());}
        }
        {if ("" != null) return SqlTypeName.GEOMETRY;}
        break;
        }
      case DEC:
      case DECIMAL:
      case NUMERIC:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DECIMAL:{
          jj_consume_token(DECIMAL);
          break;
          }
        case DEC:{
          jj_consume_token(DEC);
          break;
          }
        case NUMERIC:{
          jj_consume_token(NUMERIC);
          break;
          }
        default:
          jj_la1[212] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlTypeName.DECIMAL;}
        break;
        }
      case BOOLEAN:{
        jj_consume_token(BOOLEAN);
{if ("" != null) return SqlTypeName.BOOLEAN;}
        break;
        }
      case INT:
      case INTEGER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INTEGER:{
          jj_consume_token(INTEGER);
          break;
          }
        case INT:{
          jj_consume_token(INT);
          break;
          }
        default:
          jj_la1[213] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlTypeName.INTEGER;}
        break;
        }
      case BINARY:{
        jj_consume_token(BINARY);
s.add(this);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VARYING:{
          jj_consume_token(VARYING);
{if ("" != null) return SqlTypeName.VARBINARY;}
          break;
          }
        default:
          jj_la1[214] = jj_gen;
{if ("" != null) return SqlTypeName.BINARY;}
        }
        break;
        }
      case VARBINARY:{
        jj_consume_token(VARBINARY);
{if ("" != null) return SqlTypeName.VARBINARY;}
        break;
        }
      case TINYINT:{
        jj_consume_token(TINYINT);
{if ("" != null) return SqlTypeName.TINYINT;}
        break;
        }
      case SMALLINT:{
        jj_consume_token(SMALLINT);
{if ("" != null) return SqlTypeName.SMALLINT;}
        break;
        }
      case BIGINT:{
        jj_consume_token(BIGINT);
{if ("" != null) return SqlTypeName.BIGINT;}
        break;
        }
      case REAL:{
        jj_consume_token(REAL);
{if ("" != null) return SqlTypeName.REAL;}
        break;
        }
      case DOUBLE:{
        jj_consume_token(DOUBLE);
s.add(this);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PRECISION:{
          jj_consume_token(PRECISION);
          break;
          }
        default:
          jj_la1[215] = jj_gen;
          ;
        }
{if ("" != null) return SqlTypeName.DOUBLE;}
        break;
        }
      case FLOAT:{
        jj_consume_token(FLOAT);
{if ("" != null) return SqlTypeName.FLOAT;}
        break;
        }
      case ANY:{
        jj_consume_token(ANY);
{if ("" != null) return SqlTypeName.ANY;}
        break;
        }
      default:
        jj_la1[216] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("SqlTypeName");
    }
}

// Types used for for JDBC and ODBC scalar conversion function
  final public SqlJdbcDataTypeName JdbcOdbcDataTypeName() throws ParseException {
    trace_call("JdbcOdbcDataTypeName");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CHAR:
      case SQL_CHAR:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_CHAR:{
          jj_consume_token(SQL_CHAR);
          break;
          }
        case CHAR:{
          jj_consume_token(CHAR);
          break;
          }
        default:
          jj_la1[217] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_CHAR;}
        break;
        }
      case SQL_VARCHAR:
      case VARCHAR:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_VARCHAR:{
          jj_consume_token(SQL_VARCHAR);
          break;
          }
        case VARCHAR:{
          jj_consume_token(VARCHAR);
          break;
          }
        default:
          jj_la1[218] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_VARCHAR;}
        break;
        }
      case DATE:
      case SQL_DATE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_DATE:{
          jj_consume_token(SQL_DATE);
          break;
          }
        case DATE:{
          jj_consume_token(DATE);
          break;
          }
        default:
          jj_la1[219] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_DATE;}
        break;
        }
      case SQL_TIME:
      case TIME:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_TIME:{
          jj_consume_token(SQL_TIME);
          break;
          }
        case TIME:{
          jj_consume_token(TIME);
          break;
          }
        default:
          jj_la1[220] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_TIME;}
        break;
        }
      case SQL_TIMESTAMP:
      case TIMESTAMP:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_TIMESTAMP:{
          jj_consume_token(SQL_TIMESTAMP);
          break;
          }
        case TIMESTAMP:{
          jj_consume_token(TIMESTAMP);
          break;
          }
        default:
          jj_la1[221] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_TIMESTAMP;}
        break;
        }
      case DECIMAL:
      case SQL_DECIMAL:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_DECIMAL:{
          jj_consume_token(SQL_DECIMAL);
          break;
          }
        case DECIMAL:{
          jj_consume_token(DECIMAL);
          break;
          }
        default:
          jj_la1[222] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_DECIMAL;}
        break;
        }
      case NUMERIC:
      case SQL_NUMERIC:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_NUMERIC:{
          jj_consume_token(SQL_NUMERIC);
          break;
          }
        case NUMERIC:{
          jj_consume_token(NUMERIC);
          break;
          }
        default:
          jj_la1[223] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_NUMERIC;}
        break;
        }
      case BOOLEAN:
      case SQL_BOOLEAN:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_BOOLEAN:{
          jj_consume_token(SQL_BOOLEAN);
          break;
          }
        case BOOLEAN:{
          jj_consume_token(BOOLEAN);
          break;
          }
        default:
          jj_la1[224] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_BOOLEAN;}
        break;
        }
      case INTEGER:
      case SQL_INTEGER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_INTEGER:{
          jj_consume_token(SQL_INTEGER);
          break;
          }
        case INTEGER:{
          jj_consume_token(INTEGER);
          break;
          }
        default:
          jj_la1[225] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTEGER;}
        break;
        }
      case BINARY:
      case SQL_BINARY:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_BINARY:{
          jj_consume_token(SQL_BINARY);
          break;
          }
        case BINARY:{
          jj_consume_token(BINARY);
          break;
          }
        default:
          jj_la1[226] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_BINARY;}
        break;
        }
      case SQL_VARBINARY:
      case VARBINARY:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_VARBINARY:{
          jj_consume_token(SQL_VARBINARY);
          break;
          }
        case VARBINARY:{
          jj_consume_token(VARBINARY);
          break;
          }
        default:
          jj_la1[227] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_VARBINARY;}
        break;
        }
      case SQL_TINYINT:
      case TINYINT:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_TINYINT:{
          jj_consume_token(SQL_TINYINT);
          break;
          }
        case TINYINT:{
          jj_consume_token(TINYINT);
          break;
          }
        default:
          jj_la1[228] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_TINYINT;}
        break;
        }
      case SMALLINT:
      case SQL_SMALLINT:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_SMALLINT:{
          jj_consume_token(SQL_SMALLINT);
          break;
          }
        case SMALLINT:{
          jj_consume_token(SMALLINT);
          break;
          }
        default:
          jj_la1[229] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_SMALLINT;}
        break;
        }
      case BIGINT:
      case SQL_BIGINT:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_BIGINT:{
          jj_consume_token(SQL_BIGINT);
          break;
          }
        case BIGINT:{
          jj_consume_token(BIGINT);
          break;
          }
        default:
          jj_la1[230] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_BIGINT;}
        break;
        }
      case REAL:
      case SQL_REAL:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_REAL:{
          jj_consume_token(SQL_REAL);
          break;
          }
        case REAL:{
          jj_consume_token(REAL);
          break;
          }
        default:
          jj_la1[231] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_REAL;}
        break;
        }
      case DOUBLE:
      case SQL_DOUBLE:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_DOUBLE:{
          jj_consume_token(SQL_DOUBLE);
          break;
          }
        case DOUBLE:{
          jj_consume_token(DOUBLE);
          break;
          }
        default:
          jj_la1[232] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_DOUBLE;}
        break;
        }
      case FLOAT:
      case SQL_FLOAT:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SQL_FLOAT:{
          jj_consume_token(SQL_FLOAT);
          break;
          }
        case FLOAT:{
          jj_consume_token(FLOAT);
          break;
          }
        default:
          jj_la1[233] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlJdbcDataTypeName.SQL_FLOAT;}
        break;
        }
      case SQL_INTERVAL_YEAR:{
        jj_consume_token(SQL_INTERVAL_YEAR);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_YEAR;}
        break;
        }
      case SQL_INTERVAL_YEAR_TO_MONTH:{
        jj_consume_token(SQL_INTERVAL_YEAR_TO_MONTH);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_YEAR_TO_MONTH;}
        break;
        }
      case SQL_INTERVAL_MONTH:{
        jj_consume_token(SQL_INTERVAL_MONTH);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_MONTH;}
        break;
        }
      case SQL_INTERVAL_DAY:{
        jj_consume_token(SQL_INTERVAL_DAY);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_DAY;}
        break;
        }
      case SQL_INTERVAL_DAY_TO_HOUR:{
        jj_consume_token(SQL_INTERVAL_DAY_TO_HOUR);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_HOUR;}
        break;
        }
      case SQL_INTERVAL_DAY_TO_MINUTE:{
        jj_consume_token(SQL_INTERVAL_DAY_TO_MINUTE);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_MINUTE;}
        break;
        }
      case SQL_INTERVAL_DAY_TO_SECOND:{
        jj_consume_token(SQL_INTERVAL_DAY_TO_SECOND);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_SECOND;}
        break;
        }
      case SQL_INTERVAL_HOUR:{
        jj_consume_token(SQL_INTERVAL_HOUR);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR;}
        break;
        }
      case SQL_INTERVAL_HOUR_TO_MINUTE:{
        jj_consume_token(SQL_INTERVAL_HOUR_TO_MINUTE);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR_TO_MINUTE;}
        break;
        }
      case SQL_INTERVAL_HOUR_TO_SECOND:{
        jj_consume_token(SQL_INTERVAL_HOUR_TO_SECOND);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR_TO_SECOND;}
        break;
        }
      case SQL_INTERVAL_MINUTE:{
        jj_consume_token(SQL_INTERVAL_MINUTE);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_MINUTE;}
        break;
        }
      case SQL_INTERVAL_MINUTE_TO_SECOND:{
        jj_consume_token(SQL_INTERVAL_MINUTE_TO_SECOND);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_MINUTE_TO_SECOND;}
        break;
        }
      case SQL_INTERVAL_SECOND:{
        jj_consume_token(SQL_INTERVAL_SECOND);
{if ("" != null) return SqlJdbcDataTypeName.SQL_INTERVAL_SECOND;}
        break;
        }
      default:
        jj_la1[234] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JdbcOdbcDataTypeName");
    }
}

  final public SqlLiteral JdbcOdbcDataType() throws ParseException {
    trace_call("JdbcOdbcDataType");
    try {
SqlJdbcDataTypeName typeName;
      typeName = JdbcOdbcDataTypeName();
{if ("" != null) return typeName.symbol(getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JdbcOdbcDataType");
    }
}

  final public SqlIdentifier CollectionsTypeName() throws ParseException {
    trace_call("CollectionsTypeName");
    try {

      jj_consume_token(MULTISET);
{if ("" != null) return new SqlIdentifier(
            SqlTypeName.MULTISET.name(), getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CollectionsTypeName");
    }
}

/**
 * Parses a CURSOR(query) expression.  The parser allows these
 * anywhere, but the validator restricts them to appear only as
 * arguments to table functions.
 */
  final public SqlNode CursorExpression(ExprContext exprContext) throws ParseException {
    trace_call("CursorExpression");
    try {
final SqlNode e;
    final Span s;
      jj_consume_token(CURSOR);
s = span();
        if (exprContext != ExprContext.ACCEPT_ALL
                && exprContext != ExprContext.ACCEPT_CURSOR) {
            {if (true) throw SqlUtil.newContextException(s.end(this),
                RESOURCE.illegalCursorExpression());}
        }
      e = Expression(ExprContext.ACCEPT_QUERY);
{if ("" != null) return SqlStdOperatorTable.CURSOR.createCall(s.end(e), e);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("CursorExpression");
    }
}

/**
 * Parses a call to a builtin function with special syntax.
 */
  final public SqlNode BuiltinFunctionCall() throws ParseException {
    trace_call("BuiltinFunctionCall");
    try {
final SqlIdentifier name;
    List<SqlNode> args = null;
    SqlNode e = null;
    final Span s;
    SqlDataTypeSpec dt;
    TimeUnit interval;
    final SqlNode node;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CAST:{
        jj_consume_token(CAST);
s = span();
        jj_consume_token(LPAREN);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args = startList(e);
        jj_consume_token(AS);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case ANY:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BIGINT:
        case BINARY:
        case BOOLEAN:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHAR:
        case CHARACTER:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DEC:
        case DECADE:
        case DECIMAL:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOUBLE:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FLOAT:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INT:
        case INTEGER:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MULTISET:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case NUMERIC:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case REAL:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SMALLINT:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIME:
        case TIMESTAMP:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TINYINT:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VARBINARY:
        case VARCHAR:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          dt = DataType();
args.add(dt);
          break;
          }
        case INTERVAL:{
          jj_consume_token(INTERVAL);
          e = IntervalQualifier();
args.add(e);
          break;
          }
        default:
          jj_la1[235] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.CAST.createCall(s.end(this), args);}
        break;
        }
      case EXTRACT:{
        jj_consume_token(EXTRACT);
s = span();
            TimeUnit unit;
        jj_consume_token(LPAREN);
        unit = TimeUnit();
args = startList(new SqlIntervalQualifier(unit, null, getPos()));
        jj_consume_token(FROM);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.EXTRACT.createCall(s.end(this), args);}
        break;
        }
      case POSITION:{
        jj_consume_token(POSITION);
s = span();
        jj_consume_token(LPAREN);
        // FIXME jvs 31-Aug-2006:  FRG-192:  This should be
                // Expression(ExprContext.ACCEPT_SUB_QUERY), but that doesn't work
                // because it matches the other kind of IN.
                e = AtomicRowExpression();
args = startList(e);
        jj_consume_token(IN);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FROM:{
          jj_consume_token(FROM);
          e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
          break;
          }
        default:
          jj_la1[236] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.POSITION.createCall(s.end(this), args);}
        break;
        }
      case CONVERT:{
        jj_consume_token(CONVERT);
s = span();
        jj_consume_token(LPAREN);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args = startList(e);
        jj_consume_token(USING);
        name = SimpleIdentifier();
args.add(name);
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.CONVERT.createCall(s.end(this), args);}
        break;
        }
      case TRANSLATE:{
        jj_consume_token(TRANSLATE);
s = span();
        jj_consume_token(LPAREN);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args = startList(e);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case USING:{
          jj_consume_token(USING);
          name = SimpleIdentifier();
args.add(name);
          jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.TRANSLATE.createCall(s.end(this),
                    args);}
          break;
          }
        case RPAREN:
        case COMMA:{
          label_34:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case COMMA:{
              ;
              break;
              }
            default:
              jj_la1[237] = jj_gen;
              break label_34;
            }
            jj_consume_token(COMMA);
            e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
          }
          jj_consume_token(RPAREN);
{if ("" != null) return OracleSqlOperatorTable.TRANSLATE3.createCall(
                    s.end(this), args);}
          break;
          }
        default:
          jj_la1[238] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      case OVERLAY:{
        jj_consume_token(OVERLAY);
s = span();
        jj_consume_token(LPAREN);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args = startList(e);
        jj_consume_token(PLACING);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
        jj_consume_token(FROM);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FOR:{
          jj_consume_token(FOR);
          e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
          break;
          }
        default:
          jj_la1[239] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.OVERLAY.createCall(s.end(this), args);}
        break;
        }
      case FLOOR:{
        jj_consume_token(FLOOR);
s = span();
        e = FloorCeilOptions(s, true);
{if ("" != null) return e;}
        break;
        }
      case CEIL:
      case CEILING:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CEIL:{
          jj_consume_token(CEIL);
          break;
          }
        case CEILING:{
          jj_consume_token(CEILING);
          break;
          }
        default:
          jj_la1[240] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
s = span();
        e = FloorCeilOptions(s, false);
{if ("" != null) return e;}
        break;
        }
      case SUBSTRING:{
        jj_consume_token(SUBSTRING);
s = span();
        jj_consume_token(LPAREN);
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args = startList(e);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FROM:{
          jj_consume_token(FROM);
          break;
          }
        case COMMA:{
          jj_consume_token(COMMA);
          break;
          }
        default:
          jj_la1[241] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case FOR:
        case COMMA:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case FOR:{
            jj_consume_token(FOR);
            break;
            }
          case COMMA:{
            jj_consume_token(COMMA);
            break;
            }
          default:
            jj_la1[242] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
          break;
          }
        default:
          jj_la1[243] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.SUBSTRING.createCall(
                s.end(this), args);}
        break;
        }
      case TRIM:{
        jj_consume_token(TRIM);
SqlLiteral flag = null;
            SqlNode trimChars = null;
            s = span();
        jj_consume_token(LPAREN);
        if (jj_2_73(2)) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case BOTH:
          case LEADING:
          case TRAILING:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case BOTH:{
              jj_consume_token(BOTH);
s.add(this);
                    flag = SqlTrimFunction.Flag.BOTH.symbol(getPos());
              break;
              }
            case TRAILING:{
              jj_consume_token(TRAILING);
s.add(this);
                    flag = SqlTrimFunction.Flag.TRAILING.symbol(getPos());
              break;
              }
            case LEADING:{
              jj_consume_token(LEADING);
s.add(this);
                    flag = SqlTrimFunction.Flag.LEADING.symbol(getPos());
              break;
              }
            default:
              jj_la1[244] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          default:
            jj_la1[245] = jj_gen;
            ;
          }
          if (jj_2_72(1)) {
            trimChars = Expression(ExprContext.ACCEPT_SUB_QUERY);
          } else {
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case FROM:{
            jj_consume_token(FROM);
if (null == flag && null == trimChars) {
                        {if (true) throw SqlUtil.newContextException(getPos(),
                            RESOURCE.illegalFromEmpty());}
                    }
            break;
            }
          case RPAREN:{
            jj_consume_token(RPAREN);
// This is to handle the case of TRIM(x)
                    // (FRG-191).
                    if (flag == null) {
                        flag = SqlTrimFunction.Flag.BOTH.symbol(SqlParserPos.ZERO);
                    }
                    args = startList(flag);
                    args.add(null); // no trim chars
                    args.add(trimChars); // reinterpret trimChars as source
                    {if ("" != null) return SqlStdOperatorTable.TRIM.createCall(s.end(this),
                        args);}
            break;
            }
          default:
            jj_la1[246] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          ;
        }
        e = Expression(ExprContext.ACCEPT_SUB_QUERY);
if (flag == null) {
                flag = SqlTrimFunction.Flag.BOTH.symbol(SqlParserPos.ZERO);
            }
            args = startList(flag);
            args.add(trimChars);
            args.add(e);
        jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.TRIM.createCall(s.end(this), args);}
        break;
        }
      case TIMESTAMPADD:{
        node = TimestampAddFunctionCall();
{if ("" != null) return node;}
        break;
        }
      case TIMESTAMPDIFF:{
        node = TimestampDiffFunctionCall();
{if ("" != null) return node;}
        break;
        }
      default:
        jj_la1[247] = jj_gen;
        if (jj_2_74(1)) {
          node = ExtendedBuiltinFunctionCall();
{if ("" != null) return node;}
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case CLASSIFIER:
          case FINAL:
          case FIRST:
          case LAST:
          case MATCH_NUMBER:
          case NEXT:
          case PREV:
          case RUNNING:{
            node = MatchRecognizeFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_EXISTS:{
            node = JsonExistsFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_VALUE:{
            node = JsonValueFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_PRETTY:{
            node = JsonPrettyFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_QUERY:{
            node = JsonQueryFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_OBJECT:{
            node = JsonObjectFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_TYPE:{
            node = JsonTypeFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_DEPTH:{
            node = JsonDepthFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_OBJECTAGG:{
            node = JsonObjectAggFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_ARRAY:{
            node = JsonArrayFunctionCall();
{if ("" != null) return node;}
            break;
            }
          case JSON_ARRAYAGG:{
            node = JsonArrayAggFunctionCall();
{if ("" != null) return node;}
            break;
            }
          default:
            jj_la1[248] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BuiltinFunctionCall");
    }
}

  final public SqlJsonEncoding JsonRepresentation() throws ParseException {
    trace_call("JsonRepresentation");
    try {

      jj_consume_token(JSON);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENCODING:{
        jj_consume_token(ENCODING);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UTF8:{
          jj_consume_token(UTF8);
{if ("" != null) return SqlJsonEncoding.UTF8;}
          break;
          }
        case UTF16:{
          jj_consume_token(UTF16);
{if ("" != null) return SqlJsonEncoding.UTF16;}
          break;
          }
        case UTF32:{
          jj_consume_token(UTF32);
{if ("" != null) return SqlJsonEncoding.UTF32;}
          break;
          }
        default:
          jj_la1[249] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[250] = jj_gen;
        ;
      }
{if ("" != null) return SqlJsonEncoding.UTF8;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonRepresentation");
    }
}

  final public void JsonInputClause() throws ParseException {
    trace_call("JsonInputClause");
    try {

      jj_consume_token(FORMAT);
      JsonRepresentation();
    } finally {
      trace_return("JsonInputClause");
    }
}

  final public SqlDataTypeSpec JsonReturningClause() throws ParseException {
    trace_call("JsonReturningClause");
    try {
SqlDataTypeSpec dt;
      jj_consume_token(RETURNING);
      dt = DataType();
{if ("" != null) return dt;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonReturningClause");
    }
}

  final public SqlDataTypeSpec JsonOutputClause() throws ParseException {
    trace_call("JsonOutputClause");
    try {
SqlDataTypeSpec dataType;
      dataType = JsonReturningClause();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FORMAT:{
        jj_consume_token(FORMAT);
        JsonRepresentation();
        break;
        }
      default:
        jj_la1[251] = jj_gen;
        ;
      }
{if ("" != null) return dataType;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonOutputClause");
    }
}

  final public SqlNode JsonValueExpression(boolean implicitFormatJson) throws ParseException {
    trace_call("JsonValueExpression");
    try {
SqlNode e;
    List<SqlNode> args = new ArrayList<SqlNode>();
    Span span;
      e = Expression(ExprContext.ACCEPT_NON_QUERY);
args.add(e);
        span = Span.of(e);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FORMAT:{
        JsonInputClause();
{if ("" != null) return SqlStdOperatorTable.JSON_VALUE_EXPRESSION.createCall(span.end(this), args);}
        break;
        }
      default:
        jj_la1[252] = jj_gen;
        ;
      }
if (implicitFormatJson) {
            {if ("" != null) return SqlStdOperatorTable.JSON_VALUE_EXPRESSION.createCall(span.end(this), args);}
        }
        {if ("" != null) return SqlStdOperatorTable.JSON_STRUCTURED_VALUE_EXPRESSION.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonValueExpression");
    }
}

  final public SqlNode JsonPathSpec() throws ParseException {
    trace_call("JsonPathSpec");
    try {
SqlNode e;
      e = StringLiteral();
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonPathSpec");
    }
}

  final public SqlNode JsonApiCommonSyntax() throws ParseException {
    trace_call("JsonApiCommonSyntax");
    try {
SqlNode e;
    List<SqlNode> args = new ArrayList<SqlNode>();
    Span span;
      e = JsonValueExpression(true);
args.add(e);
        span = Span.of(e);
      jj_consume_token(COMMA);
      e = Expression(ExprContext.ACCEPT_NON_QUERY);
args.add(e);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PASSING:{
        jj_consume_token(PASSING);
        e = JsonValueExpression(false);
args.add(e);
        jj_consume_token(AS);
        e = SimpleIdentifier();
args.add(e);
        label_35:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[253] = jj_gen;
            break label_35;
          }
          jj_consume_token(COMMA);
          e = JsonValueExpression(false);
args.add(e);
          jj_consume_token(AS);
          e = SimpleIdentifier();
args.add(e);
        }
        break;
        }
      default:
        jj_la1[254] = jj_gen;
        ;
      }
{if ("" != null) return SqlStdOperatorTable.JSON_API_COMMON_SYNTAX.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonApiCommonSyntax");
    }
}

  final public SqlJsonExistsErrorBehavior JsonExistsErrorBehavior() throws ParseException {
    trace_call("JsonExistsErrorBehavior");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TRUE:{
        jj_consume_token(TRUE);
{if ("" != null) return SqlJsonExistsErrorBehavior.TRUE;}
        break;
        }
      case FALSE:{
        jj_consume_token(FALSE);
{if ("" != null) return SqlJsonExistsErrorBehavior.FALSE;}
        break;
        }
      case UNKNOWN:{
        jj_consume_token(UNKNOWN);
{if ("" != null) return SqlJsonExistsErrorBehavior.UNKNOWN;}
        break;
        }
      case ERROR:{
        jj_consume_token(ERROR);
{if ("" != null) return SqlJsonExistsErrorBehavior.ERROR;}
        break;
        }
      default:
        jj_la1[255] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonExistsErrorBehavior");
    }
}

  final public SqlCall JsonExistsFunctionCall() throws ParseException {
    trace_call("JsonExistsFunctionCall");
    try {
List<SqlNode> args;
    SqlNode e;
    final Span span;
    SqlJsonExistsErrorBehavior errorBehavior;
      jj_consume_token(JSON_EXISTS);
span = span();
      jj_consume_token(LPAREN);
      e = JsonApiCommonSyntax();
args = new ArrayList<SqlNode>();
        args.add(e);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ERROR:
      case FALSE:
      case TRUE:
      case UNKNOWN:{
        errorBehavior = JsonExistsErrorBehavior();
args.add(SqlLiteral.createSymbol(errorBehavior, getPos()));
        jj_consume_token(ON);
        jj_consume_token(ERROR);
        break;
        }
      default:
        jj_la1[256] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.JSON_EXISTS.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonExistsFunctionCall");
    }
}

  final public List<SqlNode> JsonValueEmptyOrErrorBehavior() throws ParseException {
    trace_call("JsonValueEmptyOrErrorBehavior");
    try {
final List<SqlNode> list = new ArrayList<SqlNode>();
    final SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ERROR:{
        jj_consume_token(ERROR);
list.add(SqlLiteral.createSymbol(SqlJsonValueEmptyOrErrorBehavior.ERROR, getPos()));
            list.add(SqlLiteral.createNull(getPos()));
        break;
        }
      case NULL:{
        jj_consume_token(NULL);
list.add(SqlLiteral.createSymbol(SqlJsonValueEmptyOrErrorBehavior.NULL, getPos()));
            list.add(SqlLiteral.createNull(getPos()));
        break;
        }
      case DEFAULT_:{
        jj_consume_token(DEFAULT_);
        e = Expression(ExprContext.ACCEPT_NON_QUERY);
list.add(SqlLiteral.createSymbol(SqlJsonValueEmptyOrErrorBehavior.DEFAULT, getPos()));
            list.add(e);
        break;
        }
      default:
        jj_la1[257] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(ON);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EMPTY:{
        jj_consume_token(EMPTY);
list.add(SqlLiteral.createSymbol(SqlJsonEmptyOrError.EMPTY, getPos()));
        break;
        }
      case ERROR:{
        jj_consume_token(ERROR);
list.add(SqlLiteral.createSymbol(SqlJsonEmptyOrError.ERROR, getPos()));
        break;
        }
      default:
        jj_la1[258] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonValueEmptyOrErrorBehavior");
    }
}

  final public SqlCall JsonValueFunctionCall() throws ParseException {
    trace_call("JsonValueFunctionCall");
    try {
final SqlNode[] args = new SqlNode[6];
    SqlNode e;
    final Span span;
    List<SqlNode> behavior;
      jj_consume_token(JSON_VALUE);
span = span();
      jj_consume_token(LPAREN);
      e = JsonApiCommonSyntax();
args[0] = e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RETURNING:{
        e = JsonReturningClause();
args[5] = e;
        break;
        }
      default:
        jj_la1[259] = jj_gen;
        ;
      }
      label_36:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DEFAULT_:
        case ERROR:
        case NULL:{
          ;
          break;
          }
        default:
          jj_la1[260] = jj_gen;
          break label_36;
        }
        behavior = JsonValueEmptyOrErrorBehavior();
final SqlJsonEmptyOrError symbol =
                ((SqlLiteral) behavior.get(2)).getValueAs(SqlJsonEmptyOrError.class);
            switch (symbol) {
            case EMPTY:
                args[1] = behavior.get(0);
                args[2] = behavior.get(1);
                break;
            case ERROR:
                args[3] = behavior.get(0);
                args[4] = behavior.get(1);
                break;
            }
      }
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.JSON_VALUE.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonValueFunctionCall");
    }
}

  final public SqlCall JsonPrettyFunctionCall() throws ParseException {
    trace_call("JsonPrettyFunctionCall");
    try {
final SqlNode[] args = new SqlNode[1];
    SqlNode e;
    final Span span;
      jj_consume_token(JSON_PRETTY);
span = span();
      jj_consume_token(LPAREN);
      e = JsonValueExpression(true);
args[0] = e;
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.JSON_PRETTY.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonPrettyFunctionCall");
    }
}

  final public List<SqlNode> JsonQueryEmptyOrErrorBehavior() throws ParseException {
    trace_call("JsonQueryEmptyOrErrorBehavior");
    try {
final List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ERROR:{
        jj_consume_token(ERROR);
list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.ERROR, getPos()));
        break;
        }
      case NULL:{
        jj_consume_token(NULL);
list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.NULL, getPos()));
        break;
        }
      default:
        jj_la1[261] = jj_gen;
        if (jj_2_75(2)) {
          jj_consume_token(EMPTY);
          jj_consume_token(ARRAY);
list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.EMPTY_ARRAY, getPos()));
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EMPTY:{
            jj_consume_token(EMPTY);
            jj_consume_token(OBJECT);
list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.EMPTY_OBJECT, getPos()));
            break;
            }
          default:
            jj_la1[262] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jj_consume_token(ON);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EMPTY:{
        jj_consume_token(EMPTY);
list.add(SqlLiteral.createSymbol(SqlJsonEmptyOrError.EMPTY, getPos()));
        break;
        }
      case ERROR:{
        jj_consume_token(ERROR);
list.add(SqlLiteral.createSymbol(SqlJsonEmptyOrError.ERROR, getPos()));
        break;
        }
      default:
        jj_la1[263] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonQueryEmptyOrErrorBehavior");
    }
}

  final public SqlNode JsonQueryWrapperBehavior() throws ParseException {
    trace_call("JsonQueryWrapperBehavior");
    try {
SqlNode e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITHOUT:{
        jj_consume_token(WITHOUT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ARRAY:{
          jj_consume_token(ARRAY);
          break;
          }
        default:
          jj_la1[264] = jj_gen;
          ;
        }
{if ("" != null) return SqlLiteral.createSymbol(SqlJsonQueryWrapperBehavior.WITHOUT_ARRAY, getPos());}
        break;
        }
      default:
        jj_la1[268] = jj_gen;
        if (jj_2_76(2)) {
          jj_consume_token(WITH);
          jj_consume_token(CONDITIONAL);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ARRAY:{
            jj_consume_token(ARRAY);
            break;
            }
          default:
            jj_la1[265] = jj_gen;
            ;
          }
{if ("" != null) return SqlLiteral.createSymbol(SqlJsonQueryWrapperBehavior.WITH_CONDITIONAL_ARRAY, getPos());}
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case WITH:{
            jj_consume_token(WITH);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case UNCONDITIONAL:{
              jj_consume_token(UNCONDITIONAL);
              break;
              }
            default:
              jj_la1[266] = jj_gen;
              ;
            }
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case ARRAY:{
              jj_consume_token(ARRAY);
              break;
              }
            default:
              jj_la1[267] = jj_gen;
              ;
            }
{if ("" != null) return SqlLiteral.createSymbol(SqlJsonQueryWrapperBehavior.WITH_UNCONDITIONAL_ARRAY, getPos());}
            break;
            }
          default:
            jj_la1[269] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonQueryWrapperBehavior");
    }
}

  final public SqlCall JsonQueryFunctionCall() throws ParseException {
    trace_call("JsonQueryFunctionCall");
    try {
final SqlNode[] args = new SqlNode[4];
    SqlNode e;
    final Span span;
    List<SqlNode> behavior;
      jj_consume_token(JSON_QUERY);
span = span();
      jj_consume_token(LPAREN);
      e = JsonApiCommonSyntax();
args[0] = e;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITH:
      case WITHOUT:{
        e = JsonQueryWrapperBehavior();
        jj_consume_token(WRAPPER);
args[1] = e;
        break;
        }
      default:
        jj_la1[270] = jj_gen;
        ;
      }
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EMPTY:
        case ERROR:
        case NULL:{
          ;
          break;
          }
        default:
          jj_la1[271] = jj_gen;
          break label_37;
        }
        behavior = JsonQueryEmptyOrErrorBehavior();
final SqlJsonEmptyOrError symbol =
                ((SqlLiteral) behavior.get(1)).getValueAs(SqlJsonEmptyOrError.class);
            switch (symbol) {
            case EMPTY:
                args[2] = behavior.get(0);
                break;
            case ERROR:
                args[3] = behavior.get(0);
                break;
            }
      }
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.JSON_QUERY.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonQueryFunctionCall");
    }
}

  final public SqlNode JsonName() throws ParseException {
    trace_call("JsonName");
    try {
final SqlNode e;
      e = Expression(ExprContext.ACCEPT_NON_QUERY);
{if ("" != null) return e;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonName");
    }
}

  final public List<SqlNode> JsonNameAndValue() throws ParseException {
    trace_call("JsonNameAndValue");
    try {
final List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode e;
    boolean kvMode = false;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case KEY:{
        jj_consume_token(KEY);
kvMode = true;
        break;
        }
      default:
        jj_la1[272] = jj_gen;
        ;
      }
      e = JsonName();
list.add(e);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VALUE:{
        jj_consume_token(VALUE);
        break;
        }
      case COLON:{
        jj_consume_token(COLON);
if (kvMode) {
                {if (true) throw SqlUtil.newContextException(getPos(), RESOURCE.illegalColon());}
            }
        break;
        }
      default:
        jj_la1[273] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      e = JsonValueExpression(false);
list.add(e);
{if ("" != null) return list;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonNameAndValue");
    }
}

  final public SqlNode JsonConstructorNullClause() throws ParseException {
    trace_call("JsonConstructorNullClause");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NULL:{
        jj_consume_token(NULL);
        jj_consume_token(ON);
        jj_consume_token(NULL);
{if ("" != null) return SqlLiteral.createSymbol(SqlJsonConstructorNullClause.NULL_ON_NULL, getPos());}
        break;
        }
      case ABSENT:{
        jj_consume_token(ABSENT);
        jj_consume_token(ON);
        jj_consume_token(NULL);
{if ("" != null) return SqlLiteral.createSymbol(SqlJsonConstructorNullClause.ABSENT_ON_NULL, getPos());}
        break;
        }
      default:
        jj_la1[274] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonConstructorNullClause");
    }
}

  final public SqlCall JsonObjectFunctionCall() throws ParseException {
    trace_call("JsonObjectFunctionCall");
    try {
final List<SqlNode> nvArgs = new ArrayList<SqlNode>();
    final SqlNode[] otherArgs = new SqlNode[1];
    SqlNode e;
    List<SqlNode> list;
    final Span span;
      jj_consume_token(JSON_OBJECT);
span = span();
      jj_consume_token(LPAREN);
      if (jj_2_77(2)) {
        list = JsonNameAndValue();
nvArgs.addAll(list);
        label_38:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[275] = jj_gen;
            break label_38;
          }
          jj_consume_token(COMMA);
          list = JsonNameAndValue();
nvArgs.addAll(list);
        }
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSENT:
      case NULL:{
        e = JsonConstructorNullClause();
otherArgs[0] = e;
        break;
        }
      default:
        jj_la1[276] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
final List<SqlNode> args = new ArrayList();
        args.addAll(Arrays.asList(otherArgs));
        args.addAll(nvArgs);
        {if ("" != null) return SqlStdOperatorTable.JSON_OBJECT.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonObjectFunctionCall");
    }
}

  final public SqlCall JsonTypeFunctionCall() throws ParseException {
    trace_call("JsonTypeFunctionCall");
    try {
final SqlNode[] args = new SqlNode[1];
    SqlNode e;
    final Span span;
      jj_consume_token(JSON_TYPE);
span = span();
      jj_consume_token(LPAREN);
      e = JsonValueExpression(true);
args[0] = e;
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.JSON_TYPE.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonTypeFunctionCall");
    }
}

  final public SqlCall JsonDepthFunctionCall() throws ParseException {
    trace_call("JsonDepthFunctionCall");
    try {
final SqlNode[] args = new SqlNode[1];
    SqlNode e;
    final Span span;
      jj_consume_token(JSON_DEPTH);
span = span();
      jj_consume_token(LPAREN);
      e = JsonValueExpression(true);
args[0] = e;
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.JSON_DEPTH.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonDepthFunctionCall");
    }
}

  final public SqlCall JsonObjectAggFunctionCall() throws ParseException {
    trace_call("JsonObjectAggFunctionCall");
    try {
final SqlNode[] args = new SqlNode[2];
    List<SqlNode> list;
    final Span span;
    SqlJsonConstructorNullClause nullClause =
        SqlJsonConstructorNullClause.NULL_ON_NULL;
    final SqlNode e;
      jj_consume_token(JSON_OBJECTAGG);
span = span();
      jj_consume_token(LPAREN);
      list = JsonNameAndValue();
args[0] = list.get(0);
        args[1] = list.get(1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSENT:
      case NULL:{
        e = JsonConstructorNullClause();
nullClause = (SqlJsonConstructorNullClause) ((SqlLiteral) e).getValue();
        break;
        }
      default:
        jj_la1[277] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.JSON_OBJECTAGG.with(nullClause)
            .createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonObjectAggFunctionCall");
    }
}

  final public SqlCall JsonArrayFunctionCall() throws ParseException {
    trace_call("JsonArrayFunctionCall");
    try {
final List<SqlNode> elements = new ArrayList<SqlNode>();
    final SqlNode[] otherArgs = new SqlNode[1];
    SqlNode e;
    final Span span;
      jj_consume_token(JSON_ARRAY);
span = span();
      jj_consume_token(LPAREN);
      if (jj_2_78(2)) {
        e = JsonValueExpression(false);
elements.add(e);
        label_39:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COMMA:{
            ;
            break;
            }
          default:
            jj_la1[278] = jj_gen;
            break label_39;
          }
          jj_consume_token(COMMA);
          e = JsonValueExpression(false);
elements.add(e);
        }
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSENT:
      case NULL:{
        e = JsonConstructorNullClause();
otherArgs[0] = e;
        break;
        }
      default:
        jj_la1[279] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
final List<SqlNode> args = new ArrayList();
        args.addAll(Arrays.asList(otherArgs));
        args.addAll(elements);
        {if ("" != null) return SqlStdOperatorTable.JSON_ARRAY.createCall(span.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonArrayFunctionCall");
    }
}

  final public SqlNodeList JsonArrayAggOrderByClause() throws ParseException {
    trace_call("JsonArrayAggOrderByClause");
    try {
final SqlNodeList orderList;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ORDER:{
        orderList = OrderBy(true);
        break;
        }
      default:
        jj_la1[280] = jj_gen;
orderList = null;
      }
{if ("" != null) return orderList;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonArrayAggOrderByClause");
    }
}

  final public SqlCall JsonArrayAggFunctionCall() throws ParseException {
    trace_call("JsonArrayAggFunctionCall");
    try {
final SqlNode valueExpr;
    SqlNodeList orderList = null;
    List<SqlNode> list;
    final Span span;
    SqlJsonConstructorNullClause nullClause =
        SqlJsonConstructorNullClause.ABSENT_ON_NULL;
    SqlNode e = null;
    final SqlNode aggCall;
      jj_consume_token(JSON_ARRAYAGG);
span = span();
      jj_consume_token(LPAREN);
      e = JsonValueExpression(false);
valueExpr = e;
      orderList = JsonArrayAggOrderByClause();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSENT:
      case NULL:{
        e = JsonConstructorNullClause();
nullClause = (SqlJsonConstructorNullClause) ((SqlLiteral) e).getValue();
        break;
        }
      default:
        jj_la1[281] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
aggCall = SqlStdOperatorTable.JSON_ARRAYAGG.with(nullClause)
            .createCall(span.end(this), valueExpr, orderList);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITHIN:{
        e = withinGroup(aggCall);
if (orderList != null) {
                {if (true) throw SqlUtil.newContextException(span.pos().plus(e.getParserPosition()),
                    RESOURCE.ambiguousSortOrderInJsonArrayAggFunc());}
            }
            {if ("" != null) return (SqlCall) e;}
        break;
        }
      default:
        jj_la1[282] = jj_gen;
        ;
      }
if (orderList == null) {
            {if ("" != null) return SqlStdOperatorTable.JSON_ARRAYAGG.with(nullClause)
                .createCall(span.end(this), valueExpr);}
        }
        {if ("" != null) return SqlStdOperatorTable.JSON_ARRAYAGG.with(nullClause)
            .createCall(span.end(this), valueExpr, orderList);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JsonArrayAggFunctionCall");
    }
}

/**
 * Parses a call to TIMESTAMPADD.
 */
  final public SqlCall TimestampAddFunctionCall() throws ParseException {
    trace_call("TimestampAddFunctionCall");
    try {
List<SqlNode> args;
    SqlNode e;
    final Span s;
    TimeUnit interval;
    SqlNode node;
      jj_consume_token(TIMESTAMPADD);
s = span();
      jj_consume_token(LPAREN);
      interval = TimestampInterval();
args = startList(SqlLiteral.createSymbol(interval, getPos()));
      jj_consume_token(COMMA);
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
      jj_consume_token(COMMA);
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.TIMESTAMP_ADD.createCall(
            s.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TimestampAddFunctionCall");
    }
}

/**
 * Parses a call to TIMESTAMPDIFF.
 */
  final public SqlCall TimestampDiffFunctionCall() throws ParseException {
    trace_call("TimestampDiffFunctionCall");
    try {
List<SqlNode> args;
    SqlNode e;
    final Span s;
    TimeUnit interval;
    SqlNode node;
      jj_consume_token(TIMESTAMPDIFF);
s = span();
      jj_consume_token(LPAREN);
      interval = TimestampInterval();
args = startList(SqlLiteral.createSymbol(interval, getPos()));
      jj_consume_token(COMMA);
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
      jj_consume_token(COMMA);
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args.add(e);
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.TIMESTAMP_DIFF.createCall(
            s.end(this), args);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("TimestampDiffFunctionCall");
    }
}

  final public SqlCall MatchRecognizeFunctionCall() throws ParseException {
    trace_call("MatchRecognizeFunctionCall");
    try {
final SqlCall func;
    final Span s;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CLASSIFIER:{
        jj_consume_token(CLASSIFIER);
s = span();
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
func = SqlStdOperatorTable.CLASSIFIER.createCall(s.end(this));
        break;
        }
      case MATCH_NUMBER:{
        jj_consume_token(MATCH_NUMBER);
s = span();
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
func = SqlStdOperatorTable.MATCH_NUMBER.createCall(s.end(this));
        break;
        }
      default:
        jj_la1[283] = jj_gen;
        if (jj_2_79(3)) {
          func = MatchRecognizeNavigationLogical();
        } else if (jj_2_80(2)) {
          func = MatchRecognizeNavigationPhysical();
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case FINAL:
          case RUNNING:{
            func = MatchRecognizeCallWithModifier();
            break;
            }
          default:
            jj_la1[284] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
{if ("" != null) return func;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MatchRecognizeFunctionCall");
    }
}

  final public SqlCall MatchRecognizeCallWithModifier() throws ParseException {
    trace_call("MatchRecognizeCallWithModifier");
    try {
final Span s;
    final SqlOperator runningOp;
    final SqlNode func;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RUNNING:{
        jj_consume_token(RUNNING);
runningOp = SqlStdOperatorTable.RUNNING;
        break;
        }
      case FINAL:{
        jj_consume_token(FINAL);
runningOp = SqlStdOperatorTable.FINAL;
        break;
        }
      default:
        jj_la1[285] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
s = span();
      func = NamedFunctionCall();
{if ("" != null) return runningOp.createCall(s.end(func), func);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MatchRecognizeCallWithModifier");
    }
}

  final public SqlCall MatchRecognizeNavigationLogical() throws ParseException {
    trace_call("MatchRecognizeNavigationLogical");
    try {
final Span s = Span.of();
    SqlCall func;
    final SqlOperator funcOp;
    final SqlOperator runningOp;
    SqlNode arg0;
    SqlNode arg1 = SqlLiteral.createExactNumeric("0", SqlParserPos.ZERO);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RUNNING:{
        jj_consume_token(RUNNING);
runningOp = SqlStdOperatorTable.RUNNING; s.add(this);
        break;
        }
      case FINAL:{
        jj_consume_token(FINAL);
runningOp = SqlStdOperatorTable.FINAL; s.add(this);
        break;
        }
      default:
        jj_la1[286] = jj_gen;
runningOp = null;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FIRST:{
        jj_consume_token(FIRST);
funcOp = SqlStdOperatorTable.FIRST;
        break;
        }
      case LAST:{
        jj_consume_token(LAST);
funcOp = SqlStdOperatorTable.LAST;
        break;
        }
      default:
        jj_la1[287] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
s.add(this);
      jj_consume_token(LPAREN);
      arg0 = Expression(ExprContext.ACCEPT_SUB_QUERY);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        jj_consume_token(COMMA);
        arg1 = NumericLiteral();
        break;
        }
      default:
        jj_la1[288] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
func = funcOp.createCall(s.end(this), arg0, arg1);
        if (runningOp != null) {
            {if ("" != null) return runningOp.createCall(s.end(this), func);}
        } else {
            {if ("" != null) return func;}
        }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MatchRecognizeNavigationLogical");
    }
}

  final public SqlCall MatchRecognizeNavigationPhysical() throws ParseException {
    trace_call("MatchRecognizeNavigationPhysical");
    try {
final Span s;
    SqlCall func;
    SqlOperator funcOp;
    SqlNode arg0;
    SqlNode arg1 = SqlLiteral.createExactNumeric("1", SqlParserPos.ZERO);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PREV:{
        jj_consume_token(PREV);
funcOp = SqlStdOperatorTable.PREV;
        break;
        }
      case NEXT:{
        jj_consume_token(NEXT);
funcOp = SqlStdOperatorTable.NEXT;
        break;
        }
      default:
        jj_la1[289] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
s = span();
      jj_consume_token(LPAREN);
      arg0 = Expression(ExprContext.ACCEPT_SUB_QUERY);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        jj_consume_token(COMMA);
        arg1 = NumericLiteral();
        break;
        }
      default:
        jj_la1[290] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
{if ("" != null) return funcOp.createCall(s.end(this), arg0, arg1);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("MatchRecognizeNavigationPhysical");
    }
}

  final public SqlCall withinGroup(SqlNode arg) throws ParseException {
    trace_call("withinGroup");
    try {
final Span withinGroupSpan;
    final SqlNodeList orderList;
      jj_consume_token(WITHIN);
withinGroupSpan = span();
      jj_consume_token(GROUP);
      jj_consume_token(LPAREN);
      orderList = OrderBy(true);
      jj_consume_token(RPAREN);
{if ("" != null) return SqlStdOperatorTable.WITHIN_GROUP.createCall(
            withinGroupSpan.end(this), arg, orderList);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("withinGroup");
    }
}

/**
 * Parses a call to a named function (could be a builtin with regular
 * syntax, or else a UDF).
 *
 * <p>NOTE: every UDF has two names: an <em>invocation name</em> and a
 * <em>specific name</em>.  Normally, function calls are resolved via overload
 * resolution and invocation names.  The SPECIFIC prefix allows overload
 * resolution to be bypassed.  Note that usage of the SPECIFIC prefix in
 * queries is non-standard; it is used internally by Farrago, e.g. in stored
 * view definitions to permanently bind references to a particular function
 * after the overload resolution performed by view creation.
 *
 * <p>TODO jvs 25-Mar-2005:  Once we have SQL-Flagger support, flag SPECIFIC
 * as non-standard.
 */
  final public SqlNode NamedFunctionCall() throws ParseException {
    trace_call("NamedFunctionCall");
    try {
final SqlFunctionCategory funcType;
    final SqlIdentifier qualifiedName;
    final Span s;
    final List<SqlNode> args;
    SqlCall call;
    final Span filterSpan;
    final SqlNode filter;
    final SqlNode over;
    SqlLiteral quantifier = null;
    SqlNodeList orderList = null;
    final Span withinGroupSpan;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SPECIFIC:{
        jj_consume_token(SPECIFIC);
funcType = SqlFunctionCategory.USER_DEFINED_SPECIFIC_FUNCTION;
        break;
        }
      default:
        jj_la1[291] = jj_gen;
funcType = SqlFunctionCategory.USER_DEFINED_FUNCTION;
      }
      qualifiedName = FunctionName();
s = span();
      if (jj_2_81(2)) {
        jj_consume_token(LPAREN);
        jj_consume_token(STAR);
args = startList(SqlIdentifier.star(getPos()));
        jj_consume_token(RPAREN);
      } else if (jj_2_82(2)) {
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
args = Collections.emptyList();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          args = FunctionParameterList(ExprContext.ACCEPT_SUB_QUERY);
quantifier = (SqlLiteral) args.get(0);
            args.remove(0);
          break;
          }
        default:
          jj_la1[292] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
call = createCall(qualifiedName, s.end(this), funcType, quantifier, args);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITHIN:{
        call = withinGroup(call);
        break;
        }
      default:
        jj_la1[293] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FILTER:{
        jj_consume_token(FILTER);
filterSpan = span();
        jj_consume_token(LPAREN);
        jj_consume_token(WHERE);
        filter = Expression(ExprContext.ACCEPT_SUB_QUERY);
        jj_consume_token(RPAREN);
call = SqlStdOperatorTable.FILTER.createCall(
                filterSpan.end(this), call, filter);
        break;
        }
      default:
        jj_la1[294] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OVER:{
        jj_consume_token(OVER);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          over = SimpleIdentifier();
          break;
          }
        case LPAREN:{
          over = WindowSpecification();
          break;
          }
        default:
          jj_la1[295] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
call = SqlStdOperatorTable.OVER.createCall(s.end(over), call, over);
        break;
        }
      default:
        jj_la1[296] = jj_gen;
        ;
      }
{if ("" != null) return call;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NamedFunctionCall");
    }
}

/*
* Parse Floor/Ceil function parameters
*/
  final public SqlNode StandardFloorCeilOptions(Span s, boolean floorFlag) throws ParseException {
    trace_call("StandardFloorCeilOptions");
    try {
SqlNode e;
    final List<SqlNode> args;
    TimeUnit unit;
    SqlCall function;
    final Span s1;
      jj_consume_token(LPAREN);
      e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args = startList(e);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TO:{
        jj_consume_token(TO);
        unit = TimeUnit();
args.add(new SqlIntervalQualifier(unit, null, getPos()));
        break;
        }
      default:
        jj_la1[297] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
SqlOperator op = floorFlag
            ? SqlStdOperatorTable.FLOOR
            : SqlStdOperatorTable.CEIL;
        function =  op.createCall(s.end(this), args);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OVER:{
        jj_consume_token(OVER);
s1 = span();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case A:
        case ABSENT:
        case ABSOLUTE:
        case ACTION:
        case ADA:
        case ADD:
        case ADMIN:
        case AFTER:
        case ALWAYS:
        case APPLY:
        case ASC:
        case ASSERTION:
        case ASSIGNMENT:
        case ATTRIBUTE:
        case ATTRIBUTES:
        case BEFORE:
        case BERNOULLI:
        case BREADTH:
        case C:
        case CASCADE:
        case CATALOG:
        case CATALOG_NAME:
        case CENTURY:
        case CHAIN:
        case CHARACTER_SET_CATALOG:
        case CHARACTER_SET_NAME:
        case CHARACTER_SET_SCHEMA:
        case CHARACTERISTICS:
        case CHARACTERS:
        case CLASS_ORIGIN:
        case COBOL:
        case COLLATION:
        case COLLATION_CATALOG:
        case COLLATION_NAME:
        case COLLATION_SCHEMA:
        case COLUMN_NAME:
        case COMMAND_FUNCTION:
        case COMMAND_FUNCTION_CODE:
        case COMMITTED:
        case CONDITIONAL:
        case CONDITION_NUMBER:
        case CONNECTION:
        case CONNECTION_NAME:
        case CONSTRAINT_CATALOG:
        case CONSTRAINT_NAME:
        case CONSTRAINT_SCHEMA:
        case CONSTRAINTS:
        case CONSTRUCTOR:
        case CONTINUE:
        case CURSOR_NAME:
        case DATA:
        case DATABASE:
        case DATETIME_INTERVAL_CODE:
        case DATETIME_INTERVAL_PRECISION:
        case DECADE:
        case DEFAULTS:
        case DEFERRABLE:
        case DEFERRED:
        case DEFINED:
        case DEFINER:
        case DEGREE:
        case DEPTH:
        case DERIVED:
        case DESC:
        case DESCRIPTION:
        case DESCRIPTOR:
        case DIAGNOSTICS:
        case DISPATCH:
        case DOMAIN:
        case DOW:
        case DOY:
        case DYNAMIC_FUNCTION:
        case DYNAMIC_FUNCTION_CODE:
        case ENCODING:
        case EPOCH:
        case ERROR:
        case EXCEPTION:
        case EXCLUDE:
        case EXCLUDING:
        case FINAL:
        case FIRST:
        case FOLLOWING:
        case FORMAT:
        case FORTRAN:
        case FOUND:
        case FRAC_SECOND:
        case G:
        case GENERAL:
        case GENERATED:
        case GEOMETRY:
        case GO:
        case GOTO:
        case GRANTED:
        case HIERARCHY:
        case IMMEDIATE:
        case IMMEDIATELY:
        case IMPLEMENTATION:
        case INCLUDING:
        case INCREMENT:
        case INITIALLY:
        case INPUT:
        case INSTANCE:
        case INSTANTIABLE:
        case INVOKER:
        case ISODOW:
        case ISOYEAR:
        case ISOLATION:
        case JAVA:
        case JSON:
        case JSON_PRETTY:
        case JSON_TYPE:
        case JSON_DEPTH:
        case K:
        case KEY:
        case KEY_MEMBER:
        case KEY_TYPE:
        case LABEL:
        case LAST:
        case LENGTH:
        case LEVEL:
        case LIBRARY:
        case LOCATOR:
        case M:
        case MAP:
        case MATCHED:
        case MAXVALUE:
        case MESSAGE_LENGTH:
        case MESSAGE_OCTET_LENGTH:
        case MESSAGE_TEXT:
        case MICROSECOND:
        case MILLISECOND:
        case MILLENNIUM:
        case MINVALUE:
        case MORE_:
        case MUMPS:
        case NAME:
        case NAMES:
        case NANOSECOND:
        case NESTING:
        case NORMALIZED:
        case NULLABLE:
        case NULLS:
        case NUMBER:
        case OBJECT:
        case OCTETS:
        case OPTION:
        case OPTIONS:
        case ORDERING:
        case ORDINALITY:
        case OTHERS:
        case OUTPUT:
        case OVERRIDING:
        case PAD:
        case PARAMETER_MODE:
        case PARAMETER_NAME:
        case PARAMETER_ORDINAL_POSITION:
        case PARAMETER_SPECIFIC_CATALOG:
        case PARAMETER_SPECIFIC_NAME:
        case PARAMETER_SPECIFIC_SCHEMA:
        case PARTIAL:
        case PASCAL:
        case PASSING:
        case PASSTHROUGH:
        case PAST:
        case PATH:
        case PLACING:
        case PLAN:
        case PLI:
        case PRECEDING:
        case PRESERVE:
        case PRIOR:
        case PRIVILEGES:
        case PUBLIC:
        case QUARTER:
        case READ:
        case RELATIVE:
        case REPEATABLE:
        case REPLACE:
        case RESTART:
        case RESTRICT:
        case RETURNED_CARDINALITY:
        case RETURNED_LENGTH:
        case RETURNED_OCTET_LENGTH:
        case RETURNED_SQLSTATE:
        case RETURNING:
        case ROLE:
        case ROUTINE:
        case ROUTINE_CATALOG:
        case ROUTINE_NAME:
        case ROUTINE_SCHEMA:
        case ROW_COUNT:
        case SCALAR:
        case SCALE:
        case SCHEMA:
        case SCHEMA_NAME:
        case SCOPE_CATALOGS:
        case SCOPE_NAME:
        case SCOPE_SCHEMA:
        case SECTION:
        case SECURITY:
        case SELF:
        case SEQUENCE:
        case SERIALIZABLE:
        case SERVER:
        case SERVER_NAME:
        case SESSION:
        case SETS:
        case SIMPLE:
        case SIZE:
        case SOURCE:
        case SPACE:
        case SPECIFIC_NAME:
        case SQL_BIGINT:
        case SQL_BINARY:
        case SQL_BIT:
        case SQL_BLOB:
        case SQL_BOOLEAN:
        case SQL_CHAR:
        case SQL_CLOB:
        case SQL_DATE:
        case SQL_DECIMAL:
        case SQL_DOUBLE:
        case SQL_FLOAT:
        case SQL_INTEGER:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_MINUTE_TO_SECOND:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_LONGVARBINARY:
        case SQL_LONGVARCHAR:
        case SQL_LONGVARNCHAR:
        case SQL_NCHAR:
        case SQL_NCLOB:
        case SQL_NUMERIC:
        case SQL_NVARCHAR:
        case SQL_REAL:
        case SQL_SMALLINT:
        case SQL_TIME:
        case SQL_TIMESTAMP:
        case SQL_TINYINT:
        case SQL_TSI_DAY:
        case SQL_TSI_FRAC_SECOND:
        case SQL_TSI_HOUR:
        case SQL_TSI_MICROSECOND:
        case SQL_TSI_MINUTE:
        case SQL_TSI_MONTH:
        case SQL_TSI_QUARTER:
        case SQL_TSI_SECOND:
        case SQL_TSI_WEEK:
        case SQL_TSI_YEAR:
        case SQL_VARBINARY:
        case SQL_VARCHAR:
        case STATE:
        case STATEMENT:
        case STRUCTURE:
        case STYLE:
        case SUBCLASS_ORIGIN:
        case SUBSTITUTE:
        case TABLE_NAME:
        case TEMPORARY:
        case TIES:
        case TIMESTAMPADD:
        case TIMESTAMPDIFF:
        case TOP_LEVEL_COUNT:
        case TRANSACTION:
        case TRANSACTIONS_ACTIVE:
        case TRANSACTIONS_COMMITTED:
        case TRANSACTIONS_ROLLED_BACK:
        case TRANSFORM:
        case TRANSFORMS:
        case TRIGGER_CATALOG:
        case TRIGGER_NAME:
        case TRIGGER_SCHEMA:
        case TYPE:
        case UNBOUNDED:
        case UNCOMMITTED:
        case UNCONDITIONAL:
        case UNDER:
        case UNNAMED:
        case USAGE:
        case USER_DEFINED_TYPE_CATALOG:
        case USER_DEFINED_TYPE_CODE:
        case USER_DEFINED_TYPE_NAME:
        case USER_DEFINED_TYPE_SCHEMA:
        case UTF8:
        case UTF16:
        case UTF32:
        case VERSION:
        case VIEW:
        case WEEK:
        case WORK:
        case WRAPPER:
        case WRITE:
        case XML:
        case ZONE:
        case BRACKET_QUOTED_IDENTIFIER:
        case QUOTED_IDENTIFIER:
        case BACK_QUOTED_IDENTIFIER:
        case IDENTIFIER:
        case UNICODE_QUOTED_IDENTIFIER:{
          e = SimpleIdentifier();
          break;
          }
        case LPAREN:{
          e = WindowSpecification();
          break;
          }
        default:
          jj_la1[298] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return SqlStdOperatorTable.OVER.createCall(s1.end(this), function, e);}
        break;
        }
      default:
        jj_la1[299] = jj_gen;
{if ("" != null) return function;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("StandardFloorCeilOptions");
    }
}

/**
 * Parses the name of a JDBC function that is a token but is not reserved.
 */
  final public String NonReservedJdbcFunctionName() throws ParseException {
    trace_call("NonReservedJdbcFunctionName");
    try {

      jj_consume_token(SUBSTRING);
{if ("" != null) return unquotedIdentifier();}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NonReservedJdbcFunctionName");
    }
}

/**
 * Parses the name of a function (either a compound identifier or
 * a reserved word which can be used as a function name).
 */
  final public SqlIdentifier FunctionName() throws ParseException {
    trace_call("FunctionName");
    try {
SqlIdentifier qualifiedName;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ABSENT:
      case ABSOLUTE:
      case ACTION:
      case ADA:
      case ADD:
      case ADMIN:
      case AFTER:
      case ALWAYS:
      case APPLY:
      case ASC:
      case ASSERTION:
      case ASSIGNMENT:
      case ATTRIBUTE:
      case ATTRIBUTES:
      case BEFORE:
      case BERNOULLI:
      case BREADTH:
      case C:
      case CASCADE:
      case CATALOG:
      case CATALOG_NAME:
      case CENTURY:
      case CHAIN:
      case CHARACTER_SET_CATALOG:
      case CHARACTER_SET_NAME:
      case CHARACTER_SET_SCHEMA:
      case CHARACTERISTICS:
      case CHARACTERS:
      case CLASS_ORIGIN:
      case COBOL:
      case COLLATION:
      case COLLATION_CATALOG:
      case COLLATION_NAME:
      case COLLATION_SCHEMA:
      case COLUMN_NAME:
      case COMMAND_FUNCTION:
      case COMMAND_FUNCTION_CODE:
      case COMMITTED:
      case CONDITIONAL:
      case CONDITION_NUMBER:
      case CONNECTION:
      case CONNECTION_NAME:
      case CONSTRAINT_CATALOG:
      case CONSTRAINT_NAME:
      case CONSTRAINT_SCHEMA:
      case CONSTRAINTS:
      case CONSTRUCTOR:
      case CONTINUE:
      case CURSOR_NAME:
      case DATA:
      case DATABASE:
      case DATETIME_INTERVAL_CODE:
      case DATETIME_INTERVAL_PRECISION:
      case DECADE:
      case DEFAULTS:
      case DEFERRABLE:
      case DEFERRED:
      case DEFINED:
      case DEFINER:
      case DEGREE:
      case DEPTH:
      case DERIVED:
      case DESC:
      case DESCRIPTION:
      case DESCRIPTOR:
      case DIAGNOSTICS:
      case DISPATCH:
      case DOMAIN:
      case DOW:
      case DOY:
      case DYNAMIC_FUNCTION:
      case DYNAMIC_FUNCTION_CODE:
      case ENCODING:
      case EPOCH:
      case ERROR:
      case EXCEPTION:
      case EXCLUDE:
      case EXCLUDING:
      case FINAL:
      case FIRST:
      case FOLLOWING:
      case FORMAT:
      case FORTRAN:
      case FOUND:
      case FRAC_SECOND:
      case G:
      case GENERAL:
      case GENERATED:
      case GEOMETRY:
      case GO:
      case GOTO:
      case GRANTED:
      case HIERARCHY:
      case IMMEDIATE:
      case IMMEDIATELY:
      case IMPLEMENTATION:
      case INCLUDING:
      case INCREMENT:
      case INITIALLY:
      case INPUT:
      case INSTANCE:
      case INSTANTIABLE:
      case INVOKER:
      case ISODOW:
      case ISOYEAR:
      case ISOLATION:
      case JAVA:
      case JSON:
      case JSON_PRETTY:
      case JSON_TYPE:
      case JSON_DEPTH:
      case K:
      case KEY:
      case KEY_MEMBER:
      case KEY_TYPE:
      case LABEL:
      case LAST:
      case LENGTH:
      case LEVEL:
      case LIBRARY:
      case LOCATOR:
      case M:
      case MAP:
      case MATCHED:
      case MAXVALUE:
      case MESSAGE_LENGTH:
      case MESSAGE_OCTET_LENGTH:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MILLISECOND:
      case MILLENNIUM:
      case MINVALUE:
      case MORE_:
      case MUMPS:
      case NAME:
      case NAMES:
      case NANOSECOND:
      case NESTING:
      case NORMALIZED:
      case NULLABLE:
      case NULLS:
      case NUMBER:
      case OBJECT:
      case OCTETS:
      case OPTION:
      case OPTIONS:
      case ORDERING:
      case ORDINALITY:
      case OTHERS:
      case OUTPUT:
      case OVERRIDING:
      case PAD:
      case PARAMETER_MODE:
      case PARAMETER_NAME:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARAMETER_SPECIFIC_NAME:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PARTIAL:
      case PASCAL:
      case PASSING:
      case PASSTHROUGH:
      case PAST:
      case PATH:
      case PLACING:
      case PLAN:
      case PLI:
      case PRECEDING:
      case PRESERVE:
      case PRIOR:
      case PRIVILEGES:
      case PUBLIC:
      case QUARTER:
      case READ:
      case RELATIVE:
      case REPEATABLE:
      case REPLACE:
      case RESTART:
      case RESTRICT:
      case RETURNED_CARDINALITY:
      case RETURNED_LENGTH:
      case RETURNED_OCTET_LENGTH:
      case RETURNED_SQLSTATE:
      case RETURNING:
      case ROLE:
      case ROUTINE:
      case ROUTINE_CATALOG:
      case ROUTINE_NAME:
      case ROUTINE_SCHEMA:
      case ROW_COUNT:
      case SCALAR:
      case SCALE:
      case SCHEMA:
      case SCHEMA_NAME:
      case SCOPE_CATALOGS:
      case SCOPE_NAME:
      case SCOPE_SCHEMA:
      case SECTION:
      case SECURITY:
      case SELF:
      case SEQUENCE:
      case SERIALIZABLE:
      case SERVER:
      case SERVER_NAME:
      case SESSION:
      case SETS:
      case SIMPLE:
      case SIZE:
      case SOURCE:
      case SPACE:
      case SPECIFIC_NAME:
      case SQL_BIGINT:
      case SQL_BINARY:
      case SQL_BIT:
      case SQL_BLOB:
      case SQL_BOOLEAN:
      case SQL_CHAR:
      case SQL_CLOB:
      case SQL_DATE:
      case SQL_DECIMAL:
      case SQL_DOUBLE:
      case SQL_FLOAT:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARBINARY:
      case SQL_LONGVARCHAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCHAR:
      case SQL_NCLOB:
      case SQL_NUMERIC:
      case SQL_NVARCHAR:
      case SQL_REAL:
      case SQL_SMALLINT:
      case SQL_TIME:
      case SQL_TIMESTAMP:
      case SQL_TINYINT:
      case SQL_TSI_DAY:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_HOUR:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_MONTH:
      case SQL_TSI_QUARTER:
      case SQL_TSI_SECOND:
      case SQL_TSI_WEEK:
      case SQL_TSI_YEAR:
      case SQL_VARBINARY:
      case SQL_VARCHAR:
      case STATE:
      case STATEMENT:
      case STRUCTURE:
      case STYLE:
      case SUBCLASS_ORIGIN:
      case SUBSTITUTE:
      case TABLE_NAME:
      case TEMPORARY:
      case TIES:
      case TIMESTAMPADD:
      case TIMESTAMPDIFF:
      case TOP_LEVEL_COUNT:
      case TRANSACTION:
      case TRANSACTIONS_ACTIVE:
      case TRANSACTIONS_COMMITTED:
      case TRANSACTIONS_ROLLED_BACK:
      case TRANSFORM:
      case TRANSFORMS:
      case TRIGGER_CATALOG:
      case TRIGGER_NAME:
      case TRIGGER_SCHEMA:
      case TYPE:
      case UNBOUNDED:
      case UNCOMMITTED:
      case UNCONDITIONAL:
      case UNDER:
      case UNNAMED:
      case USAGE:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_CODE:
      case USER_DEFINED_TYPE_NAME:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF8:
      case UTF16:
      case UTF32:
      case VERSION:
      case VIEW:
      case WEEK:
      case WORK:
      case WRAPPER:
      case WRITE:
      case XML:
      case ZONE:
      case BRACKET_QUOTED_IDENTIFIER:
      case QUOTED_IDENTIFIER:
      case BACK_QUOTED_IDENTIFIER:
      case IDENTIFIER:
      case UNICODE_QUOTED_IDENTIFIER:{
        qualifiedName = CompoundIdentifier();
        break;
        }
      case ABS:
      case AVG:
      case CARDINALITY:
      case CEILING:
      case CHAR_LENGTH:
      case CHARACTER_LENGTH:
      case COALESCE:
      case COLLECT:
      case COUNT:
      case COVAR_POP:
      case COVAR_SAMP:
      case CUME_DIST:
      case CURRENT_DATE:
      case CURRENT_TIME:
      case CURRENT_TIMESTAMP:
      case DENSE_RANK:
      case ELEMENT:
      case EXP:
      case FIRST_VALUE:
      case FLOOR:
      case FUSION:
      case GROUPING:
      case HOUR:
      case LAG:
      case LAST_VALUE:
      case LEAD:
      case LN:
      case LOCALTIME:
      case LOCALTIMESTAMP:
      case LOWER:
      case MAX:
      case MIN:
      case MINUTE:
      case MOD:
      case MONTH:
      case NTH_VALUE:
      case NTILE:
      case NULLIF:
      case OCTET_LENGTH:
      case PERCENT_RANK:
      case POWER:
      case RANK:
      case REGR_COUNT:
      case REGR_SXX:
      case REGR_SYY:
      case ROW_NUMBER:
      case SECOND:
      case SQRT:
      case STDDEV_POP:
      case STDDEV_SAMP:
      case SUM:
      case TRUNCATE:
      case UPPER:
      case USER:
      case VAR_POP:
      case VAR_SAMP:
      case YEAR:{
        qualifiedName = ReservedFunctionName();
        break;
        }
      default:
        jj_la1[300] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return qualifiedName;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("FunctionName");
    }
}

/**
 * Parses a reserved word which is used as the name of a function.
 */
  final public SqlIdentifier ReservedFunctionName() throws ParseException {
    trace_call("ReservedFunctionName");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABS:{
        jj_consume_token(ABS);
        break;
        }
      case AVG:{
        jj_consume_token(AVG);
        break;
        }
      case CARDINALITY:{
        jj_consume_token(CARDINALITY);
        break;
        }
      case CEILING:{
        jj_consume_token(CEILING);
        break;
        }
      case CHAR_LENGTH:{
        jj_consume_token(CHAR_LENGTH);
        break;
        }
      case CHARACTER_LENGTH:{
        jj_consume_token(CHARACTER_LENGTH);
        break;
        }
      case COALESCE:{
        jj_consume_token(COALESCE);
        break;
        }
      case COLLECT:{
        jj_consume_token(COLLECT);
        break;
        }
      case COVAR_POP:{
        jj_consume_token(COVAR_POP);
        break;
        }
      case COVAR_SAMP:{
        jj_consume_token(COVAR_SAMP);
        break;
        }
      case CUME_DIST:{
        jj_consume_token(CUME_DIST);
        break;
        }
      case COUNT:{
        jj_consume_token(COUNT);
        break;
        }
      case CURRENT_DATE:{
        jj_consume_token(CURRENT_DATE);
        break;
        }
      case CURRENT_TIME:{
        jj_consume_token(CURRENT_TIME);
        break;
        }
      case CURRENT_TIMESTAMP:{
        jj_consume_token(CURRENT_TIMESTAMP);
        break;
        }
      case DENSE_RANK:{
        jj_consume_token(DENSE_RANK);
        break;
        }
      case ELEMENT:{
        jj_consume_token(ELEMENT);
        break;
        }
      case EXP:{
        jj_consume_token(EXP);
        break;
        }
      case FIRST_VALUE:{
        jj_consume_token(FIRST_VALUE);
        break;
        }
      case FLOOR:{
        jj_consume_token(FLOOR);
        break;
        }
      case FUSION:{
        jj_consume_token(FUSION);
        break;
        }
      case GROUPING:{
        jj_consume_token(GROUPING);
        break;
        }
      case HOUR:{
        jj_consume_token(HOUR);
        break;
        }
      case LAG:{
        jj_consume_token(LAG);
        break;
        }
      case LEAD:{
        jj_consume_token(LEAD);
        break;
        }
      case LAST_VALUE:{
        jj_consume_token(LAST_VALUE);
        break;
        }
      case LN:{
        jj_consume_token(LN);
        break;
        }
      case LOCALTIME:{
        jj_consume_token(LOCALTIME);
        break;
        }
      case LOCALTIMESTAMP:{
        jj_consume_token(LOCALTIMESTAMP);
        break;
        }
      case LOWER:{
        jj_consume_token(LOWER);
        break;
        }
      case MAX:{
        jj_consume_token(MAX);
        break;
        }
      case MIN:{
        jj_consume_token(MIN);
        break;
        }
      case MINUTE:{
        jj_consume_token(MINUTE);
        break;
        }
      case MOD:{
        jj_consume_token(MOD);
        break;
        }
      case MONTH:{
        jj_consume_token(MONTH);
        break;
        }
      case NTH_VALUE:{
        jj_consume_token(NTH_VALUE);
        break;
        }
      case NTILE:{
        jj_consume_token(NTILE);
        break;
        }
      case NULLIF:{
        jj_consume_token(NULLIF);
        break;
        }
      case OCTET_LENGTH:{
        jj_consume_token(OCTET_LENGTH);
        break;
        }
      case PERCENT_RANK:{
        jj_consume_token(PERCENT_RANK);
        break;
        }
      case POWER:{
        jj_consume_token(POWER);
        break;
        }
      case RANK:{
        jj_consume_token(RANK);
        break;
        }
      case REGR_COUNT:{
        jj_consume_token(REGR_COUNT);
        break;
        }
      case REGR_SXX:{
        jj_consume_token(REGR_SXX);
        break;
        }
      case REGR_SYY:{
        jj_consume_token(REGR_SYY);
        break;
        }
      case ROW_NUMBER:{
        jj_consume_token(ROW_NUMBER);
        break;
        }
      case SECOND:{
        jj_consume_token(SECOND);
        break;
        }
      case SQRT:{
        jj_consume_token(SQRT);
        break;
        }
      case STDDEV_POP:{
        jj_consume_token(STDDEV_POP);
        break;
        }
      case STDDEV_SAMP:{
        jj_consume_token(STDDEV_SAMP);
        break;
        }
      case SUM:{
        jj_consume_token(SUM);
        break;
        }
      case UPPER:{
        jj_consume_token(UPPER);
        break;
        }
      case TRUNCATE:{
        jj_consume_token(TRUNCATE);
        break;
        }
      case USER:{
        jj_consume_token(USER);
        break;
        }
      case VAR_POP:{
        jj_consume_token(VAR_POP);
        break;
        }
      case VAR_SAMP:{
        jj_consume_token(VAR_SAMP);
        break;
        }
      case YEAR:{
        jj_consume_token(YEAR);
        break;
        }
      default:
        jj_la1[301] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return new SqlIdentifier(unquotedIdentifier(), getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ReservedFunctionName");
    }
}

  final public SqlIdentifier ContextVariable() throws ParseException {
    trace_call("ContextVariable");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CURRENT_CATALOG:{
        jj_consume_token(CURRENT_CATALOG);
        break;
        }
      case CURRENT_DATE:{
        jj_consume_token(CURRENT_DATE);
        break;
        }
      case CURRENT_DEFAULT_TRANSFORM_GROUP:{
        jj_consume_token(CURRENT_DEFAULT_TRANSFORM_GROUP);
        break;
        }
      case CURRENT_PATH:{
        jj_consume_token(CURRENT_PATH);
        break;
        }
      case CURRENT_ROLE:{
        jj_consume_token(CURRENT_ROLE);
        break;
        }
      case CURRENT_SCHEMA:{
        jj_consume_token(CURRENT_SCHEMA);
        break;
        }
      case CURRENT_TIME:{
        jj_consume_token(CURRENT_TIME);
        break;
        }
      case CURRENT_TIMESTAMP:{
        jj_consume_token(CURRENT_TIMESTAMP);
        break;
        }
      case CURRENT_USER:{
        jj_consume_token(CURRENT_USER);
        break;
        }
      case LOCALTIME:{
        jj_consume_token(LOCALTIME);
        break;
        }
      case LOCALTIMESTAMP:{
        jj_consume_token(LOCALTIMESTAMP);
        break;
        }
      case SESSION_USER:{
        jj_consume_token(SESSION_USER);
        break;
        }
      case SYSTEM_USER:{
        jj_consume_token(SYSTEM_USER);
        break;
        }
      case USER:{
        jj_consume_token(USER);
        break;
        }
      default:
        jj_la1[302] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return new SqlIdentifier(unquotedIdentifier(), getPos());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ContextVariable");
    }
}

/**
 * Parses a function call expression with JDBC syntax.
 */
  final public SqlNode JdbcFunctionCall() throws ParseException {
    trace_call("JdbcFunctionCall");
    try {
String name;
    SqlIdentifier id;
    SqlNode e;
    SqlLiteral tl;
    SqlNodeList args;
    SqlCall call;
    final Span s, s1;
      jj_consume_token(LBRACE_FN);
s = span();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TIMESTAMPADD:{
        call = TimestampAddFunctionCall();
name = call.getOperator().getName();
            args = new SqlNodeList(call.getOperandList(), getPos());
        break;
        }
      default:
        jj_la1[305] = jj_gen;
        if (jj_2_85(3)) {
          call = TimestampDiffFunctionCall();
name = call.getOperator().getName();
            args = new SqlNodeList(call.getOperandList(), getPos());
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case CONVERT:{
            jj_consume_token(CONVERT);
name = unquotedIdentifier();
            jj_consume_token(LPAREN);
            e = Expression(ExprContext.ACCEPT_SUB_QUERY);
args = new SqlNodeList(getPos());
            args.add(e);
            jj_consume_token(COMMA);
            tl = JdbcOdbcDataType();
args.add(tl);
            jj_consume_token(RPAREN);
            break;
            }
          case A:
          case ABS:
          case ABSENT:
          case ABSOLUTE:
          case ACTION:
          case ADA:
          case ADD:
          case ADMIN:
          case AFTER:
          case ALWAYS:
          case APPLY:
          case ASC:
          case ASSERTION:
          case ASSIGNMENT:
          case ATTRIBUTE:
          case ATTRIBUTES:
          case AVG:
          case BEFORE:
          case BERNOULLI:
          case BREADTH:
          case C:
          case CARDINALITY:
          case CASCADE:
          case CATALOG:
          case CATALOG_NAME:
          case CEILING:
          case CENTURY:
          case CHAIN:
          case CHAR_LENGTH:
          case CHARACTER_LENGTH:
          case CHARACTER_SET_CATALOG:
          case CHARACTER_SET_NAME:
          case CHARACTER_SET_SCHEMA:
          case CHARACTERISTICS:
          case CHARACTERS:
          case CLASS_ORIGIN:
          case COALESCE:
          case COBOL:
          case COLLATION:
          case COLLATION_CATALOG:
          case COLLATION_NAME:
          case COLLATION_SCHEMA:
          case COLLECT:
          case COLUMN_NAME:
          case COMMAND_FUNCTION:
          case COMMAND_FUNCTION_CODE:
          case COMMITTED:
          case CONDITIONAL:
          case CONDITION_NUMBER:
          case CONNECTION:
          case CONNECTION_NAME:
          case CONSTRAINT_CATALOG:
          case CONSTRAINT_NAME:
          case CONSTRAINT_SCHEMA:
          case CONSTRAINTS:
          case CONSTRUCTOR:
          case CONTINUE:
          case COUNT:
          case COVAR_POP:
          case COVAR_SAMP:
          case CUME_DIST:
          case CURRENT_DATE:
          case CURRENT_TIME:
          case CURRENT_TIMESTAMP:
          case CURSOR_NAME:
          case DATA:
          case DATABASE:
          case DATETIME_INTERVAL_CODE:
          case DATETIME_INTERVAL_PRECISION:
          case DECADE:
          case DEFAULTS:
          case DEFERRABLE:
          case DEFERRED:
          case DEFINED:
          case DEFINER:
          case DEGREE:
          case DENSE_RANK:
          case DEPTH:
          case DERIVED:
          case DESC:
          case DESCRIPTION:
          case DESCRIPTOR:
          case DIAGNOSTICS:
          case DISPATCH:
          case DOMAIN:
          case DOW:
          case DOY:
          case DYNAMIC_FUNCTION:
          case DYNAMIC_FUNCTION_CODE:
          case ELEMENT:
          case ENCODING:
          case EPOCH:
          case ERROR:
          case EXCEPTION:
          case EXCLUDE:
          case EXCLUDING:
          case EXP:
          case FINAL:
          case FIRST:
          case FIRST_VALUE:
          case FLOOR:
          case FOLLOWING:
          case FORMAT:
          case FORTRAN:
          case FOUND:
          case FRAC_SECOND:
          case FUSION:
          case G:
          case GENERAL:
          case GENERATED:
          case GEOMETRY:
          case GO:
          case GOTO:
          case GRANTED:
          case GROUPING:
          case HIERARCHY:
          case HOUR:
          case IMMEDIATE:
          case IMMEDIATELY:
          case IMPLEMENTATION:
          case INCLUDING:
          case INCREMENT:
          case INITIALLY:
          case INPUT:
          case INSERT:
          case INSTANCE:
          case INSTANTIABLE:
          case INVOKER:
          case ISODOW:
          case ISOYEAR:
          case ISOLATION:
          case JAVA:
          case JSON:
          case JSON_PRETTY:
          case JSON_TYPE:
          case JSON_DEPTH:
          case K:
          case KEY:
          case KEY_MEMBER:
          case KEY_TYPE:
          case LABEL:
          case LAG:
          case LAST:
          case LAST_VALUE:
          case LEAD:
          case LENGTH:
          case LEVEL:
          case LIBRARY:
          case LN:
          case LOCALTIME:
          case LOCALTIMESTAMP:
          case LOCATOR:
          case LOWER:
          case M:
          case MAP:
          case MATCHED:
          case MAX:
          case MAXVALUE:
          case MESSAGE_LENGTH:
          case MESSAGE_OCTET_LENGTH:
          case MESSAGE_TEXT:
          case MICROSECOND:
          case MILLISECOND:
          case MILLENNIUM:
          case MIN:
          case MINUTE:
          case MINVALUE:
          case MOD:
          case MONTH:
          case MORE_:
          case MUMPS:
          case NAME:
          case NAMES:
          case NANOSECOND:
          case NESTING:
          case NORMALIZED:
          case NTH_VALUE:
          case NTILE:
          case NULLABLE:
          case NULLIF:
          case NULLS:
          case NUMBER:
          case OBJECT:
          case OCTET_LENGTH:
          case OCTETS:
          case OPTION:
          case OPTIONS:
          case ORDERING:
          case ORDINALITY:
          case OTHERS:
          case OUTPUT:
          case OVERRIDING:
          case PAD:
          case PARAMETER_MODE:
          case PARAMETER_NAME:
          case PARAMETER_ORDINAL_POSITION:
          case PARAMETER_SPECIFIC_CATALOG:
          case PARAMETER_SPECIFIC_NAME:
          case PARAMETER_SPECIFIC_SCHEMA:
          case PARTIAL:
          case PASCAL:
          case PASSING:
          case PASSTHROUGH:
          case PAST:
          case PATH:
          case PERCENT_RANK:
          case PLACING:
          case PLAN:
          case PLI:
          case POWER:
          case PRECEDING:
          case PRESERVE:
          case PRIOR:
          case PRIVILEGES:
          case PUBLIC:
          case QUARTER:
          case RANK:
          case READ:
          case REGR_COUNT:
          case REGR_SXX:
          case REGR_SYY:
          case RELATIVE:
          case REPEATABLE:
          case REPLACE:
          case RESTART:
          case RESTRICT:
          case RETURNED_CARDINALITY:
          case RETURNED_LENGTH:
          case RETURNED_OCTET_LENGTH:
          case RETURNED_SQLSTATE:
          case RETURNING:
          case ROLE:
          case ROUTINE:
          case ROUTINE_CATALOG:
          case ROUTINE_NAME:
          case ROUTINE_SCHEMA:
          case ROW_COUNT:
          case ROW_NUMBER:
          case SCALAR:
          case SCALE:
          case SCHEMA:
          case SCHEMA_NAME:
          case SCOPE_CATALOGS:
          case SCOPE_NAME:
          case SCOPE_SCHEMA:
          case SECOND:
          case SECTION:
          case SECURITY:
          case SELF:
          case SEQUENCE:
          case SERIALIZABLE:
          case SERVER:
          case SERVER_NAME:
          case SESSION:
          case SETS:
          case SIMPLE:
          case SIZE:
          case SOURCE:
          case SPACE:
          case SPECIFIC_NAME:
          case SQL_BIGINT:
          case SQL_BINARY:
          case SQL_BIT:
          case SQL_BLOB:
          case SQL_BOOLEAN:
          case SQL_CHAR:
          case SQL_CLOB:
          case SQL_DATE:
          case SQL_DECIMAL:
          case SQL_DOUBLE:
          case SQL_FLOAT:
          case SQL_INTEGER:
          case SQL_INTERVAL_DAY:
          case SQL_INTERVAL_DAY_TO_HOUR:
          case SQL_INTERVAL_DAY_TO_MINUTE:
          case SQL_INTERVAL_DAY_TO_SECOND:
          case SQL_INTERVAL_HOUR:
          case SQL_INTERVAL_HOUR_TO_MINUTE:
          case SQL_INTERVAL_HOUR_TO_SECOND:
          case SQL_INTERVAL_MINUTE:
          case SQL_INTERVAL_MINUTE_TO_SECOND:
          case SQL_INTERVAL_MONTH:
          case SQL_INTERVAL_SECOND:
          case SQL_INTERVAL_YEAR:
          case SQL_INTERVAL_YEAR_TO_MONTH:
          case SQL_LONGVARBINARY:
          case SQL_LONGVARCHAR:
          case SQL_LONGVARNCHAR:
          case SQL_NCHAR:
          case SQL_NCLOB:
          case SQL_NUMERIC:
          case SQL_NVARCHAR:
          case SQL_REAL:
          case SQL_SMALLINT:
          case SQL_TIME:
          case SQL_TIMESTAMP:
          case SQL_TINYINT:
          case SQL_TSI_DAY:
          case SQL_TSI_FRAC_SECOND:
          case SQL_TSI_HOUR:
          case SQL_TSI_MICROSECOND:
          case SQL_TSI_MINUTE:
          case SQL_TSI_MONTH:
          case SQL_TSI_QUARTER:
          case SQL_TSI_SECOND:
          case SQL_TSI_WEEK:
          case SQL_TSI_YEAR:
          case SQL_VARBINARY:
          case SQL_VARCHAR:
          case SQRT:
          case STATE:
          case STATEMENT:
          case STDDEV_POP:
          case STDDEV_SAMP:
          case STRUCTURE:
          case STYLE:
          case SUBCLASS_ORIGIN:
          case SUBSTITUTE:
          case SUBSTRING:
          case SUM:
          case TABLE_NAME:
          case TEMPORARY:
          case TIES:
          case TIMESTAMPADD:
          case TIMESTAMPDIFF:
          case TOP_LEVEL_COUNT:
          case TRANSACTION:
          case TRANSACTIONS_ACTIVE:
          case TRANSACTIONS_COMMITTED:
          case TRANSACTIONS_ROLLED_BACK:
          case TRANSFORM:
          case TRANSFORMS:
          case TRIGGER_CATALOG:
          case TRIGGER_NAME:
          case TRIGGER_SCHEMA:
          case TRUNCATE:
          case TYPE:
          case UNBOUNDED:
          case UNCOMMITTED:
          case UNCONDITIONAL:
          case UNDER:
          case UNNAMED:
          case UPPER:
          case USAGE:
          case USER:
          case USER_DEFINED_TYPE_CATALOG:
          case USER_DEFINED_TYPE_CODE:
          case USER_DEFINED_TYPE_NAME:
          case USER_DEFINED_TYPE_SCHEMA:
          case UTF8:
          case UTF16:
          case UTF32:
          case VAR_POP:
          case VAR_SAMP:
          case VERSION:
          case VIEW:
          case WEEK:
          case WORK:
          case WRAPPER:
          case WRITE:
          case XML:
          case YEAR:
          case ZONE:
          case BRACKET_QUOTED_IDENTIFIER:
          case QUOTED_IDENTIFIER:
          case BACK_QUOTED_IDENTIFIER:
          case IDENTIFIER:
          case UNICODE_QUOTED_IDENTIFIER:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case INSERT:{
              jj_consume_token(INSERT);
name = unquotedIdentifier();
              break;
              }
            case TRUNCATE:{
              jj_consume_token(TRUNCATE);
name = unquotedIdentifier();
              break;
              }
            case ABS:
            case AVG:
            case CARDINALITY:
            case CEILING:
            case CHAR_LENGTH:
            case CHARACTER_LENGTH:
            case COALESCE:
            case COLLECT:
            case COUNT:
            case COVAR_POP:
            case COVAR_SAMP:
            case CUME_DIST:
            case CURRENT_DATE:
            case CURRENT_TIME:
            case CURRENT_TIMESTAMP:
            case DENSE_RANK:
            case ELEMENT:
            case EXP:
            case FIRST_VALUE:
            case FLOOR:
            case FUSION:
            case GROUPING:
            case HOUR:
            case LAG:
            case LAST_VALUE:
            case LEAD:
            case LN:
            case LOCALTIME:
            case LOCALTIMESTAMP:
            case LOWER:
            case MAX:
            case MIN:
            case MINUTE:
            case MOD:
            case MONTH:
            case NTH_VALUE:
            case NTILE:
            case NULLIF:
            case OCTET_LENGTH:
            case PERCENT_RANK:
            case POWER:
            case RANK:
            case REGR_COUNT:
            case REGR_SXX:
            case REGR_SYY:
            case ROW_NUMBER:
            case SECOND:
            case SQRT:
            case STDDEV_POP:
            case STDDEV_SAMP:
            case SUM:
            case UPPER:
            case USER:
            case VAR_POP:
            case VAR_SAMP:
            case YEAR:{
              // For cases like {fn power(1,2)} and {fn lower('a')}
                          id = ReservedFunctionName();
name = id.getSimple();
              break;
              }
            case SUBSTRING:{
              // For cases like {fn substring('foo', 1,2)}
                          name = NonReservedJdbcFunctionName();
              break;
              }
            case A:
            case ABSENT:
            case ABSOLUTE:
            case ACTION:
            case ADA:
            case ADD:
            case ADMIN:
            case AFTER:
            case ALWAYS:
            case APPLY:
            case ASC:
            case ASSERTION:
            case ASSIGNMENT:
            case ATTRIBUTE:
            case ATTRIBUTES:
            case BEFORE:
            case BERNOULLI:
            case BREADTH:
            case C:
            case CASCADE:
            case CATALOG:
            case CATALOG_NAME:
            case CENTURY:
            case CHAIN:
            case CHARACTER_SET_CATALOG:
            case CHARACTER_SET_NAME:
            case CHARACTER_SET_SCHEMA:
            case CHARACTERISTICS:
            case CHARACTERS:
            case CLASS_ORIGIN:
            case COBOL:
            case COLLATION:
            case COLLATION_CATALOG:
            case COLLATION_NAME:
            case COLLATION_SCHEMA:
            case COLUMN_NAME:
            case COMMAND_FUNCTION:
            case COMMAND_FUNCTION_CODE:
            case COMMITTED:
            case CONDITIONAL:
            case CONDITION_NUMBER:
            case CONNECTION:
            case CONNECTION_NAME:
            case CONSTRAINT_CATALOG:
            case CONSTRAINT_NAME:
            case CONSTRAINT_SCHEMA:
            case CONSTRAINTS:
            case CONSTRUCTOR:
            case CONTINUE:
            case CURSOR_NAME:
            case DATA:
            case DATABASE:
            case DATETIME_INTERVAL_CODE:
            case DATETIME_INTERVAL_PRECISION:
            case DECADE:
            case DEFAULTS:
            case DEFERRABLE:
            case DEFERRED:
            case DEFINED:
            case DEFINER:
            case DEGREE:
            case DEPTH:
            case DERIVED:
            case DESC:
            case DESCRIPTION:
            case DESCRIPTOR:
            case DIAGNOSTICS:
            case DISPATCH:
            case DOMAIN:
            case DOW:
            case DOY:
            case DYNAMIC_FUNCTION:
            case DYNAMIC_FUNCTION_CODE:
            case ENCODING:
            case EPOCH:
            case ERROR:
            case EXCEPTION:
            case EXCLUDE:
            case EXCLUDING:
            case FINAL:
            case FIRST:
            case FOLLOWING:
            case FORMAT:
            case FORTRAN:
            case FOUND:
            case FRAC_SECOND:
            case G:
            case GENERAL:
            case GENERATED:
            case GEOMETRY:
            case GO:
            case GOTO:
            case GRANTED:
            case HIERARCHY:
            case IMMEDIATE:
            case IMMEDIATELY:
            case IMPLEMENTATION:
            case INCLUDING:
            case INCREMENT:
            case INITIALLY:
            case INPUT:
            case INSTANCE:
            case INSTANTIABLE:
            case INVOKER:
            case ISODOW:
            case ISOYEAR:
            case ISOLATION:
            case JAVA:
            case JSON:
            case JSON_PRETTY:
            case JSON_TYPE:
            case JSON_DEPTH:
            case K:
            case KEY:
            case KEY_MEMBER:
            case KEY_TYPE:
            case LABEL:
            case LAST:
            case LENGTH:
            case LEVEL:
            case LIBRARY:
            case LOCATOR:
            case M:
            case MAP:
            case MATCHED:
            case MAXVALUE:
            case MESSAGE_LENGTH:
            case MESSAGE_OCTET_LENGTH:
            case MESSAGE_TEXT:
            case MICROSECOND:
            case MILLISECOND:
            case MILLENNIUM:
            case MINVALUE:
            case MORE_:
            case MUMPS:
            case NAME:
            case NAMES:
            case NANOSECOND:
            case NESTING:
            case NORMALIZED:
            case NULLABLE:
            case NULLS:
            case NUMBER:
            case OBJECT:
            case OCTETS:
            case OPTION:
            case OPTIONS:
            case ORDERING:
            case ORDINALITY:
            case OTHERS:
            case OUTPUT:
            case OVERRIDING:
            case PAD:
            case PARAMETER_MODE:
            case PARAMETER_NAME:
            case PARAMETER_ORDINAL_POSITION:
            case PARAMETER_SPECIFIC_CATALOG:
            case PARAMETER_SPECIFIC_NAME:
            case PARAMETER_SPECIFIC_SCHEMA:
            case PARTIAL:
            case PASCAL:
            case PASSING:
            case PASSTHROUGH:
            case PAST:
            case PATH:
            case PLACING:
            case PLAN:
            case PLI:
            case PRECEDING:
            case PRESERVE:
            case PRIOR:
            case PRIVILEGES:
            case PUBLIC:
            case QUARTER:
            case READ:
            case RELATIVE:
            case REPEATABLE:
            case REPLACE:
            case RESTART:
            case RESTRICT:
            case RETURNED_CARDINALITY:
            case RETURNED_LENGTH:
            case RETURNED_OCTET_LENGTH:
            case RETURNED_SQLSTATE:
            case RETURNING:
            case ROLE:
            case ROUTINE:
            case ROUTINE_CATALOG:
            case ROUTINE_NAME:
            case ROUTINE_SCHEMA:
            case ROW_COUNT:
            case SCALAR:
            case SCALE:
            case SCHEMA:
            case SCHEMA_NAME:
            case SCOPE_CATALOGS:
            case SCOPE_NAME:
            case SCOPE_SCHEMA:
            case SECTION:
            case SECURITY:
            case SELF:
            case SEQUENCE:
            case SERIALIZABLE:
            case SERVER:
            case SERVER_NAME:
            case SESSION:
            case SETS:
            case SIMPLE:
            case SIZE:
            case SOURCE:
            case SPACE:
            case SPECIFIC_NAME:
            case SQL_BIGINT:
            case SQL_BINARY:
            case SQL_BIT:
            case SQL_BLOB:
            case SQL_BOOLEAN:
            case SQL_CHAR:
            case SQL_CLOB:
            case SQL_DATE:
            case SQL_DECIMAL:
            case SQL_DOUBLE:
            case SQL_FLOAT:
            case SQL_INTEGER:
            case SQL_INTERVAL_DAY:
            case SQL_INTERVAL_DAY_TO_HOUR:
            case SQL_INTERVAL_DAY_TO_MINUTE:
            case SQL_INTERVAL_DAY_TO_SECOND:
            case SQL_INTERVAL_HOUR:
            case SQL_INTERVAL_HOUR_TO_MINUTE:
            case SQL_INTERVAL_HOUR_TO_SECOND:
            case SQL_INTERVAL_MINUTE:
            case SQL_INTERVAL_MINUTE_TO_SECOND:
            case SQL_INTERVAL_MONTH:
            case SQL_INTERVAL_SECOND:
            case SQL_INTERVAL_YEAR:
            case SQL_INTERVAL_YEAR_TO_MONTH:
            case SQL_LONGVARBINARY:
            case SQL_LONGVARCHAR:
            case SQL_LONGVARNCHAR:
            case SQL_NCHAR:
            case SQL_NCLOB:
            case SQL_NUMERIC:
            case SQL_NVARCHAR:
            case SQL_REAL:
            case SQL_SMALLINT:
            case SQL_TIME:
            case SQL_TIMESTAMP:
            case SQL_TINYINT:
            case SQL_TSI_DAY:
            case SQL_TSI_FRAC_SECOND:
            case SQL_TSI_HOUR:
            case SQL_TSI_MICROSECOND:
            case SQL_TSI_MINUTE:
            case SQL_TSI_MONTH:
            case SQL_TSI_QUARTER:
            case SQL_TSI_SECOND:
            case SQL_TSI_WEEK:
            case SQL_TSI_YEAR:
            case SQL_VARBINARY:
            case SQL_VARCHAR:
            case STATE:
            case STATEMENT:
            case STRUCTURE:
            case STYLE:
            case SUBCLASS_ORIGIN:
            case SUBSTITUTE:
            case TABLE_NAME:
            case TEMPORARY:
            case TIES:
            case TIMESTAMPADD:
            case TIMESTAMPDIFF:
            case TOP_LEVEL_COUNT:
            case TRANSACTION:
            case TRANSACTIONS_ACTIVE:
            case TRANSACTIONS_COMMITTED:
            case TRANSACTIONS_ROLLED_BACK:
            case TRANSFORM:
            case TRANSFORMS:
            case TRIGGER_CATALOG:
            case TRIGGER_NAME:
            case TRIGGER_SCHEMA:
            case TYPE:
            case UNBOUNDED:
            case UNCOMMITTED:
            case UNCONDITIONAL:
            case UNDER:
            case UNNAMED:
            case USAGE:
            case USER_DEFINED_TYPE_CATALOG:
            case USER_DEFINED_TYPE_CODE:
            case USER_DEFINED_TYPE_NAME:
            case USER_DEFINED_TYPE_SCHEMA:
            case UTF8:
            case UTF16:
            case UTF32:
            case VERSION:
            case VIEW:
            case WEEK:
            case WORK:
            case WRAPPER:
            case WRITE:
            case XML:
            case ZONE:
            case BRACKET_QUOTED_IDENTIFIER:
            case QUOTED_IDENTIFIER:
            case BACK_QUOTED_IDENTIFIER:
            case IDENTIFIER:
            case UNICODE_QUOTED_IDENTIFIER:{
              name = Identifier();
              break;
              }
            default:
              jj_la1[303] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            if (jj_2_83(2)) {
              jj_consume_token(LPAREN);
              jj_consume_token(STAR);
s1 = span();
              jj_consume_token(RPAREN);
args = new SqlNodeList(s1.pos());
                args.add(SqlIdentifier.star(s1.pos()));
            } else if (jj_2_84(2)) {
              jj_consume_token(LPAREN);
              jj_consume_token(RPAREN);
args = SqlNodeList.EMPTY;
            } else {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case LPAREN:{
                args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUB_QUERY);
                break;
                }
              default:
                jj_la1[304] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
            }
          default:
            jj_la1[306] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jj_consume_token(RBRACE);
{if ("" != null) return new SqlJdbcFunctionCall(name).createCall(s.end(this),
            args.getList());}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("JdbcFunctionCall");
    }
}

/**
 * Parses a binary query operator like UNION.
 */
  final public SqlBinaryOperator BinaryQueryOperator() throws ParseException {
    trace_call("BinaryQueryOperator");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNION:{
        jj_consume_token(UNION);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL:{
          jj_consume_token(ALL);
{if ("" != null) return SqlStdOperatorTable.UNION_ALL;}
          break;
          }
        case DISTINCT:{
          jj_consume_token(DISTINCT);
{if ("" != null) return SqlStdOperatorTable.UNION;}
          break;
          }
        default:
          jj_la1[307] = jj_gen;
{if ("" != null) return SqlStdOperatorTable.UNION;}
        }
        break;
        }
      case INTERSECT:{
        jj_consume_token(INTERSECT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL:{
          jj_consume_token(ALL);
{if ("" != null) return SqlStdOperatorTable.INTERSECT_ALL;}
          break;
          }
        case DISTINCT:{
          jj_consume_token(DISTINCT);
{if ("" != null) return SqlStdOperatorTable.INTERSECT;}
          break;
          }
        default:
          jj_la1[308] = jj_gen;
{if ("" != null) return SqlStdOperatorTable.INTERSECT;}
        }
        break;
        }
      case EXCEPT:
      case SET_MINUS:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXCEPT:{
          jj_consume_token(EXCEPT);
          break;
          }
        case SET_MINUS:{
          jj_consume_token(SET_MINUS);
if (!this.conformance.isMinusAllowed()) {
                    {if (true) throw new ParseException(RESOURCE.minusNotAllowed().str());}
                }
          break;
          }
        default:
          jj_la1[309] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL:{
          jj_consume_token(ALL);
{if ("" != null) return SqlStdOperatorTable.EXCEPT_ALL;}
          break;
          }
        case DISTINCT:{
          jj_consume_token(DISTINCT);
{if ("" != null) return SqlStdOperatorTable.EXCEPT;}
          break;
          }
        default:
          jj_la1[310] = jj_gen;
{if ("" != null) return SqlStdOperatorTable.EXCEPT;}
        }
        break;
        }
      default:
        jj_la1[311] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BinaryQueryOperator");
    }
}

/**
 * Parses a binary multiset operator.
 */
  final public SqlBinaryOperator BinaryMultisetOperator() throws ParseException {
    trace_call("BinaryMultisetOperator");
    try {

      jj_consume_token(MULTISET);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNION:{
        jj_consume_token(UNION);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL:
        case DISTINCT:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ALL:{
            jj_consume_token(ALL);
            break;
            }
          case DISTINCT:{
            jj_consume_token(DISTINCT);
{if ("" != null) return SqlStdOperatorTable.MULTISET_UNION_DISTINCT;}
            break;
            }
          default:
            jj_la1[312] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[313] = jj_gen;
          ;
        }
{if ("" != null) return SqlStdOperatorTable.MULTISET_UNION;}
        break;
        }
      case INTERSECT:{
        jj_consume_token(INTERSECT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL:
        case DISTINCT:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ALL:{
            jj_consume_token(ALL);
            break;
            }
          case DISTINCT:{
            jj_consume_token(DISTINCT);
{if ("" != null) return SqlStdOperatorTable.MULTISET_INTERSECT_DISTINCT;}
            break;
            }
          default:
            jj_la1[314] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[315] = jj_gen;
          ;
        }
{if ("" != null) return SqlStdOperatorTable.MULTISET_INTERSECT;}
        break;
        }
      case EXCEPT:{
        jj_consume_token(EXCEPT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL:
        case DISTINCT:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ALL:{
            jj_consume_token(ALL);
            break;
            }
          case DISTINCT:{
            jj_consume_token(DISTINCT);
{if ("" != null) return SqlStdOperatorTable.MULTISET_EXCEPT_DISTINCT;}
            break;
            }
          default:
            jj_la1[316] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[317] = jj_gen;
          ;
        }
{if ("" != null) return SqlStdOperatorTable.MULTISET_EXCEPT;}
        break;
        }
      default:
        jj_la1[318] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BinaryMultisetOperator");
    }
}

/**
 * Parses a binary row operator like AND.
 */
  final public SqlBinaryOperator BinaryRowOperator() throws ParseException {
    trace_call("BinaryRowOperator");
    try {
SqlBinaryOperator op;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQ:{
        jj_consume_token(EQ);
{if ("" != null) return SqlStdOperatorTable.EQUALS;}
        break;
        }
      case GT:{
        jj_consume_token(GT);
{if ("" != null) return SqlStdOperatorTable.GREATER_THAN;}
        break;
        }
      case LT:{
        jj_consume_token(LT);
{if ("" != null) return SqlStdOperatorTable.LESS_THAN;}
        break;
        }
      case LE:{
        jj_consume_token(LE);
{if ("" != null) return SqlStdOperatorTable.LESS_THAN_OR_EQUAL;}
        break;
        }
      case GE:{
        jj_consume_token(GE);
{if ("" != null) return SqlStdOperatorTable.GREATER_THAN_OR_EQUAL;}
        break;
        }
      case NE:{
        jj_consume_token(NE);
{if ("" != null) return SqlStdOperatorTable.NOT_EQUALS;}
        break;
        }
      case NE2:{
        jj_consume_token(NE2);
if (!this.conformance.isBangEqualAllowed()) {
            {if (true) throw new ParseException(RESOURCE.bangEqualNotAllowed().str());}
        }
        {if ("" != null) return SqlStdOperatorTable.NOT_EQUALS;}
        break;
        }
      case PLUS:{
        jj_consume_token(PLUS);
{if ("" != null) return SqlStdOperatorTable.PLUS;}
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
{if ("" != null) return SqlStdOperatorTable.MINUS;}
        break;
        }
      case STAR:{
        jj_consume_token(STAR);
{if ("" != null) return SqlStdOperatorTable.MULTIPLY;}
        break;
        }
      case SLASH:{
        jj_consume_token(SLASH);
{if ("" != null) return SqlStdOperatorTable.DIVIDE;}
        break;
        }
      case PERCENT_REMAINDER:{
        jj_consume_token(PERCENT_REMAINDER);
if (!this.conformance.isPercentRemainderAllowed()) {
            {if (true) throw new ParseException(RESOURCE.percentRemainderNotAllowed().str());}
        }
        {if ("" != null) return SqlStdOperatorTable.PERCENT_REMAINDER;}
        break;
        }
      case CONCAT:{
        jj_consume_token(CONCAT);
{if ("" != null) return SqlStdOperatorTable.CONCAT;}
        break;
        }
      case AND:{
        jj_consume_token(AND);
{if ("" != null) return SqlStdOperatorTable.AND;}
        break;
        }
      case OR:{
        jj_consume_token(OR);
{if ("" != null) return SqlStdOperatorTable.OR;}
        break;
        }
      default:
        jj_la1[319] = jj_gen;
        if (jj_2_86(2)) {
          jj_consume_token(IS);
          jj_consume_token(DISTINCT);
          jj_consume_token(FROM);
{if ("" != null) return SqlStdOperatorTable.IS_DISTINCT_FROM;}
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case IS:{
            jj_consume_token(IS);
            jj_consume_token(NOT);
            jj_consume_token(DISTINCT);
            jj_consume_token(FROM);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_DISTINCT_FROM;}
            break;
            }
          case MEMBER:{
            jj_consume_token(MEMBER);
            jj_consume_token(OF);
{if ("" != null) return SqlStdOperatorTable.MEMBER_OF;}
            break;
            }
          default:
            jj_la1[320] = jj_gen;
            if (jj_2_87(2)) {
              jj_consume_token(SUBMULTISET);
              jj_consume_token(OF);
{if ("" != null) return SqlStdOperatorTable.SUBMULTISET_OF;}
            } else {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case NOT:{
                jj_consume_token(NOT);
                jj_consume_token(SUBMULTISET);
                jj_consume_token(OF);
{if ("" != null) return SqlStdOperatorTable.NOT_SUBMULTISET_OF;}
                break;
                }
              case CONTAINS:{
                jj_consume_token(CONTAINS);
{if ("" != null) return SqlStdOperatorTable.CONTAINS;}
                break;
                }
              case OVERLAPS:{
                jj_consume_token(OVERLAPS);
{if ("" != null) return SqlStdOperatorTable.OVERLAPS;}
                break;
                }
              case EQUALS:{
                jj_consume_token(EQUALS);
{if ("" != null) return SqlStdOperatorTable.PERIOD_EQUALS;}
                break;
                }
              case PRECEDES:{
                jj_consume_token(PRECEDES);
{if ("" != null) return SqlStdOperatorTable.PRECEDES;}
                break;
                }
              case SUCCEEDS:{
                jj_consume_token(SUCCEEDS);
{if ("" != null) return SqlStdOperatorTable.SUCCEEDS;}
                break;
                }
              default:
                jj_la1[321] = jj_gen;
                if (jj_2_88(2)) {
                  jj_consume_token(IMMEDIATELY);
                  jj_consume_token(PRECEDES);
{if ("" != null) return SqlStdOperatorTable.IMMEDIATELY_PRECEDES;}
                } else {
                  switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                  case IMMEDIATELY:{
                    jj_consume_token(IMMEDIATELY);
                    jj_consume_token(SUCCEEDS);
{if ("" != null) return SqlStdOperatorTable.IMMEDIATELY_SUCCEEDS;}
                    break;
                    }
                  case MULTISET:{
                    op = BinaryMultisetOperator();
{if ("" != null) return op;}
                    break;
                    }
                  default:
                    jj_la1[322] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                  }
                }
              }
            }
          }
        }
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("BinaryRowOperator");
    }
}

/**
 * Parses a prefix row operator like NOT.
 */
  final public SqlPrefixOperator PrefixRowOperator() throws ParseException {
    trace_call("PrefixRowOperator");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        jj_consume_token(PLUS);
{if ("" != null) return SqlStdOperatorTable.UNARY_PLUS;}
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
{if ("" != null) return SqlStdOperatorTable.UNARY_MINUS;}
        break;
        }
      case NOT:{
        jj_consume_token(NOT);
{if ("" != null) return SqlStdOperatorTable.NOT;}
        break;
        }
      case EXISTS:{
        jj_consume_token(EXISTS);
{if ("" != null) return SqlStdOperatorTable.EXISTS;}
        break;
        }
      default:
        jj_la1[323] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PrefixRowOperator");
    }
}

/**
 * Parses a postfix row operator like IS NOT NULL.
 */
  final public SqlPostfixOperator PostfixRowOperator() throws ParseException {
    trace_call("PostfixRowOperator");
    try {

      jj_consume_token(IS);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:{
        jj_consume_token(A);
        jj_consume_token(SET);
{if ("" != null) return SqlStdOperatorTable.IS_A_SET;}
        break;
        }
      case NOT:{
        jj_consume_token(NOT);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NULL:{
          jj_consume_token(NULL);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_NULL;}
          break;
          }
        case TRUE:{
          jj_consume_token(TRUE);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_TRUE;}
          break;
          }
        case FALSE:{
          jj_consume_token(FALSE);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_FALSE;}
          break;
          }
        case UNKNOWN:{
          jj_consume_token(UNKNOWN);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_UNKNOWN;}
          break;
          }
        case A:{
          jj_consume_token(A);
          jj_consume_token(SET);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_A_SET;}
          break;
          }
        case EMPTY:{
          jj_consume_token(EMPTY);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_EMPTY;}
          break;
          }
        default:
          jj_la1[324] = jj_gen;
          if (jj_2_89(2)) {
            jj_consume_token(JSON);
            jj_consume_token(VALUE);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_JSON_VALUE;}
          } else if (jj_2_90(2)) {
            jj_consume_token(JSON);
            jj_consume_token(OBJECT);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_JSON_OBJECT;}
          } else if (jj_2_91(2)) {
            jj_consume_token(JSON);
            jj_consume_token(ARRAY);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_JSON_ARRAY;}
          } else if (jj_2_92(2)) {
            jj_consume_token(JSON);
            jj_consume_token(SCALAR);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_JSON_SCALAR;}
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case JSON:{
              jj_consume_token(JSON);
{if ("" != null) return SqlStdOperatorTable.IS_NOT_JSON_VALUE;}
              break;
              }
            default:
              jj_la1[325] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
        }
      case EMPTY:
      case FALSE:
      case JSON:
      case NULL:
      case TRUE:
      case UNKNOWN:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NULL:{
          jj_consume_token(NULL);
{if ("" != null) return SqlStdOperatorTable.IS_NULL;}
          break;
          }
        case TRUE:{
          jj_consume_token(TRUE);
{if ("" != null) return SqlStdOperatorTable.IS_TRUE;}
          break;
          }
        case FALSE:{
          jj_consume_token(FALSE);
{if ("" != null) return SqlStdOperatorTable.IS_FALSE;}
          break;
          }
        case UNKNOWN:{
          jj_consume_token(UNKNOWN);
{if ("" != null) return SqlStdOperatorTable.IS_UNKNOWN;}
          break;
          }
        case EMPTY:{
          jj_consume_token(EMPTY);
{if ("" != null) return SqlStdOperatorTable.IS_EMPTY;}
          break;
          }
        default:
          jj_la1[326] = jj_gen;
          if (jj_2_93(2)) {
            jj_consume_token(JSON);
            jj_consume_token(VALUE);
{if ("" != null) return SqlStdOperatorTable.IS_JSON_VALUE;}
          } else if (jj_2_94(2)) {
            jj_consume_token(JSON);
            jj_consume_token(OBJECT);
{if ("" != null) return SqlStdOperatorTable.IS_JSON_OBJECT;}
          } else if (jj_2_95(2)) {
            jj_consume_token(JSON);
            jj_consume_token(ARRAY);
{if ("" != null) return SqlStdOperatorTable.IS_JSON_ARRAY;}
          } else if (jj_2_96(2)) {
            jj_consume_token(JSON);
            jj_consume_token(SCALAR);
{if ("" != null) return SqlStdOperatorTable.IS_JSON_SCALAR;}
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case JSON:{
              jj_consume_token(JSON);
{if ("" != null) return SqlStdOperatorTable.IS_JSON_VALUE;}
              break;
              }
            default:
              jj_la1[327] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
        }
      default:
        jj_la1[328] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("PostfixRowOperator");
    }
}

/**
 * Parses a non-reserved keyword for use as an identifier.
 *
 * <p>The method is broken up into several sub-methods; without this
 * decomposition, parsers such as Babel with more than ~1,000 non-reserved
 * keywords would generate such deeply nested 'if' statements that javac would
 * fail with a {@link StackOverflowError}.
 *
 * <p>The list is generated from the FMPP config data. To add or remove
 * keywords, modify config.fmpp. For parsers except Babel, make sure that
 * keywords are not reserved by the SQL standard.
 *
 * @see Glossary#SQL2003 SQL:2003 Part 2 Section 5.2
 */
  final public String NonReservedKeyWord() throws ParseException {
    trace_call("NonReservedKeyWord");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:
      case ACTION:
      case ADMIN:
      case APPLY:
      case ASSIGNMENT:
      case BEFORE:
      case C:
      case CATALOG_NAME:
      case CHARACTER_SET_CATALOG:
      case CHARACTERISTICS:
      case COBOL:
      case COLLATION_NAME:
      case COMMAND_FUNCTION:
      case CONDITION_NUMBER:
      case CONNECTION_NAME:
      case CONSTRAINT_SCHEMA:
      case CONTINUE:
      case DATABASE:
      case DECADE:
      case DEFERRED:
      case DEGREE:
      case DESC:
      case DIAGNOSTICS:
      case DOW:
      case DYNAMIC_FUNCTION_CODE:
      case ERROR:
      case EXCLUDING:
      case FOLLOWING:
      case FOUND:
      case GENERAL:
      case GO:
      case HIERARCHY:
      case IMPLEMENTATION:
      case INITIALLY:
      case INSTANTIABLE:
      case ISOYEAR:
      case JSON:
      case JSON_PRETTY:
      case KEY_MEMBER:
      case LAST:
      case LIBRARY:
      case MAP:
      case MESSAGE_TEXT:
      case MICROSECOND:
      case MINVALUE:
      case NAME:
      case NESTING:
      case NULLS:
      case OCTETS:
      case ORDERING:
      case OUTPUT:
      case PARAMETER_MODE:
      case PARAMETER_SPECIFIC_CATALOG:
      case PARTIAL:
      case PASSTHROUGH:
      case PLACING:
      case PRECEDING:
      case PRIVILEGES:
      case READ:
      case REPLACE:
      case RETURNED_CARDINALITY:
      case RETURNED_SQLSTATE:
      case ROUTINE:
      case ROUTINE_SCHEMA:
      case SCALE:
      case SCOPE_CATALOGS:
      case SECTION:
      case SEQUENCE:
      case SERVER_NAME:
      case SIMPLE:
      case SPACE:
      case SQL_BINARY:
      case SQL_BOOLEAN:
      case SQL_DATE:
      case SQL_FLOAT:
      case SQL_INTERVAL_DAY_TO_HOUR:
      case SQL_INTERVAL_HOUR:
      case SQL_INTERVAL_MINUTE:
      case SQL_INTERVAL_SECOND:
      case SQL_LONGVARBINARY:
      case SQL_NCHAR:
      case SQL_NVARCHAR:
      case SQL_TIME:
      case SQL_TSI_DAY:
      case SQL_TSI_MICROSECOND:
      case SQL_TSI_QUARTER:
      case SQL_TSI_YEAR:
      case STATE:
      case STYLE:
      case TABLE_NAME:
      case TIMESTAMPADD:
      case TRANSACTION:
      case TRANSACTIONS_ROLLED_BACK:
      case TRIGGER_CATALOG:
      case TYPE:
      case UNCONDITIONAL:
      case USAGE:
      case USER_DEFINED_TYPE_NAME:
      case UTF16:
      case VIEW:
      case WORK:
      case ZONE:{
        NonReservedKeyWord0of3();
        break;
        }
      case ABSENT:
      case ADA:
      case AFTER:
      case ASC:
      case ATTRIBUTE:
      case BERNOULLI:
      case CASCADE:
      case CENTURY:
      case CHARACTER_SET_NAME:
      case CHARACTERS:
      case COLLATION:
      case COLLATION_SCHEMA:
      case COMMAND_FUNCTION_CODE:
      case CONDITIONAL:
      case CONSTRAINT_CATALOG:
      case CONSTRAINTS:
      case CURSOR_NAME:
      case DATETIME_INTERVAL_CODE:
      case DEFAULTS:
      case DEFINED:
      case DEPTH:
      case DESCRIPTION:
      case DISPATCH:
      case DOY:
      case ENCODING:
      case EXCEPTION:
      case FINAL:
      case FORMAT:
      case FRAC_SECOND:
      case GENERATED:
      case GOTO:
      case IMMEDIATE:
      case INCLUDING:
      case INPUT:
      case INVOKER:
      case ISOLATION:
      case JSON_TYPE:
      case K:
      case KEY_TYPE:
      case LENGTH:
      case LOCATOR:
      case MATCHED:
      case MESSAGE_LENGTH:
      case MILLISECOND:
      case MORE_:
      case NAMES:
      case NORMALIZED:
      case NUMBER:
      case OPTION:
      case ORDINALITY:
      case OVERRIDING:
      case PARAMETER_NAME:
      case PARAMETER_SPECIFIC_NAME:
      case PASCAL:
      case PAST:
      case PLAN:
      case PRESERVE:
      case PUBLIC:
      case RELATIVE:
      case RESTART:
      case RETURNED_LENGTH:
      case RETURNING:
      case ROUTINE_CATALOG:
      case ROW_COUNT:
      case SCHEMA:
      case SCOPE_NAME:
      case SECURITY:
      case SERIALIZABLE:
      case SESSION:
      case SIZE:
      case SPECIFIC_NAME:
      case SQL_BIT:
      case SQL_CHAR:
      case SQL_DECIMAL:
      case SQL_INTEGER:
      case SQL_INTERVAL_DAY_TO_MINUTE:
      case SQL_INTERVAL_HOUR_TO_MINUTE:
      case SQL_INTERVAL_MINUTE_TO_SECOND:
      case SQL_INTERVAL_YEAR:
      case SQL_LONGVARNCHAR:
      case SQL_NCLOB:
      case SQL_REAL:
      case SQL_TIMESTAMP:
      case SQL_TSI_FRAC_SECOND:
      case SQL_TSI_MINUTE:
      case SQL_TSI_SECOND:
      case SQL_VARBINARY:
      case STATEMENT:
      case SUBCLASS_ORIGIN:
      case TEMPORARY:
      case TIMESTAMPDIFF:
      case TRANSACTIONS_ACTIVE:
      case TRANSFORM:
      case TRIGGER_NAME:
      case UNBOUNDED:
      case UNDER:
      case USER_DEFINED_TYPE_CATALOG:
      case USER_DEFINED_TYPE_SCHEMA:
      case UTF32:
      case WEEK:
      case WRITE:{
        NonReservedKeyWord1of3();
        break;
        }
      case ABSOLUTE:
      case ADD:
      case ALWAYS:
      case ASSERTION:
      case ATTRIBUTES:
      case BREADTH:
      case CATALOG:
      case CHAIN:
      case CHARACTER_SET_SCHEMA:
      case CLASS_ORIGIN:
      case COLLATION_CATALOG:
      case COLUMN_NAME:
      case COMMITTED:
      case CONNECTION:
      case CONSTRAINT_NAME:
      case CONSTRUCTOR:
      case DATA:
      case DATETIME_INTERVAL_PRECISION:
      case DEFERRABLE:
      case DEFINER:
      case DERIVED:
      case DESCRIPTOR:
      case DOMAIN:
      case DYNAMIC_FUNCTION:
      case EPOCH:
      case EXCLUDE:
      case FIRST:
      case FORTRAN:
      case G:
      case GEOMETRY:
      case GRANTED:
      case IMMEDIATELY:
      case INCREMENT:
      case INSTANCE:
      case ISODOW:
      case JAVA:
      case JSON_DEPTH:
      case KEY:
      case LABEL:
      case LEVEL:
      case M:
      case MAXVALUE:
      case MESSAGE_OCTET_LENGTH:
      case MILLENNIUM:
      case MUMPS:
      case NANOSECOND:
      case NULLABLE:
      case OBJECT:
      case OPTIONS:
      case OTHERS:
      case PAD:
      case PARAMETER_ORDINAL_POSITION:
      case PARAMETER_SPECIFIC_SCHEMA:
      case PASSING:
      case PATH:
      case PLI:
      case PRIOR:
      case QUARTER:
      case REPEATABLE:
      case RESTRICT:
      case RETURNED_OCTET_LENGTH:
      case ROLE:
      case ROUTINE_NAME:
      case SCALAR:
      case SCHEMA_NAME:
      case SCOPE_SCHEMA:
      case SELF:
      case SERVER:
      case SETS:
      case SOURCE:
      case SQL_BIGINT:
      case SQL_BLOB:
      case SQL_CLOB:
      case SQL_DOUBLE:
      case SQL_INTERVAL_DAY:
      case SQL_INTERVAL_DAY_TO_SECOND:
      case SQL_INTERVAL_HOUR_TO_SECOND:
      case SQL_INTERVAL_MONTH:
      case SQL_INTERVAL_YEAR_TO_MONTH:
      case SQL_LONGVARCHAR:
      case SQL_NUMERIC:
      case SQL_SMALLINT:
      case SQL_TINYINT:
      case SQL_TSI_HOUR:
      case SQL_TSI_MONTH:
      case SQL_TSI_WEEK:
      case SQL_VARCHAR:
      case STRUCTURE:
      case SUBSTITUTE:
      case TIES:
      case TOP_LEVEL_COUNT:
      case TRANSACTIONS_COMMITTED:
      case TRANSFORMS:
      case TRIGGER_SCHEMA:
      case UNCOMMITTED:
      case UNNAMED:
      case USER_DEFINED_TYPE_CODE:
      case UTF8:
      case VERSION:
      case WRAPPER:
      case XML:{
        NonReservedKeyWord2of3();
        break;
        }
      default:
        jj_la1[329] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
{if ("" != null) return unquotedIdentifier();}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("NonReservedKeyWord");
    }
}

/** @see #NonReservedKeyWord */
  final public void NonReservedKeyWord0of3() throws ParseException {
    trace_call("NonReservedKeyWord0of3");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case A:{
        jj_consume_token(A);
        break;
        }
      case ACTION:{
        jj_consume_token(ACTION);
        break;
        }
      case ADMIN:{
        jj_consume_token(ADMIN);
        break;
        }
      case APPLY:{
        jj_consume_token(APPLY);
        break;
        }
      case ASSIGNMENT:{
        jj_consume_token(ASSIGNMENT);
        break;
        }
      case BEFORE:{
        jj_consume_token(BEFORE);
        break;
        }
      case C:{
        jj_consume_token(C);
        break;
        }
      case CATALOG_NAME:{
        jj_consume_token(CATALOG_NAME);
        break;
        }
      case CHARACTER_SET_CATALOG:{
        jj_consume_token(CHARACTER_SET_CATALOG);
        break;
        }
      case CHARACTERISTICS:{
        jj_consume_token(CHARACTERISTICS);
        break;
        }
      case COBOL:{
        jj_consume_token(COBOL);
        break;
        }
      case COLLATION_NAME:{
        jj_consume_token(COLLATION_NAME);
        break;
        }
      case COMMAND_FUNCTION:{
        jj_consume_token(COMMAND_FUNCTION);
        break;
        }
      case CONDITION_NUMBER:{
        jj_consume_token(CONDITION_NUMBER);
        break;
        }
      case CONNECTION_NAME:{
        jj_consume_token(CONNECTION_NAME);
        break;
        }
      case CONSTRAINT_SCHEMA:{
        jj_consume_token(CONSTRAINT_SCHEMA);
        break;
        }
      case CONTINUE:{
        jj_consume_token(CONTINUE);
        break;
        }
      case DATABASE:{
        jj_consume_token(DATABASE);
        break;
        }
      case DECADE:{
        jj_consume_token(DECADE);
        break;
        }
      case DEFERRED:{
        jj_consume_token(DEFERRED);
        break;
        }
      case DEGREE:{
        jj_consume_token(DEGREE);
        break;
        }
      case DESC:{
        jj_consume_token(DESC);
        break;
        }
      case DIAGNOSTICS:{
        jj_consume_token(DIAGNOSTICS);
        break;
        }
      case DOW:{
        jj_consume_token(DOW);
        break;
        }
      case DYNAMIC_FUNCTION_CODE:{
        jj_consume_token(DYNAMIC_FUNCTION_CODE);
        break;
        }
      case ERROR:{
        jj_consume_token(ERROR);
        break;
        }
      case EXCLUDING:{
        jj_consume_token(EXCLUDING);
        break;
        }
      case FOLLOWING:{
        jj_consume_token(FOLLOWING);
        break;
        }
      case FOUND:{
        jj_consume_token(FOUND);
        break;
        }
      case GENERAL:{
        jj_consume_token(GENERAL);
        break;
        }
      case GO:{
        jj_consume_token(GO);
        break;
        }
      case HIERARCHY:{
        jj_consume_token(HIERARCHY);
        break;
        }
      case IMPLEMENTATION:{
        jj_consume_token(IMPLEMENTATION);
        break;
        }
      case INITIALLY:{
        jj_consume_token(INITIALLY);
        break;
        }
      case INSTANTIABLE:{
        jj_consume_token(INSTANTIABLE);
        break;
        }
      case ISOYEAR:{
        jj_consume_token(ISOYEAR);
        break;
        }
      case JSON:{
        jj_consume_token(JSON);
        break;
        }
      case JSON_PRETTY:{
        jj_consume_token(JSON_PRETTY);
        break;
        }
      case KEY_MEMBER:{
        jj_consume_token(KEY_MEMBER);
        break;
        }
      case LAST:{
        jj_consume_token(LAST);
        break;
        }
      case LIBRARY:{
        jj_consume_token(LIBRARY);
        break;
        }
      case MAP:{
        jj_consume_token(MAP);
        break;
        }
      case MICROSECOND:{
        jj_consume_token(MICROSECOND);
        break;
        }
      case MESSAGE_TEXT:{
        jj_consume_token(MESSAGE_TEXT);
        break;
        }
      case MINVALUE:{
        jj_consume_token(MINVALUE);
        break;
        }
      case NAME:{
        jj_consume_token(NAME);
        break;
        }
      case NESTING:{
        jj_consume_token(NESTING);
        break;
        }
      case NULLS:{
        jj_consume_token(NULLS);
        break;
        }
      case OCTETS:{
        jj_consume_token(OCTETS);
        break;
        }
      case ORDERING:{
        jj_consume_token(ORDERING);
        break;
        }
      case OUTPUT:{
        jj_consume_token(OUTPUT);
        break;
        }
      case PARAMETER_MODE:{
        jj_consume_token(PARAMETER_MODE);
        break;
        }
      case PARAMETER_SPECIFIC_CATALOG:{
        jj_consume_token(PARAMETER_SPECIFIC_CATALOG);
        break;
        }
      case PARTIAL:{
        jj_consume_token(PARTIAL);
        break;
        }
      case PASSTHROUGH:{
        jj_consume_token(PASSTHROUGH);
        break;
        }
      case PLACING:{
        jj_consume_token(PLACING);
        break;
        }
      case PRECEDING:{
        jj_consume_token(PRECEDING);
        break;
        }
      case PRIVILEGES:{
        jj_consume_token(PRIVILEGES);
        break;
        }
      case READ:{
        jj_consume_token(READ);
        break;
        }
      case REPLACE:{
        jj_consume_token(REPLACE);
        break;
        }
      case RETURNED_CARDINALITY:{
        jj_consume_token(RETURNED_CARDINALITY);
        break;
        }
      case RETURNED_SQLSTATE:{
        jj_consume_token(RETURNED_SQLSTATE);
        break;
        }
      case ROUTINE:{
        jj_consume_token(ROUTINE);
        break;
        }
      case ROUTINE_SCHEMA:{
        jj_consume_token(ROUTINE_SCHEMA);
        break;
        }
      case SCALE:{
        jj_consume_token(SCALE);
        break;
        }
      case SCOPE_CATALOGS:{
        jj_consume_token(SCOPE_CATALOGS);
        break;
        }
      case SECTION:{
        jj_consume_token(SECTION);
        break;
        }
      case SEQUENCE:{
        jj_consume_token(SEQUENCE);
        break;
        }
      case SERVER_NAME:{
        jj_consume_token(SERVER_NAME);
        break;
        }
      case SIMPLE:{
        jj_consume_token(SIMPLE);
        break;
        }
      case SPACE:{
        jj_consume_token(SPACE);
        break;
        }
      case SQL_BINARY:{
        jj_consume_token(SQL_BINARY);
        break;
        }
      case SQL_BOOLEAN:{
        jj_consume_token(SQL_BOOLEAN);
        break;
        }
      case SQL_DATE:{
        jj_consume_token(SQL_DATE);
        break;
        }
      case SQL_FLOAT:{
        jj_consume_token(SQL_FLOAT);
        break;
        }
      case SQL_INTERVAL_DAY_TO_HOUR:{
        jj_consume_token(SQL_INTERVAL_DAY_TO_HOUR);
        break;
        }
      case SQL_INTERVAL_HOUR:{
        jj_consume_token(SQL_INTERVAL_HOUR);
        break;
        }
      case SQL_INTERVAL_MINUTE:{
        jj_consume_token(SQL_INTERVAL_MINUTE);
        break;
        }
      case SQL_INTERVAL_SECOND:{
        jj_consume_token(SQL_INTERVAL_SECOND);
        break;
        }
      case SQL_LONGVARBINARY:{
        jj_consume_token(SQL_LONGVARBINARY);
        break;
        }
      case SQL_NCHAR:{
        jj_consume_token(SQL_NCHAR);
        break;
        }
      case SQL_NVARCHAR:{
        jj_consume_token(SQL_NVARCHAR);
        break;
        }
      case SQL_TIME:{
        jj_consume_token(SQL_TIME);
        break;
        }
      case SQL_TSI_DAY:{
        jj_consume_token(SQL_TSI_DAY);
        break;
        }
      case SQL_TSI_MICROSECOND:{
        jj_consume_token(SQL_TSI_MICROSECOND);
        break;
        }
      case SQL_TSI_QUARTER:{
        jj_consume_token(SQL_TSI_QUARTER);
        break;
        }
      case SQL_TSI_YEAR:{
        jj_consume_token(SQL_TSI_YEAR);
        break;
        }
      case STATE:{
        jj_consume_token(STATE);
        break;
        }
      case STYLE:{
        jj_consume_token(STYLE);
        break;
        }
      case TABLE_NAME:{
        jj_consume_token(TABLE_NAME);
        break;
        }
      case TIMESTAMPADD:{
        jj_consume_token(TIMESTAMPADD);
        break;
        }
      case TRANSACTION:{
        jj_consume_token(TRANSACTION);
        break;
        }
      case TRANSACTIONS_ROLLED_BACK:{
        jj_consume_token(TRANSACTIONS_ROLLED_BACK);
        break;
        }
      case TRIGGER_CATALOG:{
        jj_consume_token(TRIGGER_CATALOG);
        break;
        }
      case TYPE:{
        jj_consume_token(TYPE);
        break;
        }
      case UNCONDITIONAL:{
        jj_consume_token(UNCONDITIONAL);
        break;
        }
      case USAGE:{
        jj_consume_token(USAGE);
        break;
        }
      case USER_DEFINED_TYPE_NAME:{
        jj_consume_token(USER_DEFINED_TYPE_NAME);
        break;
        }
      case UTF16:{
        jj_consume_token(UTF16);
        break;
        }
      case VIEW:{
        jj_consume_token(VIEW);
        break;
        }
      case WORK:{
        jj_consume_token(WORK);
        break;
        }
      case ZONE:{
        jj_consume_token(ZONE);
        break;
        }
      default:
        jj_la1[330] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("NonReservedKeyWord0of3");
    }
}

/** @see #NonReservedKeyWord */
  final public void NonReservedKeyWord1of3() throws ParseException {
    trace_call("NonReservedKeyWord1of3");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSENT:{
        jj_consume_token(ABSENT);
        break;
        }
      case ADA:{
        jj_consume_token(ADA);
        break;
        }
      case AFTER:{
        jj_consume_token(AFTER);
        break;
        }
      case ASC:{
        jj_consume_token(ASC);
        break;
        }
      case ATTRIBUTE:{
        jj_consume_token(ATTRIBUTE);
        break;
        }
      case BERNOULLI:{
        jj_consume_token(BERNOULLI);
        break;
        }
      case CASCADE:{
        jj_consume_token(CASCADE);
        break;
        }
      case CENTURY:{
        jj_consume_token(CENTURY);
        break;
        }
      case CHARACTER_SET_NAME:{
        jj_consume_token(CHARACTER_SET_NAME);
        break;
        }
      case CHARACTERS:{
        jj_consume_token(CHARACTERS);
        break;
        }
      case COLLATION:{
        jj_consume_token(COLLATION);
        break;
        }
      case COLLATION_SCHEMA:{
        jj_consume_token(COLLATION_SCHEMA);
        break;
        }
      case COMMAND_FUNCTION_CODE:{
        jj_consume_token(COMMAND_FUNCTION_CODE);
        break;
        }
      case CONDITIONAL:{
        jj_consume_token(CONDITIONAL);
        break;
        }
      case CONSTRAINT_CATALOG:{
        jj_consume_token(CONSTRAINT_CATALOG);
        break;
        }
      case CONSTRAINTS:{
        jj_consume_token(CONSTRAINTS);
        break;
        }
      case CURSOR_NAME:{
        jj_consume_token(CURSOR_NAME);
        break;
        }
      case DATETIME_INTERVAL_CODE:{
        jj_consume_token(DATETIME_INTERVAL_CODE);
        break;
        }
      case DEFAULTS:{
        jj_consume_token(DEFAULTS);
        break;
        }
      case DEFINED:{
        jj_consume_token(DEFINED);
        break;
        }
      case DEPTH:{
        jj_consume_token(DEPTH);
        break;
        }
      case DESCRIPTION:{
        jj_consume_token(DESCRIPTION);
        break;
        }
      case DISPATCH:{
        jj_consume_token(DISPATCH);
        break;
        }
      case DOY:{
        jj_consume_token(DOY);
        break;
        }
      case ENCODING:{
        jj_consume_token(ENCODING);
        break;
        }
      case EXCEPTION:{
        jj_consume_token(EXCEPTION);
        break;
        }
      case FINAL:{
        jj_consume_token(FINAL);
        break;
        }
      case FORMAT:{
        jj_consume_token(FORMAT);
        break;
        }
      case FRAC_SECOND:{
        jj_consume_token(FRAC_SECOND);
        break;
        }
      case GENERATED:{
        jj_consume_token(GENERATED);
        break;
        }
      case GOTO:{
        jj_consume_token(GOTO);
        break;
        }
      case IMMEDIATE:{
        jj_consume_token(IMMEDIATE);
        break;
        }
      case INCLUDING:{
        jj_consume_token(INCLUDING);
        break;
        }
      case INPUT:{
        jj_consume_token(INPUT);
        break;
        }
      case INVOKER:{
        jj_consume_token(INVOKER);
        break;
        }
      case ISOLATION:{
        jj_consume_token(ISOLATION);
        break;
        }
      case JSON_TYPE:{
        jj_consume_token(JSON_TYPE);
        break;
        }
      case K:{
        jj_consume_token(K);
        break;
        }
      case KEY_TYPE:{
        jj_consume_token(KEY_TYPE);
        break;
        }
      case LENGTH:{
        jj_consume_token(LENGTH);
        break;
        }
      case LOCATOR:{
        jj_consume_token(LOCATOR);
        break;
        }
      case MATCHED:{
        jj_consume_token(MATCHED);
        break;
        }
      case MESSAGE_LENGTH:{
        jj_consume_token(MESSAGE_LENGTH);
        break;
        }
      case MILLISECOND:{
        jj_consume_token(MILLISECOND);
        break;
        }
      case MORE_:{
        jj_consume_token(MORE_);
        break;
        }
      case NAMES:{
        jj_consume_token(NAMES);
        break;
        }
      case NORMALIZED:{
        jj_consume_token(NORMALIZED);
        break;
        }
      case NUMBER:{
        jj_consume_token(NUMBER);
        break;
        }
      case OPTION:{
        jj_consume_token(OPTION);
        break;
        }
      case ORDINALITY:{
        jj_consume_token(ORDINALITY);
        break;
        }
      case OVERRIDING:{
        jj_consume_token(OVERRIDING);
        break;
        }
      case PARAMETER_NAME:{
        jj_consume_token(PARAMETER_NAME);
        break;
        }
      case PARAMETER_SPECIFIC_NAME:{
        jj_consume_token(PARAMETER_SPECIFIC_NAME);
        break;
        }
      case PASCAL:{
        jj_consume_token(PASCAL);
        break;
        }
      case PAST:{
        jj_consume_token(PAST);
        break;
        }
      case PLAN:{
        jj_consume_token(PLAN);
        break;
        }
      case PRESERVE:{
        jj_consume_token(PRESERVE);
        break;
        }
      case PUBLIC:{
        jj_consume_token(PUBLIC);
        break;
        }
      case RELATIVE:{
        jj_consume_token(RELATIVE);
        break;
        }
      case RESTART:{
        jj_consume_token(RESTART);
        break;
        }
      case RETURNED_LENGTH:{
        jj_consume_token(RETURNED_LENGTH);
        break;
        }
      case RETURNING:{
        jj_consume_token(RETURNING);
        break;
        }
      case ROUTINE_CATALOG:{
        jj_consume_token(ROUTINE_CATALOG);
        break;
        }
      case ROW_COUNT:{
        jj_consume_token(ROW_COUNT);
        break;
        }
      case SCHEMA:{
        jj_consume_token(SCHEMA);
        break;
        }
      case SCOPE_NAME:{
        jj_consume_token(SCOPE_NAME);
        break;
        }
      case SECURITY:{
        jj_consume_token(SECURITY);
        break;
        }
      case SERIALIZABLE:{
        jj_consume_token(SERIALIZABLE);
        break;
        }
      case SESSION:{
        jj_consume_token(SESSION);
        break;
        }
      case SIZE:{
        jj_consume_token(SIZE);
        break;
        }
      case SPECIFIC_NAME:{
        jj_consume_token(SPECIFIC_NAME);
        break;
        }
      case SQL_BIT:{
        jj_consume_token(SQL_BIT);
        break;
        }
      case SQL_CHAR:{
        jj_consume_token(SQL_CHAR);
        break;
        }
      case SQL_DECIMAL:{
        jj_consume_token(SQL_DECIMAL);
        break;
        }
      case SQL_INTEGER:{
        jj_consume_token(SQL_INTEGER);
        break;
        }
      case SQL_INTERVAL_DAY_TO_MINUTE:{
        jj_consume_token(SQL_INTERVAL_DAY_TO_MINUTE);
        break;
        }
      case SQL_INTERVAL_HOUR_TO_MINUTE:{
        jj_consume_token(SQL_INTERVAL_HOUR_TO_MINUTE);
        break;
        }
      case SQL_INTERVAL_MINUTE_TO_SECOND:{
        jj_consume_token(SQL_INTERVAL_MINUTE_TO_SECOND);
        break;
        }
      case SQL_INTERVAL_YEAR:{
        jj_consume_token(SQL_INTERVAL_YEAR);
        break;
        }
      case SQL_LONGVARNCHAR:{
        jj_consume_token(SQL_LONGVARNCHAR);
        break;
        }
      case SQL_NCLOB:{
        jj_consume_token(SQL_NCLOB);
        break;
        }
      case SQL_REAL:{
        jj_consume_token(SQL_REAL);
        break;
        }
      case SQL_TIMESTAMP:{
        jj_consume_token(SQL_TIMESTAMP);
        break;
        }
      case SQL_TSI_FRAC_SECOND:{
        jj_consume_token(SQL_TSI_FRAC_SECOND);
        break;
        }
      case SQL_TSI_MINUTE:{
        jj_consume_token(SQL_TSI_MINUTE);
        break;
        }
      case SQL_TSI_SECOND:{
        jj_consume_token(SQL_TSI_SECOND);
        break;
        }
      case SQL_VARBINARY:{
        jj_consume_token(SQL_VARBINARY);
        break;
        }
      case STATEMENT:{
        jj_consume_token(STATEMENT);
        break;
        }
      case SUBCLASS_ORIGIN:{
        jj_consume_token(SUBCLASS_ORIGIN);
        break;
        }
      case TEMPORARY:{
        jj_consume_token(TEMPORARY);
        break;
        }
      case TIMESTAMPDIFF:{
        jj_consume_token(TIMESTAMPDIFF);
        break;
        }
      case TRANSACTIONS_ACTIVE:{
        jj_consume_token(TRANSACTIONS_ACTIVE);
        break;
        }
      case TRANSFORM:{
        jj_consume_token(TRANSFORM);
        break;
        }
      case TRIGGER_NAME:{
        jj_consume_token(TRIGGER_NAME);
        break;
        }
      case UNBOUNDED:{
        jj_consume_token(UNBOUNDED);
        break;
        }
      case UNDER:{
        jj_consume_token(UNDER);
        break;
        }
      case USER_DEFINED_TYPE_CATALOG:{
        jj_consume_token(USER_DEFINED_TYPE_CATALOG);
        break;
        }
      case USER_DEFINED_TYPE_SCHEMA:{
        jj_consume_token(USER_DEFINED_TYPE_SCHEMA);
        break;
        }
      case UTF32:{
        jj_consume_token(UTF32);
        break;
        }
      case WEEK:{
        jj_consume_token(WEEK);
        break;
        }
      case WRITE:{
        jj_consume_token(WRITE);
        break;
        }
      default:
        jj_la1[331] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("NonReservedKeyWord1of3");
    }
}

/** @see #NonReservedKeyWord */
  final public void NonReservedKeyWord2of3() throws ParseException {
    trace_call("NonReservedKeyWord2of3");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSOLUTE:{
        jj_consume_token(ABSOLUTE);
        break;
        }
      case ADD:{
        jj_consume_token(ADD);
        break;
        }
      case ALWAYS:{
        jj_consume_token(ALWAYS);
        break;
        }
      case ASSERTION:{
        jj_consume_token(ASSERTION);
        break;
        }
      case ATTRIBUTES:{
        jj_consume_token(ATTRIBUTES);
        break;
        }
      case BREADTH:{
        jj_consume_token(BREADTH);
        break;
        }
      case CATALOG:{
        jj_consume_token(CATALOG);
        break;
        }
      case CHAIN:{
        jj_consume_token(CHAIN);
        break;
        }
      case CHARACTER_SET_SCHEMA:{
        jj_consume_token(CHARACTER_SET_SCHEMA);
        break;
        }
      case CLASS_ORIGIN:{
        jj_consume_token(CLASS_ORIGIN);
        break;
        }
      case COLLATION_CATALOG:{
        jj_consume_token(COLLATION_CATALOG);
        break;
        }
      case COLUMN_NAME:{
        jj_consume_token(COLUMN_NAME);
        break;
        }
      case COMMITTED:{
        jj_consume_token(COMMITTED);
        break;
        }
      case CONNECTION:{
        jj_consume_token(CONNECTION);
        break;
        }
      case CONSTRAINT_NAME:{
        jj_consume_token(CONSTRAINT_NAME);
        break;
        }
      case CONSTRUCTOR:{
        jj_consume_token(CONSTRUCTOR);
        break;
        }
      case DATA:{
        jj_consume_token(DATA);
        break;
        }
      case DATETIME_INTERVAL_PRECISION:{
        jj_consume_token(DATETIME_INTERVAL_PRECISION);
        break;
        }
      case DEFERRABLE:{
        jj_consume_token(DEFERRABLE);
        break;
        }
      case DEFINER:{
        jj_consume_token(DEFINER);
        break;
        }
      case DERIVED:{
        jj_consume_token(DERIVED);
        break;
        }
      case DESCRIPTOR:{
        jj_consume_token(DESCRIPTOR);
        break;
        }
      case DOMAIN:{
        jj_consume_token(DOMAIN);
        break;
        }
      case DYNAMIC_FUNCTION:{
        jj_consume_token(DYNAMIC_FUNCTION);
        break;
        }
      case EPOCH:{
        jj_consume_token(EPOCH);
        break;
        }
      case EXCLUDE:{
        jj_consume_token(EXCLUDE);
        break;
        }
      case FIRST:{
        jj_consume_token(FIRST);
        break;
        }
      case FORTRAN:{
        jj_consume_token(FORTRAN);
        break;
        }
      case G:{
        jj_consume_token(G);
        break;
        }
      case GEOMETRY:{
        jj_consume_token(GEOMETRY);
        break;
        }
      case GRANTED:{
        jj_consume_token(GRANTED);
        break;
        }
      case IMMEDIATELY:{
        jj_consume_token(IMMEDIATELY);
        break;
        }
      case INCREMENT:{
        jj_consume_token(INCREMENT);
        break;
        }
      case INSTANCE:{
        jj_consume_token(INSTANCE);
        break;
        }
      case ISODOW:{
        jj_consume_token(ISODOW);
        break;
        }
      case JAVA:{
        jj_consume_token(JAVA);
        break;
        }
      case JSON_DEPTH:{
        jj_consume_token(JSON_DEPTH);
        break;
        }
      case KEY:{
        jj_consume_token(KEY);
        break;
        }
      case LABEL:{
        jj_consume_token(LABEL);
        break;
        }
      case LEVEL:{
        jj_consume_token(LEVEL);
        break;
        }
      case M:{
        jj_consume_token(M);
        break;
        }
      case MAXVALUE:{
        jj_consume_token(MAXVALUE);
        break;
        }
      case MESSAGE_OCTET_LENGTH:{
        jj_consume_token(MESSAGE_OCTET_LENGTH);
        break;
        }
      case MILLENNIUM:{
        jj_consume_token(MILLENNIUM);
        break;
        }
      case MUMPS:{
        jj_consume_token(MUMPS);
        break;
        }
      case NANOSECOND:{
        jj_consume_token(NANOSECOND);
        break;
        }
      case NULLABLE:{
        jj_consume_token(NULLABLE);
        break;
        }
      case OBJECT:{
        jj_consume_token(OBJECT);
        break;
        }
      case OPTIONS:{
        jj_consume_token(OPTIONS);
        break;
        }
      case OTHERS:{
        jj_consume_token(OTHERS);
        break;
        }
      case PAD:{
        jj_consume_token(PAD);
        break;
        }
      case PARAMETER_ORDINAL_POSITION:{
        jj_consume_token(PARAMETER_ORDINAL_POSITION);
        break;
        }
      case PARAMETER_SPECIFIC_SCHEMA:{
        jj_consume_token(PARAMETER_SPECIFIC_SCHEMA);
        break;
        }
      case PASSING:{
        jj_consume_token(PASSING);
        break;
        }
      case PATH:{
        jj_consume_token(PATH);
        break;
        }
      case PLI:{
        jj_consume_token(PLI);
        break;
        }
      case PRIOR:{
        jj_consume_token(PRIOR);
        break;
        }
      case QUARTER:{
        jj_consume_token(QUARTER);
        break;
        }
      case REPEATABLE:{
        jj_consume_token(REPEATABLE);
        break;
        }
      case RESTRICT:{
        jj_consume_token(RESTRICT);
        break;
        }
      case RETURNED_OCTET_LENGTH:{
        jj_consume_token(RETURNED_OCTET_LENGTH);
        break;
        }
      case ROLE:{
        jj_consume_token(ROLE);
        break;
        }
      case ROUTINE_NAME:{
        jj_consume_token(ROUTINE_NAME);
        break;
        }
      case SCALAR:{
        jj_consume_token(SCALAR);
        break;
        }
      case SCHEMA_NAME:{
        jj_consume_token(SCHEMA_NAME);
        break;
        }
      case SCOPE_SCHEMA:{
        jj_consume_token(SCOPE_SCHEMA);
        break;
        }
      case SELF:{
        jj_consume_token(SELF);
        break;
        }
      case SERVER:{
        jj_consume_token(SERVER);
        break;
        }
      case SETS:{
        jj_consume_token(SETS);
        break;
        }
      case SOURCE:{
        jj_consume_token(SOURCE);
        break;
        }
      case SQL_BIGINT:{
        jj_consume_token(SQL_BIGINT);
        break;
        }
      case SQL_BLOB:{
        jj_consume_token(SQL_BLOB);
        break;
        }
      case SQL_CLOB:{
        jj_consume_token(SQL_CLOB);
        break;
        }
      case SQL_DOUBLE:{
        jj_consume_token(SQL_DOUBLE);
        break;
        }
      case SQL_INTERVAL_DAY:{
        jj_consume_token(SQL_INTERVAL_DAY);
        break;
        }
      case SQL_INTERVAL_DAY_TO_SECOND:{
        jj_consume_token(SQL_INTERVAL_DAY_TO_SECOND);
        break;
        }
      case SQL_INTERVAL_HOUR_TO_SECOND:{
        jj_consume_token(SQL_INTERVAL_HOUR_TO_SECOND);
        break;
        }
      case SQL_INTERVAL_MONTH:{
        jj_consume_token(SQL_INTERVAL_MONTH);
        break;
        }
      case SQL_INTERVAL_YEAR_TO_MONTH:{
        jj_consume_token(SQL_INTERVAL_YEAR_TO_MONTH);
        break;
        }
      case SQL_LONGVARCHAR:{
        jj_consume_token(SQL_LONGVARCHAR);
        break;
        }
      case SQL_NUMERIC:{
        jj_consume_token(SQL_NUMERIC);
        break;
        }
      case SQL_SMALLINT:{
        jj_consume_token(SQL_SMALLINT);
        break;
        }
      case SQL_TINYINT:{
        jj_consume_token(SQL_TINYINT);
        break;
        }
      case SQL_TSI_HOUR:{
        jj_consume_token(SQL_TSI_HOUR);
        break;
        }
      case SQL_TSI_MONTH:{
        jj_consume_token(SQL_TSI_MONTH);
        break;
        }
      case SQL_TSI_WEEK:{
        jj_consume_token(SQL_TSI_WEEK);
        break;
        }
      case SQL_VARCHAR:{
        jj_consume_token(SQL_VARCHAR);
        break;
        }
      case STRUCTURE:{
        jj_consume_token(STRUCTURE);
        break;
        }
      case SUBSTITUTE:{
        jj_consume_token(SUBSTITUTE);
        break;
        }
      case TIES:{
        jj_consume_token(TIES);
        break;
        }
      case TOP_LEVEL_COUNT:{
        jj_consume_token(TOP_LEVEL_COUNT);
        break;
        }
      case TRANSACTIONS_COMMITTED:{
        jj_consume_token(TRANSACTIONS_COMMITTED);
        break;
        }
      case TRANSFORMS:{
        jj_consume_token(TRANSFORMS);
        break;
        }
      case TRIGGER_SCHEMA:{
        jj_consume_token(TRIGGER_SCHEMA);
        break;
        }
      case UNCOMMITTED:{
        jj_consume_token(UNCOMMITTED);
        break;
        }
      case UNNAMED:{
        jj_consume_token(UNNAMED);
        break;
        }
      case USER_DEFINED_TYPE_CODE:{
        jj_consume_token(USER_DEFINED_TYPE_CODE);
        break;
        }
      case UTF8:{
        jj_consume_token(UTF8);
        break;
        }
      case VERSION:{
        jj_consume_token(VERSION);
        break;
        }
      case WRAPPER:{
        jj_consume_token(WRAPPER);
        break;
        }
      case XML:{
        jj_consume_token(XML);
        break;
        }
      default:
        jj_la1[332] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("NonReservedKeyWord2of3");
    }
}

/**
 * Defines a production which can never be accepted by the parser.
 * In effect, it tells the parser, "If you got here, you've gone too far."
 * It is used as the default production for parser extension points;
 * derived parsers replace it with a real production when they want to
 * implement a particular extension point.
 */
  final public void UnusedExtension() throws ParseException {
    trace_call("UnusedExtension");
    try {

      if (false) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(ZONE);
    } finally {
      trace_return("UnusedExtension");
    }
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_13()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_14()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_15()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_16()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_17()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_18()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_19()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_20()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_21()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_22()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_23()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_24()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_25()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_26()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_27()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_28()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_29()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_30()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_31()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_32()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_33()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_34()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_35()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_36()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_37()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_38()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_39()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_40()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_41()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_42()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_43()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_44()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_45()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_46()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_47()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_48()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_2_49(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_49()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  private boolean jj_2_50(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_50()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  private boolean jj_2_51(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_51()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  private boolean jj_2_52(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_52()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  private boolean jj_2_53(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_53()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  private boolean jj_2_54(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_54()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  private boolean jj_2_55(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_55()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  private boolean jj_2_56(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_56()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  private boolean jj_2_57(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_57()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  private boolean jj_2_58(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_58()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  private boolean jj_2_59(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_59()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  private boolean jj_2_60(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_60()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  private boolean jj_2_61(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_61()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  private boolean jj_2_62(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_62()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  private boolean jj_2_63(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_63()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  private boolean jj_2_64(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_64()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  private boolean jj_2_65(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_65()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  private boolean jj_2_66(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_66()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  private boolean jj_2_67(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_67()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  private boolean jj_2_68(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_68()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  private boolean jj_2_69(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_69()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  private boolean jj_2_70(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_70()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  private boolean jj_2_71(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_71()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  private boolean jj_2_72(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_72()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  private boolean jj_2_73(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_73()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  private boolean jj_2_74(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_74()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  private boolean jj_2_75(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_75()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  private boolean jj_2_76(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_76()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  private boolean jj_2_77(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_77()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  private boolean jj_2_78(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_78()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(77, xla); }
  }

  private boolean jj_2_79(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_79()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(78, xla); }
  }

  private boolean jj_2_80(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_80()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(79, xla); }
  }

  private boolean jj_2_81(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_81()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(80, xla); }
  }

  private boolean jj_2_82(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_82()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(81, xla); }
  }

  private boolean jj_2_83(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_83()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(82, xla); }
  }

  private boolean jj_2_84(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_84()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(83, xla); }
  }

  private boolean jj_2_85(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_85()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(84, xla); }
  }

  private boolean jj_2_86(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_86()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(85, xla); }
  }

  private boolean jj_2_87(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_87()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(86, xla); }
  }

  private boolean jj_2_88(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_88()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(87, xla); }
  }

  private boolean jj_2_89(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_89()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(88, xla); }
  }

  private boolean jj_2_90(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_90()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(89, xla); }
  }

  private boolean jj_2_91(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_91()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(90, xla); }
  }

  private boolean jj_2_92(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_92()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(91, xla); }
  }

  private boolean jj_2_93(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_93()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(92, xla); }
  }

  private boolean jj_2_94(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_94()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(93, xla); }
  }

  private boolean jj_2_95(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_95()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(94, xla); }
  }

  private boolean jj_2_96(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_96()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(95, xla); }
  }

  private boolean jj_3_53()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_49()) {
    jj_scanpos = xsp;
    if (jj_3_50()) {
    jj_scanpos = xsp;
    if (jj_3_51()) {
    jj_scanpos = xsp;
    if (jj_3_52()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_193()
 {
    if (jj_scan_token(EXTRACT)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_398()
 {
    Token xsp;
    if (jj_3_53()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_53()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_83()
 {
    if (!jj_rescan) trace_call("Expression2(LOOKING AHEAD...)");
    if (jj_3R_79()) { if (!jj_rescan) trace_return("Expression2(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_398()) {
    jj_scanpos = xsp;
    if (jj_3R_399()) { if (!jj_rescan) trace_return("Expression2(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("Expression2(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_192()
 {
    if (jj_scan_token(CAST)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_89()
 {
    if (!jj_rescan) trace_call("BuiltinFunctionCall(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3_74()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) { if (!jj_rescan) trace_return("BuiltinFunctionCall(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("BuiltinFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_19()
 {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3_46()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_272()
 {
    if (!jj_rescan) trace_call("CursorExpression(LOOKING AHEAD...)");
    if (jj_scan_token(CURSOR)) { if (!jj_rescan) trace_return("CursorExpression(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_42()) { if (!jj_rescan) trace_return("CursorExpression(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CursorExpression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_145()
 {
    if (jj_3R_282()) return true;
    return false;
  }

  private boolean jj_3R_79()
 {
    if (!jj_rescan) trace_call("Expression2b(LOOKING AHEAD...)");
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_145()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_72()) { if (!jj_rescan) trace_return("Expression2b(LOOKAHEAD FAILED)"); return true; }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_46()) { jj_scanpos = xsp; break; }
    }
    { if (!jj_rescan) trace_return("Expression2b(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_403()
 {
    if (!jj_rescan) trace_call("CollectionsTypeName(LOOKING AHEAD...)");
    if (jj_scan_token(MULTISET)) { if (!jj_rescan) trace_return("CollectionsTypeName(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CollectionsTypeName(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_370()
 {
    if (jj_scan_token(JSON)) return true;
    return false;
  }

  private boolean jj_3R_42()
 {
    if (!jj_rescan) trace_call("Expression(LOOKING AHEAD...)");
    if (jj_3R_83()) { if (!jj_rescan) trace_return("Expression(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Expression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_96()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(SCALAR)) return true;
    return false;
  }

  private boolean jj_3_95()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(ARRAY)) return true;
    return false;
  }

  private boolean jj_3_94()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(OBJECT)) return true;
    return false;
  }

  private boolean jj_3_93()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(VALUE)) return true;
    return false;
  }

  private boolean jj_3R_369()
 {
    if (jj_scan_token(EMPTY)) return true;
    return false;
  }

  private boolean jj_3R_368()
 {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_367()
 {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_49()
 {
    if (!jj_rescan) trace_call("WhenMatchedClause(LOOKING AHEAD...)");
    if (jj_scan_token(WHEN)) { if (!jj_rescan) trace_return("WhenMatchedClause(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(MATCHED)) { if (!jj_rescan) trace_return("WhenMatchedClause(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("WhenMatchedClause(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_366()
 {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_365()
 {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_219()
 {
    if (jj_3R_318()) return true;
    return false;
  }

  private boolean jj_3_92()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(SCALAR)) return true;
    return false;
  }

  private boolean jj_3R_286()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_365()) {
    jj_scanpos = xsp;
    if (jj_3R_366()) {
    jj_scanpos = xsp;
    if (jj_3R_367()) {
    jj_scanpos = xsp;
    if (jj_3R_368()) {
    jj_scanpos = xsp;
    if (jj_3R_369()) {
    jj_scanpos = xsp;
    if (jj_3_93()) {
    jj_scanpos = xsp;
    if (jj_3_94()) {
    jj_scanpos = xsp;
    if (jj_3_95()) {
    jj_scanpos = xsp;
    if (jj_3_96()) {
    jj_scanpos = xsp;
    if (jj_3R_370()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_92()
 {
    if (!jj_rescan) trace_call("LeafQueryOrExpr(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_45()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) { if (!jj_rescan) trace_return("LeafQueryOrExpr(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("LeafQueryOrExpr(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_45()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3_91()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(ARRAY)) return true;
    return false;
  }

  private boolean jj_3_90()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(OBJECT)) return true;
    return false;
  }

  private boolean jj_3_89()
 {
    if (jj_scan_token(JSON)) return true;
    if (jj_scan_token(VALUE)) return true;
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_285()
 {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3_44()
 {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_284()
 {
    if (jj_scan_token(A)) return true;
    return false;
  }

  private boolean jj_3R_173()
 {
    if (!jj_rescan) trace_call("PostfixRowOperator(LOOKING AHEAD...)");
    if (jj_scan_token(IS)) { if (!jj_rescan) trace_return("PostfixRowOperator(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_284()) {
    jj_scanpos = xsp;
    if (jj_3R_285()) {
    jj_scanpos = xsp;
    if (jj_3R_286()) { if (!jj_rescan) trace_return("PostfixRowOperator(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("PostfixRowOperator(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_265()
 {
    if (!jj_rescan) trace_call("SqlMerge(LOOKING AHEAD...)");
    if (jj_scan_token(MERGE)) { if (!jj_rescan) trace_return("SqlMerge(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SqlMerge(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_243()
 {
    if (jj_scan_token(ANY)) return true;
    return false;
  }

  private boolean jj_3R_361()
 {
    if (jj_scan_token(EXISTS)) return true;
    return false;
  }

  private boolean jj_3R_360()
 {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_242()
 {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_359()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_282()
 {
    if (!jj_rescan) trace_call("PrefixRowOperator(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_358()) {
    jj_scanpos = xsp;
    if (jj_3R_359()) {
    jj_scanpos = xsp;
    if (jj_3R_360()) {
    jj_scanpos = xsp;
    if (jj_3R_361()) { if (!jj_rescan) trace_return("PrefixRowOperator(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    { if (!jj_rescan) trace_return("PrefixRowOperator(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_358()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_241()
 {
    if (jj_scan_token(DOUBLE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(412)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_349()
 {
    if (!jj_rescan) trace_call("WithList(LOOKING AHEAD...)");
    if (jj_scan_token(WITH)) { if (!jj_rescan) trace_return("WithList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("WithList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_240()
 {
    if (jj_scan_token(REAL)) return true;
    return false;
  }

  private boolean jj_3R_239()
 {
    if (jj_scan_token(BIGINT)) return true;
    return false;
  }

  private boolean jj_3R_238()
 {
    if (jj_scan_token(SMALLINT)) return true;
    return false;
  }

  private boolean jj_3R_172()
 {
    if (jj_3R_283()) return true;
    return false;
  }

  private boolean jj_3R_237()
 {
    if (jj_scan_token(TINYINT)) return true;
    return false;
  }

  private boolean jj_3R_171()
 {
    if (jj_scan_token(IMMEDIATELY)) return true;
    if (jj_scan_token(SUCCEEDS)) return true;
    return false;
  }

  private boolean jj_3R_323()
 {
    return false;
  }

  private boolean jj_3_88()
 {
    if (jj_scan_token(IMMEDIATELY)) return true;
    if (jj_scan_token(PRECEDES)) return true;
    return false;
  }

  private boolean jj_3R_236()
 {
    if (jj_scan_token(VARBINARY)) return true;
    return false;
  }

  private boolean jj_3R_170()
 {
    if (jj_scan_token(SUCCEEDS)) return true;
    return false;
  }

  private boolean jj_3R_322()
 {
    if (jj_scan_token(VARYING)) return true;
    return false;
  }

  private boolean jj_3R_169()
 {
    if (jj_scan_token(PRECEDES)) return true;
    return false;
  }

  private boolean jj_3R_168()
 {
    if (jj_scan_token(EQUALS)) return true;
    return false;
  }

  private boolean jj_3R_167()
 {
    if (jj_scan_token(OVERLAPS)) return true;
    return false;
  }

  private boolean jj_3R_166()
 {
    if (jj_scan_token(CONTAINS)) return true;
    return false;
  }

  private boolean jj_3R_165()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(SUBMULTISET)) return true;
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3_87()
 {
    if (jj_scan_token(SUBMULTISET)) return true;
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3R_235()
 {
    if (jj_scan_token(BINARY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_322()) {
    jj_scanpos = xsp;
    if (jj_3R_323()) return true;
    }
    return false;
  }

  private boolean jj_3R_164()
 {
    if (jj_scan_token(MEMBER)) return true;
    if (jj_scan_token(OF)) return true;
    return false;
  }

  private boolean jj_3R_163()
 {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3R_234()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(253)) {
    jj_scanpos = xsp;
    if (jj_scan_token(252)) return true;
    }
    return false;
  }

  private boolean jj_3_86()
 {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(DISTINCT)) return true;
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_162()
 {
    if (jj_scan_token(OR)) return true;
    return false;
  }

  private boolean jj_3R_233()
 {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3R_161()
 {
    if (jj_scan_token(AND)) return true;
    return false;
  }

  private boolean jj_3R_160()
 {
    if (jj_scan_token(CONCAT)) return true;
    return false;
  }

  private boolean jj_3R_232()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(137)) {
    jj_scanpos = xsp;
    if (jj_scan_token(135)) {
    jj_scanpos = xsp;
    if (jj_scan_token(353)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_159()
 {
    if (jj_scan_token(PERCENT_REMAINDER)) return true;
    return false;
  }

  private boolean jj_3R_158()
 {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  private boolean jj_3R_231()
 {
    if (jj_scan_token(GEOMETRY)) return true;
    return false;
  }

  private boolean jj_3R_157()
 {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_156()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_230()
 {
    if (jj_scan_token(TIMESTAMP)) return true;
    return false;
  }

  private boolean jj_3R_155()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_229()
 {
    if (jj_scan_token(TIME)) return true;
    return false;
  }

  private boolean jj_3R_228()
 {
    if (jj_scan_token(DATE)) return true;
    return false;
  }

  private boolean jj_3R_321()
 {
    return false;
  }

  private boolean jj_3R_261()
 {
    if (jj_3R_349()) return true;
    return false;
  }

  private boolean jj_3R_227()
 {
    if (jj_scan_token(VARCHAR)) return true;
    return false;
  }

  private boolean jj_3R_154()
 {
    if (jj_scan_token(NE2)) return true;
    return false;
  }

  private boolean jj_3R_320()
 {
    if (jj_scan_token(VARYING)) return true;
    return false;
  }

  private boolean jj_3R_153()
 {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_152()
 {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_151()
 {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_264()
 {
    if (!jj_rescan) trace_call("SqlUpdate(LOOKING AHEAD...)");
    if (jj_scan_token(UPDATE)) { if (!jj_rescan) trace_return("SqlUpdate(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SqlUpdate(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_150()
 {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_113()
 {
    if (!jj_rescan) trace_call("QueryOrExpr(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_261()) jj_scanpos = xsp;
    if (jj_3R_92()) { if (!jj_rescan) trace_return("QueryOrExpr(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("QueryOrExpr(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_149()
 {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3R_148()
 {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_84()
 {
    if (!jj_rescan) trace_call("BinaryRowOperator(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3_86()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3_87()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3_88()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) { if (!jj_rescan) trace_return("BinaryRowOperator(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("BinaryRowOperator(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_226()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) return true;
    }
    return false;
  }

  private boolean jj_3R_100()
 {
    if (!jj_rescan) trace_call("SqlTypeName(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) {
    jj_scanpos = xsp;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) {
    jj_scanpos = xsp;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) {
    jj_scanpos = xsp;
    if (jj_3R_242()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) { if (!jj_rescan) trace_return("SqlTypeName(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("SqlTypeName(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_427()
 {
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3R_407()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_3R_427()) return true;
    }
    return false;
  }

  private boolean jj_3R_401()
 {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_400()
 {
    if (jj_3R_403()) return true;
    return false;
  }

  private boolean jj_3R_364()
 {
    if (jj_scan_token(EXCEPT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_407()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_426()
 {
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3R_406()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_3R_426()) return true;
    }
    return false;
  }

  private boolean jj_3_71()
 {
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_352()
 {
    if (!jj_rescan) trace_call("TypeName(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_71()) {
    jj_scanpos = xsp;
    if (jj_3R_400()) {
    jj_scanpos = xsp;
    if (jj_3R_401()) { if (!jj_rescan) trace_return("TypeName(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("TypeName(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_363()
 {
    if (jj_scan_token(INTERSECT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_406()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_425()
 {
    if (jj_scan_token(DISTINCT)) return true;
    return false;
  }

  private boolean jj_3R_405()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_3R_425()) return true;
    }
    return false;
  }

  private boolean jj_3R_362()
 {
    if (jj_scan_token(UNION)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_405()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_263()
 {
    if (!jj_rescan) trace_call("SqlDelete(LOOKING AHEAD...)");
    if (jj_scan_token(DELETE)) { if (!jj_rescan) trace_return("SqlDelete(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SqlDelete(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_283()
 {
    if (!jj_rescan) trace_call("BinaryMultisetOperator(LOOKING AHEAD...)");
    if (jj_scan_token(MULTISET)) { if (!jj_rescan) trace_return("BinaryMultisetOperator(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_362()) {
    jj_scanpos = xsp;
    if (jj_3R_363()) {
    jj_scanpos = xsp;
    if (jj_3R_364()) { if (!jj_rescan) trace_return("BinaryMultisetOperator(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("BinaryMultisetOperator(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_355()
 {
    if (jj_3R_403()) return true;
    return false;
  }

  private boolean jj_3R_354()
 {
    if (jj_scan_token(CHARACTER)) return true;
    if (jj_scan_token(SET)) return true;
    return false;
  }

  private boolean jj_3R_353()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_402()) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_267()
 {
    if (!jj_rescan) trace_call("DataType(LOOKING AHEAD...)");
    if (jj_3R_352()) { if (!jj_rescan) trace_return("DataType(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_353()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_354()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_355()) jj_scanpos = xsp;
    { if (!jj_rescan) trace_return("DataType(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_16()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(193)) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_351()
 {
    if (jj_scan_token(UPSERT)) return true;
    return false;
  }

  private boolean jj_3_84()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_262()
 {
    if (!jj_rescan) trace_call("SqlInsert(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(249)) {
    jj_scanpos = xsp;
    if (jj_3R_351()) { if (!jj_rescan) trace_return("SqlInsert(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("SqlInsert(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_83()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_417()
 {
    if (jj_3R_445()) return true;
    return false;
  }

  private boolean jj_3R_416()
 {
    if (jj_3R_444()) return true;
    return false;
  }

  private boolean jj_3R_415()
 {
    if (jj_3R_317()) return true;
    return false;
  }

  private boolean jj_3R_414()
 {
    if (jj_scan_token(TRUNCATE)) return true;
    return false;
  }

  private boolean jj_3R_271()
 {
    return false;
  }

  private boolean jj_3R_413()
 {
    if (jj_scan_token(INSERT)) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_378()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_413()) {
    jj_scanpos = xsp;
    if (jj_3R_414()) {
    jj_scanpos = xsp;
    if (jj_3R_415()) {
    jj_scanpos = xsp;
    if (jj_3R_416()) {
    jj_scanpos = xsp;
    if (jj_3R_417()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_402()
 {
    if (!jj_rescan) trace_call("UnsignedIntLiteral(LOOKING AHEAD...)");
    if (jj_scan_token(UNSIGNED_INTEGER_LITERAL)) { if (!jj_rescan) trace_return("UnsignedIntLiteral(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("UnsignedIntLiteral(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_134()
 {
    if (!jj_rescan) trace_call("UnusedExtension(LOOKING AHEAD...)");
    jj_lookingAhead = true;
    jj_semLA = false;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_271()) { if (!jj_rescan) trace_return("UnusedExtension(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(ZONE)) { if (!jj_rescan) trace_return("UnusedExtension(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("UnusedExtension(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_384()
 {
    if (!jj_rescan) trace_call("NamedRoutineCall(LOOKING AHEAD...)");
    if (jj_3R_44()) { if (!jj_rescan) trace_return("NamedRoutineCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("NamedRoutineCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_377()
 {
    if (jj_scan_token(CONVERT)) return true;
    return false;
  }

  private boolean jj_3_85()
 {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_300()
 {
    if (!jj_rescan) trace_call("NewSpecification(LOOKING AHEAD...)");
    if (jj_scan_token(NEW)) { if (!jj_rescan) trace_return("NewSpecification(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_384()) { if (!jj_rescan) trace_return("NewSpecification(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("NewSpecification(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_376()
 {
    if (jj_3R_304()) return true;
    return false;
  }

  private boolean jj_3R_294()
 {
    if (!jj_rescan) trace_call("JdbcFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(LBRACE_FN)) { if (!jj_rescan) trace_return("JdbcFunctionCall(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_376()) {
    jj_scanpos = xsp;
    if (jj_3_85()) {
    jj_scanpos = xsp;
    if (jj_3R_377()) {
    jj_scanpos = xsp;
    if (jj_3R_378()) { if (!jj_rescan) trace_return("JdbcFunctionCall(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    { if (!jj_rescan) trace_return("JdbcFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_48()
 {
    if (!jj_rescan) trace_call("ParenthesizedCompoundIdentifierList(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("ParenthesizedCompoundIdentifierList(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_121()) { if (!jj_rescan) trace_return("ParenthesizedCompoundIdentifierList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ParenthesizedCompoundIdentifierList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_121()
 {
    if (!jj_rescan) trace_call("CompoundIdentifierTypeCommaList(LOOKING AHEAD...)");
    if (jj_3R_269()) { if (!jj_rescan) trace_return("CompoundIdentifierTypeCommaList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CompoundIdentifierTypeCommaList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_14()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(564)) jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(583)) {
    jj_scanpos = xsp;
    if (jj_scan_token(729)) {
    jj_scanpos = xsp;
    if (jj_scan_token(726)) {
    jj_scanpos = xsp;
    if (jj_scan_token(727)) {
    jj_scanpos = xsp;
    if (jj_scan_token(725)) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_299()
 {
    if (!jj_rescan) trace_call("ContextVariable(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(298)) {
    jj_scanpos = xsp;
    if (jj_scan_token(299)) {
    jj_scanpos = xsp;
    if (jj_scan_token(492)) {
    jj_scanpos = xsp;
    if (jj_scan_token(582)) {
    jj_scanpos = xsp;
    if (jj_scan_token(632)) { if (!jj_rescan) trace_return("ContextVariable(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("ContextVariable(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_70()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(472)) return true;
    }
    }
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3_69()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3R_44()
 {
    if (!jj_rescan) trace_call("CompoundIdentifier(LOOKING AHEAD...)");
    if (jj_3R_99()) { if (!jj_rescan) trace_return("CompoundIdentifier(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_69()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3_70()) jj_scanpos = xsp;
    { if (!jj_rescan) trace_return("CompoundIdentifier(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_50()
 {
    if (!jj_rescan) trace_call("ParenthesizedSimpleIdentifierList(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("ParenthesizedSimpleIdentifierList(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_122()) { if (!jj_rescan) trace_return("ParenthesizedSimpleIdentifierList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ParenthesizedSimpleIdentifierList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_122()
 {
    if (!jj_rescan) trace_call("SimpleIdentifierCommaList(LOOKING AHEAD...)");
    if (jj_3R_43()) { if (!jj_rescan) trace_return("SimpleIdentifierCommaList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SimpleIdentifierCommaList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_43()
 {
    if (!jj_rescan) trace_call("SimpleIdentifier(LOOKING AHEAD...)");
    if (jj_3R_99()) { if (!jj_rescan) trace_return("SimpleIdentifier(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SimpleIdentifier(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_317()
 {
    if (!jj_rescan) trace_call("ReservedFunctionName(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(2)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(148)) {
    jj_scanpos = xsp;
    if (jj_scan_token(171)) {
    jj_scanpos = xsp;
    if (jj_scan_token(191)) {
    jj_scanpos = xsp;
    if (jj_scan_token(201)) {
    jj_scanpos = xsp;
    if (jj_scan_token(203)) {
    jj_scanpos = xsp;
    if (jj_scan_token(216)) {
    jj_scanpos = xsp;
    if (jj_scan_token(228)) {
    jj_scanpos = xsp;
    if (jj_scan_token(233)) {
    jj_scanpos = xsp;
    if (jj_scan_token(281)) {
    jj_scanpos = xsp;
    if (jj_scan_token(287)) {
    jj_scanpos = xsp;
    if (jj_scan_token(285)) {
    jj_scanpos = xsp;
    if (jj_scan_token(296)) {
    jj_scanpos = xsp;
    if (jj_scan_token(298)) {
    jj_scanpos = xsp;
    if (jj_scan_token(299)) {
    jj_scanpos = xsp;
    if (jj_scan_token(301)) {
    jj_scanpos = xsp;
    if (jj_scan_token(309)) {
    jj_scanpos = xsp;
    if (jj_scan_token(321)) {
    jj_scanpos = xsp;
    if (jj_scan_token(322)) {
    jj_scanpos = xsp;
    if (jj_scan_token(324)) {
    jj_scanpos = xsp;
    if (jj_scan_token(327)) {
    jj_scanpos = xsp;
    if (jj_scan_token(346)) {
    jj_scanpos = xsp;
    if (jj_scan_token(347)) {
    jj_scanpos = xsp;
    if (jj_scan_token(350)) {
    jj_scanpos = xsp;
    if (jj_scan_token(356)) {
    jj_scanpos = xsp;
    if (jj_scan_token(400)) {
    jj_scanpos = xsp;
    if (jj_scan_token(409)) {
    jj_scanpos = xsp;
    if (jj_scan_token(423)) {
    jj_scanpos = xsp;
    if (jj_scan_token(433)) {
    jj_scanpos = xsp;
    if (jj_scan_token(437)) {
    jj_scanpos = xsp;
    if (jj_scan_token(439)) {
    jj_scanpos = xsp;
    if (jj_scan_token(466)) {
    jj_scanpos = xsp;
    if (jj_scan_token(480)) {
    jj_scanpos = xsp;
    if (jj_scan_token(561)) {
    jj_scanpos = xsp;
    if (jj_scan_token(566)) {
    jj_scanpos = xsp;
    if (jj_scan_token(567)) {
    jj_scanpos = xsp;
    if (jj_scan_token(578)) {
    jj_scanpos = xsp;
    if (jj_scan_token(629)) {
    jj_scanpos = xsp;
    if (jj_scan_token(616)) {
    jj_scanpos = xsp;
    if (jj_scan_token(632)) {
    jj_scanpos = xsp;
    if (jj_scan_token(644)) {
    jj_scanpos = xsp;
    if (jj_scan_token(645)) {
    jj_scanpos = xsp;
    if (jj_scan_token(665)) { if (!jj_rescan) trace_return("ReservedFunctionName(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("ReservedFunctionName(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_11()
 {
    if (jj_scan_token(WITH)) return true;
    if (jj_scan_token(TYPE)) return true;
    return false;
  }

  private boolean jj_3R_445()
 {
    if (!jj_rescan) trace_call("Identifier(LOOKING AHEAD...)");
    if (jj_3R_99()) { if (!jj_rescan) trace_return("Identifier(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Identifier(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_218()
 {
    if (jj_3R_317()) return true;
    return false;
  }

  private boolean jj_3R_217()
 {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_117()
 {
    if (jj_3R_265()) return true;
    return false;
  }

  private boolean jj_3R_91()
 {
    if (!jj_rescan) trace_call("FunctionName(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) { if (!jj_rescan) trace_return("FunctionName(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("FunctionName(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_116()
 {
    if (jj_3R_264()) return true;
    return false;
  }

  private boolean jj_3R_115()
 {
    if (jj_3R_263()) return true;
    return false;
  }

  private boolean jj_3R_114()
 {
    if (jj_3R_262()) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_45()
 {
    if (!jj_rescan) trace_call("SqlQueryOrDml(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) { if (!jj_rescan) trace_return("SqlQueryOrDml(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("SqlQueryOrDml(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_225()
 {
    if (jj_3R_319()) return true;
    return false;
  }

  private boolean jj_3R_444()
 {
    if (!jj_rescan) trace_call("NonReservedJdbcFunctionName(LOOKING AHEAD...)");
    if (jj_scan_token(SUBSTRING)) { if (!jj_rescan) trace_return("NonReservedJdbcFunctionName(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("NonReservedJdbcFunctionName(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_350()
 {
    if (jj_scan_token(UESCAPE)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_224()
 {
    if (jj_scan_token(UNICODE_QUOTED_IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_350()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_scan_token(AS)) return true;
    if (jj_scan_token(XML)) return true;
    return false;
  }

  private boolean jj_3R_223()
 {
    if (jj_scan_token(BRACKET_QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_222()
 {
    if (jj_scan_token(BACK_QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_221()
 {
    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_388()
 {
    if (!jj_rescan) trace_call("StandardFloorCeilOptions(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("StandardFloorCeilOptions(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("StandardFloorCeilOptions(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_220()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_99()
 {
    if (!jj_rescan) trace_call("IdentifierSegment(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) { if (!jj_rescan) trace_return("IdentifierSegment(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("IdentifierSegment(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_43()
 {
    if (jj_scan_token(FIRST)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3_42()
 {
    if (jj_scan_token(NEXT)) return true;
    if (jj_scan_token(ROW)) return true;
    return false;
  }

  private boolean jj_3R_260()
 {
    if (!jj_rescan) trace_call("DynamicParam(LOOKING AHEAD...)");
    if (jj_scan_token(HOOK)) { if (!jj_rescan) trace_return("DynamicParam(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("DynamicParam(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_345()
 {
    if (jj_scan_token(SQL_TSI_YEAR)) return true;
    return false;
  }

  private boolean jj_3R_344()
 {
    if (jj_scan_token(YEAR)) return true;
    return false;
  }

  private boolean jj_3R_343()
 {
    if (jj_scan_token(SQL_TSI_QUARTER)) return true;
    return false;
  }

  private boolean jj_3R_342()
 {
    if (jj_scan_token(QUARTER)) return true;
    return false;
  }

  private boolean jj_3R_341()
 {
    if (jj_scan_token(SQL_TSI_MONTH)) return true;
    return false;
  }

  private boolean jj_3R_340()
 {
    if (jj_scan_token(MONTH)) return true;
    return false;
  }

  private boolean jj_3R_339()
 {
    if (jj_scan_token(SQL_TSI_WEEK)) return true;
    return false;
  }

  private boolean jj_3R_338()
 {
    if (jj_scan_token(WEEK)) return true;
    return false;
  }

  private boolean jj_3R_337()
 {
    if (jj_scan_token(SQL_TSI_DAY)) return true;
    return false;
  }

  private boolean jj_3R_336()
 {
    if (jj_scan_token(DAY)) return true;
    return false;
  }

  private boolean jj_3R_335()
 {
    if (jj_scan_token(SQL_TSI_HOUR)) return true;
    return false;
  }

  private boolean jj_3R_334()
 {
    if (jj_scan_token(HOUR)) return true;
    return false;
  }

  private boolean jj_3R_419()
 {
    if (!jj_rescan) trace_call("SqlSelect(LOOKING AHEAD...)");
    if (jj_scan_token(SELECT)) { if (!jj_rescan) trace_return("SqlSelect(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SqlSelect(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_333()
 {
    if (jj_scan_token(SQL_TSI_MINUTE)) return true;
    return false;
  }

  private boolean jj_3_82()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_332()
 {
    if (jj_scan_token(MINUTE)) return true;
    return false;
  }

  private boolean jj_3R_331()
 {
    if (jj_scan_token(SQL_TSI_SECOND)) return true;
    return false;
  }

  private boolean jj_3R_330()
 {
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3R_329()
 {
    if (jj_scan_token(SQL_TSI_MICROSECOND)) return true;
    return false;
  }

  private boolean jj_3R_328()
 {
    if (jj_scan_token(SQL_TSI_FRAC_SECOND)) return true;
    return false;
  }

  private boolean jj_3_81()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_327()
 {
    if (jj_scan_token(NANOSECOND)) return true;
    return false;
  }

  private boolean jj_3R_326()
 {
    if (jj_scan_token(MICROSECOND)) return true;
    return false;
  }

  private boolean jj_3R_258()
 {
    if (!jj_rescan) trace_call("TimestampInterval(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_325()) {
    jj_scanpos = xsp;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) {
    jj_scanpos = xsp;
    if (jj_3R_328()) {
    jj_scanpos = xsp;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) {
    jj_scanpos = xsp;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) {
    jj_scanpos = xsp;
    if (jj_3R_333()) {
    jj_scanpos = xsp;
    if (jj_3R_334()) {
    jj_scanpos = xsp;
    if (jj_3R_335()) {
    jj_scanpos = xsp;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) {
    jj_scanpos = xsp;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) {
    jj_scanpos = xsp;
    if (jj_3R_340()) {
    jj_scanpos = xsp;
    if (jj_3R_341()) {
    jj_scanpos = xsp;
    if (jj_3R_342()) {
    jj_scanpos = xsp;
    if (jj_3R_343()) {
    jj_scanpos = xsp;
    if (jj_3R_344()) {
    jj_scanpos = xsp;
    if (jj_3R_345()) { if (!jj_rescan) trace_return("TimestampInterval(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("TimestampInterval(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_325()
 {
    if (jj_scan_token(FRAC_SECOND)) return true;
    return false;
  }

  private boolean jj_3R_133()
 {
    if (!jj_rescan) trace_call("MatchRecognize(LOOKING AHEAD...)");
    if (jj_scan_token(MATCH_RECOGNIZE)) { if (!jj_rescan) trace_return("MatchRecognize(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("MatchRecognize(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_383()
 {
    return false;
  }

  private boolean jj_3R_382()
 {
    if (jj_scan_token(SPECIFIC)) return true;
    return false;
  }

  private boolean jj_3R_298()
 {
    if (!jj_rescan) trace_call("NamedFunctionCall(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_382()) {
    jj_scanpos = xsp;
    if (jj_3R_383()) { if (!jj_rescan) trace_return("NamedFunctionCall(LOOKAHEAD FAILED)"); return true; }
    }
    if (jj_3R_91()) { if (!jj_rescan) trace_return("NamedFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("NamedFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_132()
 {
    if (!jj_rescan) trace_call("Snapshot(LOOKING AHEAD...)");
    if (jj_scan_token(FOR)) { if (!jj_rescan) trace_return("Snapshot(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Snapshot(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_292()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_291()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_179()
 {
    if (jj_scan_token(SECOND)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_292()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_68()
 {
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3_41()
 {
    if (jj_scan_token(NULLS)) return true;
    if (jj_scan_token(FIRST)) return true;
    return false;
  }

  private boolean jj_3R_98()
 {
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3R_178()
 {
    if (jj_scan_token(MINUTE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_291()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_68()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_97()
 {
    if (jj_scan_token(MINUTE)) return true;
    return false;
  }

  private boolean jj_3R_290()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_67()
 {
    if (jj_scan_token(TO)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) return true;
    }
    return false;
  }

  private boolean jj_3R_96()
 {
    if (jj_scan_token(SECOND)) return true;
    return false;
  }

  private boolean jj_3R_71()
 {
    if (!jj_rescan) trace_call("OrderItem(LOOKING AHEAD...)");
    if (jj_3R_42()) { if (!jj_rescan) trace_return("OrderItem(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("OrderItem(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_177()
 {
    if (jj_scan_token(HOUR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_290()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_67()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_95()
 {
    if (jj_scan_token(MINUTE)) return true;
    return false;
  }

  private boolean jj_3R_94()
 {
    if (jj_scan_token(HOUR)) return true;
    return false;
  }

  private boolean jj_3R_289()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_257()
 {
    if (jj_scan_token(NEXT)) return true;
    return false;
  }

  private boolean jj_3R_288()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_256()
 {
    if (jj_scan_token(PREV)) return true;
    return false;
  }

  private boolean jj_3_40()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3_66()
 {
    if (jj_scan_token(TO)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_109()
 {
    if (!jj_rescan) trace_call("MatchRecognizeNavigationPhysical(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) { if (!jj_rescan) trace_return("MatchRecognizeNavigationPhysical(LOOKAHEAD FAILED)"); return true; }
    }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("MatchRecognizeNavigationPhysical(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("MatchRecognizeNavigationPhysical(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_176()
 {
    if (jj_scan_token(DAY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_289()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_66()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_266()
 {
    if (!jj_rescan) trace_call("Default(LOOKING AHEAD...)");
    if (jj_scan_token(DEFAULT_)) { if (!jj_rescan) trace_return("Default(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Default(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_175()
 {
    if (jj_scan_token(MONTH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_288()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_287()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_65()
 {
    if (jj_scan_token(TO)) return true;
    if (jj_scan_token(MONTH)) return true;
    return false;
  }

  private boolean jj_3R_174()
 {
    if (jj_scan_token(YEAR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_287()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_65()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_87()
 {
    if (!jj_rescan) trace_call("IntervalQualifier(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) { if (!jj_rescan) trace_return("IntervalQualifier(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("IntervalQualifier(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_6()
 {
    if (jj_3R_43()) return true;
    if (jj_scan_token(NAMED_ARGUMENT_ASSIGNMENT)) return true;
    return false;
  }

  private boolean jj_3R_255()
 {
    if (jj_scan_token(LAST)) return true;
    return false;
  }

  private boolean jj_3R_254()
 {
    if (jj_scan_token(FIRST)) return true;
    return false;
  }

  private boolean jj_3R_253()
 {
    return false;
  }

  private boolean jj_3R_252()
 {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_251()
 {
    if (jj_scan_token(RUNNING)) return true;
    return false;
  }

  private boolean jj_3R_454()
 {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_453()
 {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_443()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_453()) {
    jj_scanpos = xsp;
    if (jj_3R_454()) return true;
    }
    return false;
  }

  private boolean jj_3R_108()
 {
    if (!jj_rescan) trace_call("MatchRecognizeNavigationLogical(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) { if (!jj_rescan) trace_return("MatchRecognizeNavigationLogical(LOOKAHEAD FAILED)"); return true; }
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) { if (!jj_rescan) trace_return("MatchRecognizeNavigationLogical(LOOKAHEAD FAILED)"); return true; }
    }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("MatchRecognizeNavigationLogical(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("MatchRecognizeNavigationLogical(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_5()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_39()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_412()
 {
    if (!jj_rescan) trace_call("IntervalLiteral(LOOKING AHEAD...)");
    if (jj_scan_token(INTERVAL)) { if (!jj_rescan) trace_return("IntervalLiteral(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_443()) jj_scanpos = xsp;
    if (jj_scan_token(QUOTED_STRING)) { if (!jj_rescan) trace_return("IntervalLiteral(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("IntervalLiteral(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_70()
 {
    if (jj_scan_token(FOLLOWING)) return true;
    return false;
  }

  private boolean jj_3R_118()
 {
    if (jj_3R_266()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_43()) return true;
    if (jj_scan_token(NAMED_ARGUMENT_ASSIGNMENT)) return true;
    return false;
  }

  private boolean jj_3R_69()
 {
    if (jj_scan_token(PRECEDING)) return true;
    return false;
  }

  private boolean jj_3R_46()
 {
    if (!jj_rescan) trace_call("Arg0(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3_5()) { if (!jj_rescan) trace_return("Arg0(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("Arg0(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_447()
 {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3_38()
 {
    if (jj_scan_token(UNBOUNDED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) return true;
    }
    return false;
  }

  private boolean jj_3R_446()
 {
    if (jj_scan_token(RUNNING)) return true;
    return false;
  }

  private boolean jj_3_37()
 {
    if (jj_scan_token(CURRENT)) return true;
    if (jj_scan_token(ROW)) return true;
    return false;
  }

  private boolean jj_3R_68()
 {
    if (!jj_rescan) trace_call("WindowRange(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3_38()) {
    jj_scanpos = xsp;
    if (jj_3_39()) { if (!jj_rescan) trace_return("WindowRange(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("WindowRange(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_418()
 {
    if (!jj_rescan) trace_call("MatchRecognizeCallWithModifier(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_446()) {
    jj_scanpos = xsp;
    if (jj_3R_447()) { if (!jj_rescan) trace_return("MatchRecognizeCallWithModifier(LOOKAHEAD FAILED)"); return true; }
    }
    if (jj_3R_298()) { if (!jj_rescan) trace_return("MatchRecognizeCallWithModifier(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("MatchRecognizeCallWithModifier(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_297()
 {
    if (!jj_rescan) trace_call("PeriodConstructor(LOOKING AHEAD...)");
    if (jj_scan_token(PERIOD)) { if (!jj_rescan) trace_return("PeriodConstructor(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("PeriodConstructor(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("PeriodConstructor(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_391()
 {
    if (jj_3R_418()) return true;
    return false;
  }

  private boolean jj_3_80()
 {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_424()
 {
    if (!jj_rescan) trace_call("NonReservedKeyWord2of3(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(145)) {
    jj_scanpos = xsp;
    if (jj_scan_token(151)) {
    jj_scanpos = xsp;
    if (jj_scan_token(155)) {
    jj_scanpos = xsp;
    if (jj_scan_token(162)) {
    jj_scanpos = xsp;
    if (jj_scan_token(168)) {
    jj_scanpos = xsp;
    if (jj_scan_token(179)) {
    jj_scanpos = xsp;
    if (jj_scan_token(186)) {
    jj_scanpos = xsp;
    if (jj_scan_token(200)) {
    jj_scanpos = xsp;
    if (jj_scan_token(208)) {
    jj_scanpos = xsp;
    if (jj_scan_token(217)) {
    jj_scanpos = xsp;
    if (jj_scan_token(220)) {
    jj_scanpos = xsp;
    if (jj_scan_token(226)) {
    jj_scanpos = xsp;
    if (jj_scan_token(236)) {
    jj_scanpos = xsp;
    if (jj_scan_token(241)) {
    jj_scanpos = xsp;
    if (jj_scan_token(250)) {
    jj_scanpos = xsp;
    if (jj_scan_token(260)) {
    jj_scanpos = xsp;
    if (jj_scan_token(263)) {
    jj_scanpos = xsp;
    if (jj_scan_token(273)) {
    jj_scanpos = xsp;
    if (jj_scan_token(277)) {
    jj_scanpos = xsp;
    if (jj_scan_token(280)) {
    jj_scanpos = xsp;
    if (jj_scan_token(291)) {
    jj_scanpos = xsp;
    if (jj_scan_token(302)) {
    jj_scanpos = xsp;
    if (jj_scan_token(310)) {
    jj_scanpos = xsp;
    if (jj_scan_token(315)) {
    jj_scanpos = xsp;
    if (jj_scan_token(320)) {
    jj_scanpos = xsp;
    if (jj_scan_token(330)) {
    jj_scanpos = xsp;
    if (jj_scan_token(333)) {
    jj_scanpos = xsp;
    if (jj_scan_token(349)) {
    jj_scanpos = xsp;
    if (jj_scan_token(354)) {
    jj_scanpos = xsp;
    if (jj_scan_token(367)) {
    jj_scanpos = xsp;
    if (jj_scan_token(372)) {
    jj_scanpos = xsp;
    if (jj_scan_token(380)) {
    jj_scanpos = xsp;
    if (jj_scan_token(384)) {
    jj_scanpos = xsp;
    if (jj_scan_token(387)) {
    jj_scanpos = xsp;
    if (jj_scan_token(391)) {
    jj_scanpos = xsp;
    if (jj_scan_token(394)) {
    jj_scanpos = xsp;
    if (jj_scan_token(405)) {
    jj_scanpos = xsp;
    if (jj_scan_token(417)) {
    jj_scanpos = xsp;
    if (jj_scan_token(421)) {
    jj_scanpos = xsp;
    if (jj_scan_token(442)) {
    jj_scanpos = xsp;
    if (jj_scan_token(446)) {
    jj_scanpos = xsp;
    if (jj_scan_token(451)) {
    jj_scanpos = xsp;
    if (jj_scan_token(457)) {
    jj_scanpos = xsp;
    if (jj_scan_token(462)) {
    jj_scanpos = xsp;
    if (jj_scan_token(470)) {
    jj_scanpos = xsp;
    if (jj_scan_token(473)) {
    jj_scanpos = xsp;
    if (jj_scan_token(477)) {
    jj_scanpos = xsp;
    if (jj_scan_token(485)) {
    jj_scanpos = xsp;
    if (jj_scan_token(489)) {
    jj_scanpos = xsp;
    if (jj_scan_token(494)) {
    jj_scanpos = xsp;
    if (jj_scan_token(503)) {
    jj_scanpos = xsp;
    if (jj_scan_token(512)) {
    jj_scanpos = xsp;
    if (jj_scan_token(515)) {
    jj_scanpos = xsp;
    if (jj_scan_token(518)) {
    jj_scanpos = xsp;
    if (jj_scan_token(521)) {
    jj_scanpos = xsp;
    if (jj_scan_token(524)) {
    jj_scanpos = xsp;
    if (jj_scan_token(527)) {
    jj_scanpos = xsp;
    if (jj_scan_token(530)) {
    jj_scanpos = xsp;
    if (jj_scan_token(533)) {
    jj_scanpos = xsp;
    if (jj_scan_token(536)) {
    jj_scanpos = xsp;
    if (jj_scan_token(538)) {
    jj_scanpos = xsp;
    if (jj_scan_token(542)) {
    jj_scanpos = xsp;
    if (jj_scan_token(545)) {
    jj_scanpos = xsp;
    if (jj_scan_token(548)) {
    jj_scanpos = xsp;
    if (jj_scan_token(551)) {
    jj_scanpos = xsp;
    if (jj_scan_token(554)) {
    jj_scanpos = xsp;
    if (jj_scan_token(557)) {
    jj_scanpos = xsp;
    if (jj_scan_token(560)) {
    jj_scanpos = xsp;
    if (jj_scan_token(569)) {
    jj_scanpos = xsp;
    if (jj_scan_token(574)) {
    jj_scanpos = xsp;
    if (jj_scan_token(588)) {
    jj_scanpos = xsp;
    if (jj_scan_token(597)) {
    jj_scanpos = xsp;
    if (jj_scan_token(601)) {
    jj_scanpos = xsp;
    if (jj_scan_token(604)) {
    jj_scanpos = xsp;
    if (jj_scan_token(612)) {
    jj_scanpos = xsp;
    if (jj_scan_token(620)) {
    jj_scanpos = xsp;
    if (jj_scan_token(626)) {
    jj_scanpos = xsp;
    if (jj_scan_token(634)) {
    jj_scanpos = xsp;
    if (jj_scan_token(638)) {
    jj_scanpos = xsp;
    if (jj_scan_token(649)) {
    jj_scanpos = xsp;
    if (jj_scan_token(662)) {
    jj_scanpos = xsp;
    if (jj_scan_token(664)) { if (!jj_rescan) trace_return("NonReservedKeyWord2of3(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("NonReservedKeyWord2of3(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_316()
 {
    return false;
  }

  private boolean jj_3_79()
 {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3_64()
 {
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3_36()
 {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_390()
 {
    if (jj_scan_token(MATCH_NUMBER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_216()
 {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_64()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) return true;
    }
    return false;
  }

  private boolean jj_3R_389()
 {
    if (jj_scan_token(CLASSIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_305()
 {
    if (!jj_rescan) trace_call("MatchRecognizeFunctionCall(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_389()) {
    jj_scanpos = xsp;
    if (jj_3R_390()) {
    jj_scanpos = xsp;
    if (jj_3_79()) {
    jj_scanpos = xsp;
    if (jj_3_80()) {
    jj_scanpos = xsp;
    if (jj_3R_391()) { if (!jj_rescan) trace_return("MatchRecognizeFunctionCall(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("MatchRecognizeFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_215()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_90()
 {
    if (!jj_rescan) trace_call("MapConstructor(LOOKING AHEAD...)");
    if (jj_scan_token(MAP)) { if (!jj_rescan) trace_return("MapConstructor(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) { if (!jj_rescan) trace_return("MapConstructor(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("MapConstructor(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_110()
 {
    if (!jj_rescan) trace_call("TimestampDiffFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(TIMESTAMPDIFF)) { if (!jj_rescan) trace_return("TimestampDiffFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("TimestampDiffFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_258()) { if (!jj_rescan) trace_return("TimestampDiffFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("TimestampDiffFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_63()
 {
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_381()
 {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_380()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_296()
 {
    if (!jj_rescan) trace_call("ArrayConstructor(LOOKING AHEAD...)");
    if (jj_scan_token(ARRAY)) { if (!jj_rescan) trace_return("ArrayConstructor(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_380()) {
    jj_scanpos = xsp;
    if (jj_3R_381()) { if (!jj_rescan) trace_return("ArrayConstructor(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("ArrayConstructor(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_135()
 {
    if (jj_3R_266()) return true;
    return false;
  }

  private boolean jj_3R_304()
 {
    if (!jj_rescan) trace_call("TimestampAddFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(TIMESTAMPADD)) { if (!jj_rescan) trace_return("TimestampAddFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("TimestampAddFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("TimestampAddFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_2()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3_35()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_379()
 {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_64()
 {
    if (!jj_rescan) trace_call("ParenthesizedQueryOrCommaListWithDefault(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("ParenthesizedQueryOrCommaListWithDefault(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) { if (!jj_rescan) trace_return("ParenthesizedQueryOrCommaListWithDefault(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("ParenthesizedQueryOrCommaListWithDefault(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_62()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_295()
 {
    if (!jj_rescan) trace_call("MultisetConstructor(LOOKING AHEAD...)");
    if (jj_scan_token(MULTISET)) { if (!jj_rescan) trace_return("MultisetConstructor(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_62()) {
    jj_scanpos = xsp;
    if (jj_3R_379()) { if (!jj_rescan) trace_return("MultisetConstructor(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("MultisetConstructor(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_442()
 {
    if (jj_scan_token(TIMESTAMP)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_315()
 {
    if (!jj_rescan) trace_call("JsonArrayAggFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_ARRAYAGG)) { if (!jj_rescan) trace_return("JsonArrayAggFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonArrayAggFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonArrayAggFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_423()
 {
    if (!jj_rescan) trace_call("NonReservedKeyWord1of3(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(9)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(140)) {
    jj_scanpos = xsp;
    if (jj_scan_token(144)) {
    jj_scanpos = xsp;
    if (jj_scan_token(149)) {
    jj_scanpos = xsp;
    if (jj_scan_token(154)) {
    jj_scanpos = xsp;
    if (jj_scan_token(160)) {
    jj_scanpos = xsp;
    if (jj_scan_token(165)) {
    jj_scanpos = xsp;
    if (jj_scan_token(174)) {
    jj_scanpos = xsp;
    if (jj_scan_token(185)) {
    jj_scanpos = xsp;
    if (jj_scan_token(199)) {
    jj_scanpos = xsp;
    if (jj_scan_token(206)) {
    jj_scanpos = xsp;
    if (jj_scan_token(210)) {
    jj_scanpos = xsp;
    if (jj_scan_token(219)) {
    jj_scanpos = xsp;
    if (jj_scan_token(224)) {
    jj_scanpos = xsp;
    if (jj_scan_token(235)) {
    jj_scanpos = xsp;
    if (jj_scan_token(240)) {
    jj_scanpos = xsp;
    if (jj_scan_token(247)) {
    jj_scanpos = xsp;
    if (jj_scan_token(258)) {
    jj_scanpos = xsp;
    if (jj_scan_token(262)) {
    jj_scanpos = xsp;
    if (jj_scan_token(272)) {
    jj_scanpos = xsp;
    if (jj_scan_token(276)) {
    jj_scanpos = xsp;
    if (jj_scan_token(279)) {
    jj_scanpos = xsp;
    if (jj_scan_token(290)) {
    jj_scanpos = xsp;
    if (jj_scan_token(300)) {
    jj_scanpos = xsp;
    if (jj_scan_token(305)) {
    jj_scanpos = xsp;
    if (jj_scan_token(314)) {
    jj_scanpos = xsp;
    if (jj_scan_token(319)) {
    jj_scanpos = xsp;
    if (jj_scan_token(328)) {
    jj_scanpos = xsp;
    if (jj_scan_token(332)) {
    jj_scanpos = xsp;
    if (jj_scan_token(344)) {
    jj_scanpos = xsp;
    if (jj_scan_token(352)) {
    jj_scanpos = xsp;
    if (jj_scan_token(366)) {
    jj_scanpos = xsp;
    if (jj_scan_token(371)) {
    jj_scanpos = xsp;
    if (jj_scan_token(379)) {
    jj_scanpos = xsp;
    if (jj_scan_token(383)) {
    jj_scanpos = xsp;
    if (jj_scan_token(386)) {
    jj_scanpos = xsp;
    if (jj_scan_token(390)) {
    jj_scanpos = xsp;
    if (jj_scan_token(393)) {
    jj_scanpos = xsp;
    if (jj_scan_token(404)) {
    jj_scanpos = xsp;
    if (jj_scan_token(414)) {
    jj_scanpos = xsp;
    if (jj_scan_token(420)) {
    jj_scanpos = xsp;
    if (jj_scan_token(440)) {
    jj_scanpos = xsp;
    if (jj_scan_token(445)) {
    jj_scanpos = xsp;
    if (jj_scan_token(450)) {
    jj_scanpos = xsp;
    if (jj_scan_token(453)) {
    jj_scanpos = xsp;
    if (jj_scan_token(461)) {
    jj_scanpos = xsp;
    if (jj_scan_token(465)) {
    jj_scanpos = xsp;
    if (jj_scan_token(472)) {
    jj_scanpos = xsp;
    if (jj_scan_token(476)) {
    jj_scanpos = xsp;
    if (jj_scan_token(482)) {
    jj_scanpos = xsp;
    if (jj_scan_token(488)) {
    jj_scanpos = xsp;
    if (jj_scan_token(491)) {
    jj_scanpos = xsp;
    if (jj_scan_token(499)) {
    jj_scanpos = xsp;
    if (jj_scan_token(506)) {
    jj_scanpos = xsp;
    if (jj_scan_token(514)) {
    jj_scanpos = xsp;
    if (jj_scan_token(517)) {
    jj_scanpos = xsp;
    if (jj_scan_token(520)) {
    jj_scanpos = xsp;
    if (jj_scan_token(523)) {
    jj_scanpos = xsp;
    if (jj_scan_token(526)) {
    jj_scanpos = xsp;
    if (jj_scan_token(529)) {
    jj_scanpos = xsp;
    if (jj_scan_token(532)) {
    jj_scanpos = xsp;
    if (jj_scan_token(535)) {
    jj_scanpos = xsp;
    if (jj_scan_token(539)) {
    jj_scanpos = xsp;
    if (jj_scan_token(541)) {
    jj_scanpos = xsp;
    if (jj_scan_token(544)) {
    jj_scanpos = xsp;
    if (jj_scan_token(547)) {
    jj_scanpos = xsp;
    if (jj_scan_token(550)) {
    jj_scanpos = xsp;
    if (jj_scan_token(553)) {
    jj_scanpos = xsp;
    if (jj_scan_token(556)) {
    jj_scanpos = xsp;
    if (jj_scan_token(559)) {
    jj_scanpos = xsp;
    if (jj_scan_token(564)) {
    jj_scanpos = xsp;
    if (jj_scan_token(571)) {
    jj_scanpos = xsp;
    if (jj_scan_token(586)) {
    jj_scanpos = xsp;
    if (jj_scan_token(592)) {
    jj_scanpos = xsp;
    if (jj_scan_token(600)) {
    jj_scanpos = xsp;
    if (jj_scan_token(603)) {
    jj_scanpos = xsp;
    if (jj_scan_token(611)) {
    jj_scanpos = xsp;
    if (jj_scan_token(619)) {
    jj_scanpos = xsp;
    if (jj_scan_token(622)) {
    jj_scanpos = xsp;
    if (jj_scan_token(633)) {
    jj_scanpos = xsp;
    if (jj_scan_token(636)) {
    jj_scanpos = xsp;
    if (jj_scan_token(640)) {
    jj_scanpos = xsp;
    if (jj_scan_token(652)) {
    jj_scanpos = xsp;
    if (jj_scan_token(663)) { if (!jj_rescan) trace_return("NonReservedKeyWord1of3(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("NonReservedKeyWord1of3(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_441()
 {
    if (jj_scan_token(TIME)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3_34()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_440()
 {
    if (jj_scan_token(DATE)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_439()
 {
    if (jj_scan_token(LBRACE_TS)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_93()
 {
    if (!jj_rescan) trace_call("ExpressionCommaList(LOOKING AHEAD...)");
    if (jj_3R_42()) { if (!jj_rescan) trace_return("ExpressionCommaList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ExpressionCommaList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_438()
 {
    if (jj_scan_token(LBRACE_T)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_76()
 {
    if (!jj_rescan) trace_call("ParenthesizedQueryOrCommaList(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("ParenthesizedQueryOrCommaList(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_41()) { if (!jj_rescan) trace_return("ParenthesizedQueryOrCommaList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ParenthesizedQueryOrCommaList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_411()
 {
    if (!jj_rescan) trace_call("DateTimeLiteral(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_437()) {
    jj_scanpos = xsp;
    if (jj_3R_438()) {
    jj_scanpos = xsp;
    if (jj_3R_439()) {
    jj_scanpos = xsp;
    if (jj_3R_440()) {
    jj_scanpos = xsp;
    if (jj_3R_441()) {
    jj_scanpos = xsp;
    if (jj_3R_442()) { if (!jj_rescan) trace_return("DateTimeLiteral(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("DateTimeLiteral(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_437()
 {
    if (jj_scan_token(LBRACE_D)) return true;
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3_33()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3_32()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_107()
 {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_137()
 {
    if (jj_scan_token(CUBE)) return true;
    return false;
  }

  private boolean jj_3R_136()
 {
    if (jj_scan_token(ROLLUP)) return true;
    return false;
  }

  private boolean jj_3_78()
 {
    if (jj_3R_106()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_107()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_31()
 {
    if (jj_scan_token(GROUPING)) return true;
    if (jj_scan_token(SETS)) return true;
    return false;
  }

  private boolean jj_3R_67()
 {
    if (!jj_rescan) trace_call("GroupingElement(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3_33()) { if (!jj_rescan) trace_return("GroupingElement(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("GroupingElement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_314()
 {
    if (!jj_rescan) trace_call("JsonArrayFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_ARRAY)) { if (!jj_rescan) trace_return("JsonArrayFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonArrayFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonArrayFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_452()
 {
    if (jj_scan_token(UESCAPE)) return true;
    return false;
  }

  private boolean jj_3_30()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_451()
 {
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_61()
 {
    if (!jj_rescan) trace_call("ParenthesizedExpression(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("ParenthesizedExpression(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_41()) { if (!jj_rescan) trace_return("ParenthesizedExpression(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ParenthesizedExpression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_313()
 {
    if (!jj_rescan) trace_call("JsonObjectAggFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_OBJECTAGG)) { if (!jj_rescan) trace_return("JsonObjectAggFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonObjectAggFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonObjectAggFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_394()
 {
    if (jj_3R_421()) return true;
    return false;
  }

  private boolean jj_3R_393()
 {
    if (jj_3R_420()) return true;
    return false;
  }

  private boolean jj_3R_318()
 {
    if (!jj_rescan) trace_call("LeafQuery(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_392()) {
    jj_scanpos = xsp;
    if (jj_3R_393()) {
    jj_scanpos = xsp;
    if (jj_3R_394()) { if (!jj_rescan) trace_return("LeafQuery(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("LeafQuery(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_392()
 {
    if (jj_3R_419()) return true;
    return false;
  }

  private boolean jj_3R_450()
 {
    if (jj_scan_token(UNICODE_STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_312()
 {
    if (!jj_rescan) trace_call("JsonDepthFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_DEPTH)) { if (!jj_rescan) trace_return("JsonDepthFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonDepthFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonDepthFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_449()
 {
    if (jj_scan_token(PREFIXED_STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_432()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_449()) {
    jj_scanpos = xsp;
    if (jj_scan_token(674)) {
    jj_scanpos = xsp;
    if (jj_3R_450()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_451()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_452()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_311()
 {
    if (!jj_rescan) trace_call("JsonTypeFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_TYPE)) { if (!jj_rescan) trace_return("JsonTypeFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonTypeFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonTypeFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_422()
 {
    if (!jj_rescan) trace_call("NonReservedKeyWord0of3(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(1)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(8)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(136)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(146)) {
    jj_scanpos = xsp;
    if (jj_scan_token(152)) {
    jj_scanpos = xsp;
    if (jj_scan_token(157)) {
    jj_scanpos = xsp;
    if (jj_scan_token(164)) {
    jj_scanpos = xsp;
    if (jj_scan_token(169)) {
    jj_scanpos = xsp;
    if (jj_scan_token(181)) {
    jj_scanpos = xsp;
    if (jj_scan_token(187)) {
    jj_scanpos = xsp;
    if (jj_scan_token(204)) {
    jj_scanpos = xsp;
    if (jj_scan_token(209)) {
    jj_scanpos = xsp;
    if (jj_scan_token(218)) {
    jj_scanpos = xsp;
    if (jj_scan_token(223)) {
    jj_scanpos = xsp;
    if (jj_scan_token(231)) {
    jj_scanpos = xsp;
    if (jj_scan_token(237)) {
    jj_scanpos = xsp;
    if (jj_scan_token(244)) {
    jj_scanpos = xsp;
    if (jj_scan_token(251)) {
    jj_scanpos = xsp;
    if (jj_scan_token(261)) {
    jj_scanpos = xsp;
    if (jj_scan_token(265)) {
    jj_scanpos = xsp;
    if (jj_scan_token(270)) {
    jj_scanpos = xsp;
    if (jj_scan_token(278)) {
    jj_scanpos = xsp;
    if (jj_scan_token(284)) {
    jj_scanpos = xsp;
    if (jj_scan_token(292)) {
    jj_scanpos = xsp;
    if (jj_scan_token(303)) {
    jj_scanpos = xsp;
    if (jj_scan_token(318)) {
    jj_scanpos = xsp;
    if (jj_scan_token(316)) {
    jj_scanpos = xsp;
    if (jj_scan_token(323)) {
    jj_scanpos = xsp;
    if (jj_scan_token(331)) {
    jj_scanpos = xsp;
    if (jj_scan_token(338)) {
    jj_scanpos = xsp;
    if (jj_scan_token(351)) {
    jj_scanpos = xsp;
    if (jj_scan_token(357)) {
    jj_scanpos = xsp;
    if (jj_scan_token(370)) {
    jj_scanpos = xsp;
    if (jj_scan_token(375)) {
    jj_scanpos = xsp;
    if (jj_scan_token(382)) {
    jj_scanpos = xsp;
    if (jj_scan_token(385)) {
    jj_scanpos = xsp;
    if (jj_scan_token(388)) {
    jj_scanpos = xsp;
    if (jj_scan_token(392)) {
    jj_scanpos = xsp;
    if (jj_scan_token(403)) {
    jj_scanpos = xsp;
    if (jj_scan_token(411)) {
    jj_scanpos = xsp;
    if (jj_scan_token(418)) {
    jj_scanpos = xsp;
    if (jj_scan_token(424)) {
    jj_scanpos = xsp;
    if (jj_scan_token(443)) {
    jj_scanpos = xsp;
    if (jj_scan_token(449)) {
    jj_scanpos = xsp;
    if (jj_scan_token(452)) {
    jj_scanpos = xsp;
    if (jj_scan_token(460)) {
    jj_scanpos = xsp;
    if (jj_scan_token(463)) {
    jj_scanpos = xsp;
    if (jj_scan_token(471)) {
    jj_scanpos = xsp;
    if (jj_scan_token(475)) {
    jj_scanpos = xsp;
    if (jj_scan_token(481)) {
    jj_scanpos = xsp;
    if (jj_scan_token(487)) {
    jj_scanpos = xsp;
    if (jj_scan_token(490)) {
    jj_scanpos = xsp;
    if (jj_scan_token(498)) {
    jj_scanpos = xsp;
    if (jj_scan_token(504)) {
    jj_scanpos = xsp;
    if (jj_scan_token(513)) {
    jj_scanpos = xsp;
    if (jj_scan_token(516)) {
    jj_scanpos = xsp;
    if (jj_scan_token(519)) {
    jj_scanpos = xsp;
    if (jj_scan_token(522)) {
    jj_scanpos = xsp;
    if (jj_scan_token(525)) {
    jj_scanpos = xsp;
    if (jj_scan_token(528)) {
    jj_scanpos = xsp;
    if (jj_scan_token(531)) {
    jj_scanpos = xsp;
    if (jj_scan_token(534)) {
    jj_scanpos = xsp;
    if (jj_scan_token(537)) {
    jj_scanpos = xsp;
    if (jj_scan_token(540)) {
    jj_scanpos = xsp;
    if (jj_scan_token(543)) {
    jj_scanpos = xsp;
    if (jj_scan_token(546)) {
    jj_scanpos = xsp;
    if (jj_scan_token(549)) {
    jj_scanpos = xsp;
    if (jj_scan_token(552)) {
    jj_scanpos = xsp;
    if (jj_scan_token(555)) {
    jj_scanpos = xsp;
    if (jj_scan_token(558)) {
    jj_scanpos = xsp;
    if (jj_scan_token(563)) {
    jj_scanpos = xsp;
    if (jj_scan_token(570)) {
    jj_scanpos = xsp;
    if (jj_scan_token(584)) {
    jj_scanpos = xsp;
    if (jj_scan_token(591)) {
    jj_scanpos = xsp;
    if (jj_scan_token(599)) {
    jj_scanpos = xsp;
    if (jj_scan_token(602)) {
    jj_scanpos = xsp;
    if (jj_scan_token(610)) {
    jj_scanpos = xsp;
    if (jj_scan_token(617)) {
    jj_scanpos = xsp;
    if (jj_scan_token(621)) {
    jj_scanpos = xsp;
    if (jj_scan_token(631)) {
    jj_scanpos = xsp;
    if (jj_scan_token(635)) {
    jj_scanpos = xsp;
    if (jj_scan_token(639)) {
    jj_scanpos = xsp;
    if (jj_scan_token(651)) {
    jj_scanpos = xsp;
    if (jj_scan_token(661)) {
    jj_scanpos = xsp;
    if (jj_scan_token(666)) { if (!jj_rescan) trace_return("NonReservedKeyWord0of3(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("NonReservedKeyWord0of3(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_397()
 {
    if (jj_3R_424()) return true;
    return false;
  }

  private boolean jj_3R_396()
 {
    if (jj_3R_423()) return true;
    return false;
  }

  private boolean jj_3R_395()
 {
    if (jj_3R_422()) return true;
    return false;
  }

  private boolean jj_3R_448()
 {
    if (jj_scan_token(QUOTED_STRING)) return true;
    return false;
  }

  private boolean jj_3R_319()
 {
    if (!jj_rescan) trace_call("NonReservedKeyWord(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) {
    jj_scanpos = xsp;
    if (jj_3R_397()) { if (!jj_rescan) trace_return("NonReservedKeyWord(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("NonReservedKeyWord(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_29()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_66()
 {
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_40()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_65()
 {
    if (jj_scan_token(ROW)) return true;
    return false;
  }

  private boolean jj_3_28()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    }
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3_77()
 {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_409()
 {
    if (!jj_rescan) trace_call("StringLiteral(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_431()) {
    jj_scanpos = xsp;
    if (jj_3R_432()) { if (!jj_rescan) trace_return("StringLiteral(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("StringLiteral(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_431()
 {
    if (jj_scan_token(BINARY_STRING_LITERAL)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_448()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_27()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(ROW)) return true;
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_310()
 {
    if (!jj_rescan) trace_call("JsonObjectFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_OBJECT)) { if (!jj_rescan) trace_return("JsonObjectFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonObjectFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonObjectFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_63()
 {
    if (!jj_rescan) trace_call("RowConstructor(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3_29()) { if (!jj_rescan) trace_return("RowConstructor(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("RowConstructor(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_41()
 {
    if (!jj_rescan) trace_call("OrderedQueryOrExpr(LOOKING AHEAD...)");
    if (jj_3R_113()) { if (!jj_rescan) trace_return("OrderedQueryOrExpr(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("OrderedQueryOrExpr(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_26()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_436()
 {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_435()
 {
    if (jj_scan_token(UNKNOWN)) return true;
    return false;
  }

  private boolean jj_3R_434()
 {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_410()
 {
    if (!jj_rescan) trace_call("SpecialLiteral(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_433()) {
    jj_scanpos = xsp;
    if (jj_3R_434()) {
    jj_scanpos = xsp;
    if (jj_3R_435()) {
    jj_scanpos = xsp;
    if (jj_3R_436()) { if (!jj_rescan) trace_return("SpecialLiteral(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    { if (!jj_rescan) trace_return("SpecialLiteral(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_433()
 {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_249()
 {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_430()
 {
    if (jj_3R_259()) return true;
    return false;
  }

  private boolean jj_3R_247()
 {
    if (jj_scan_token(KEY)) return true;
    return false;
  }

  private boolean jj_3R_429()
 {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_259()) return true;
    return false;
  }

  private boolean jj_3R_420()
 {
    if (!jj_rescan) trace_call("TableConstructor(LOOKING AHEAD...)");
    if (jj_scan_token(VALUES)) { if (!jj_rescan) trace_return("TableConstructor(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("TableConstructor(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_105()
 {
    if (!jj_rescan) trace_call("JsonNameAndValue(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) jj_scanpos = xsp;
    if (jj_3R_248()) { if (!jj_rescan) trace_return("JsonNameAndValue(LOOKAHEAD FAILED)"); return true; }
    xsp = jj_scanpos;
    if (jj_scan_token(641)) {
    jj_scanpos = xsp;
    if (jj_3R_249()) { if (!jj_rescan) trace_return("JsonNameAndValue(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("JsonNameAndValue(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_408()
 {
    if (!jj_rescan) trace_call("NumericLiteral(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_428()) {
    jj_scanpos = xsp;
    if (jj_3R_429()) {
    jj_scanpos = xsp;
    if (jj_3R_430()) { if (!jj_rescan) trace_return("NumericLiteral(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("NumericLiteral(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_428()
 {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_259()) return true;
    return false;
  }

  private boolean jj_3R_248()
 {
    if (!jj_rescan) trace_call("JsonName(LOOKING AHEAD...)");
    if (jj_3R_42()) { if (!jj_rescan) trace_return("JsonName(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonName(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_421()
 {
    if (!jj_rescan) trace_call("ExplicitTable(LOOKING AHEAD...)");
    if (jj_scan_token(TABLE)) { if (!jj_rescan) trace_return("ExplicitTable(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ExplicitTable(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_348()
 {
    if (jj_scan_token(APPROX_NUMERIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_347()
 {
    if (jj_scan_token(DECIMAL_NUMERIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_259()
 {
    if (!jj_rescan) trace_call("UnsignedNumericLiteral(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_346()) {
    jj_scanpos = xsp;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) { if (!jj_rescan) trace_return("UnsignedNumericLiteral(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("UnsignedNumericLiteral(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_346()
 {
    if (jj_scan_token(UNSIGNED_INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_375()
 {
    if (jj_3R_412()) return true;
    return false;
  }

  private boolean jj_3R_374()
 {
    if (jj_3R_411()) return true;
    return false;
  }

  private boolean jj_3R_373()
 {
    if (jj_3R_410()) return true;
    return false;
  }

  private boolean jj_3R_372()
 {
    if (jj_3R_409()) return true;
    return false;
  }

  private boolean jj_3R_371()
 {
    if (jj_3R_408()) return true;
    return false;
  }

  private boolean jj_3R_293()
 {
    if (!jj_rescan) trace_call("Literal(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_371()) {
    jj_scanpos = xsp;
    if (jj_3R_372()) {
    jj_scanpos = xsp;
    if (jj_3R_373()) {
    jj_scanpos = xsp;
    if (jj_3R_374()) {
    jj_scanpos = xsp;
    if (jj_3R_375()) { if (!jj_rescan) trace_return("Literal(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("Literal(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_309()
 {
    if (!jj_rescan) trace_call("JsonQueryFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_QUERY)) { if (!jj_rescan) trace_return("JsonQueryFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonQueryFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonQueryFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_76()
 {
    if (jj_scan_token(WITH)) return true;
    if (jj_scan_token(CONDITIONAL)) return true;
    return false;
  }

  private boolean jj_3R_269()
 {
    if (!jj_rescan) trace_call("CompoundIdentifierType(LOOKING AHEAD...)");
    if (jj_3R_44()) { if (!jj_rescan) trace_return("CompoundIdentifierType(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("CompoundIdentifierType(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_75()
 {
    if (jj_scan_token(EMPTY)) return true;
    if (jj_scan_token(ARRAY)) return true;
    return false;
  }

  private boolean jj_3R_268()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_119()
 {
    if (!jj_rescan) trace_call("ColumnType(LOOKING AHEAD...)");
    if (jj_3R_44()) { if (!jj_rescan) trace_return("ColumnType(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_267()) { if (!jj_rescan) trace_return("ColumnType(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_268()) jj_scanpos = xsp;
    { if (!jj_rescan) trace_return("ColumnType(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_120()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_47()
 {
    if (!jj_rescan) trace_call("ExtendList(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("ExtendList(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_119()) { if (!jj_rescan) trace_return("ExtendList(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_120()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RPAREN)) { if (!jj_rescan) trace_return("ExtendList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ExtendList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_308()
 {
    if (!jj_rescan) trace_call("JsonPrettyFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_PRETTY)) { if (!jj_rescan) trace_return("JsonPrettyFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonPrettyFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonPrettyFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_387()
 {
    if (jj_scan_token(CURRENT)) return true;
    return false;
  }

  private boolean jj_3R_386()
 {
    if (jj_scan_token(NEXT)) return true;
    return false;
  }

  private boolean jj_3R_302()
 {
    if (!jj_rescan) trace_call("SequenceExpression(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_386()) {
    jj_scanpos = xsp;
    if (jj_3R_387()) { if (!jj_rescan) trace_return("SequenceExpression(LOOKAHEAD FAILED)"); return true; }
    }
    if (jj_scan_token(VALUE)) { if (!jj_rescan) trace_return("SequenceExpression(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SequenceExpression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_307()
 {
    if (!jj_rescan) trace_call("JsonValueFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_VALUE)) { if (!jj_rescan) trace_return("JsonValueFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonValueFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonValueFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_385()
 {
    if (jj_scan_token(WHEN)) return true;
    return false;
  }

  private boolean jj_3_61()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_301()
 {
    if (!jj_rescan) trace_call("CaseExpression(LOOKING AHEAD...)");
    if (jj_scan_token(CASE)) { if (!jj_rescan) trace_return("CaseExpression(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_61()) jj_scanpos = xsp;
    if (jj_3R_385()) { if (!jj_rescan) trace_return("CaseExpression(LOOKAHEAD FAILED)"); return true; }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_385()) { jj_scanpos = xsp; break; }
    }
    { if (!jj_rescan) trace_return("CaseExpression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_191()
 {
    if (jj_3R_302()) return true;
    return false;
  }

  private boolean jj_3_60()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(505)) jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_190()
 {
    if (jj_3R_301()) return true;
    return false;
  }

  private boolean jj_3R_189()
 {
    if (jj_3R_300()) return true;
    return false;
  }

  private boolean jj_3R_188()
 {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_187()
 {
    if (jj_3R_299()) return true;
    return false;
  }

  private boolean jj_3R_186()
 {
    if (jj_3R_298()) return true;
    return false;
  }

  private boolean jj_3_25()
 {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_185()
 {
    if (jj_3R_297()) return true;
    return false;
  }

  private boolean jj_3_59()
 {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_306()
 {
    if (!jj_rescan) trace_call("JsonExistsFunctionCall(LOOKING AHEAD...)");
    if (jj_scan_token(JSON_EXISTS)) { if (!jj_rescan) trace_return("JsonExistsFunctionCall(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("JsonExistsFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonExistsFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_184()
 {
    if (jj_3R_296()) return true;
    return false;
  }

  private boolean jj_3R_183()
 {
    if (jj_3R_295()) return true;
    return false;
  }

  private boolean jj_3R_404()
 {
    if (jj_scan_token(LATERAL)) return true;
    return false;
  }

  private boolean jj_3R_182()
 {
    if (jj_3R_294()) return true;
    return false;
  }

  private boolean jj_3R_357()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_404()) jj_scanpos = xsp;
    if (jj_scan_token(TABLE)) return true;
    return false;
  }

  private boolean jj_3_58()
 {
    if (jj_3R_89()) return true;
    return false;
  }

  private boolean jj_3R_181()
 {
    if (jj_3R_260()) return true;
    return false;
  }

  private boolean jj_3R_180()
 {
    if (jj_3R_293()) return true;
    return false;
  }

  private boolean jj_3R_356()
 {
    if (jj_scan_token(UNNEST)) return true;
    return false;
  }

  private boolean jj_3R_88()
 {
    if (!jj_rescan) trace_call("AtomicRowExpression(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3_58()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3_59()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) { if (!jj_rescan) trace_return("AtomicRowExpression(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("AtomicRowExpression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_112()
 {
    if (jj_3R_260()) return true;
    return false;
  }

  private boolean jj_3R_303()
 {
    if (!jj_rescan) trace_call("FloorCeilOptions(LOOKING AHEAD...)");
    if (jj_3R_388()) { if (!jj_rescan) trace_return("FloorCeilOptions(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("FloorCeilOptions(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_111()
 {
    if (jj_3R_259()) return true;
    return false;
  }

  private boolean jj_3R_60()
 {
    if (jj_scan_token(LATERAL)) return true;
    return false;
  }

  private boolean jj_3R_59()
 {
    if (jj_3R_133()) return true;
    return false;
  }

  private boolean jj_3R_40()
 {
    if (!jj_rescan) trace_call("UnsignedNumericLiteralOrParam(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) { if (!jj_rescan) trace_return("UnsignedNumericLiteralOrParam(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("UnsignedNumericLiteralOrParam(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_24()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    return false;
  }

  private boolean jj_3R_58()
 {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3R_104()
 {
    if (!jj_rescan) trace_call("ExtendedBuiltinFunctionCall(LOOKING AHEAD...)");
    if (jj_3R_134()) { if (!jj_rescan) trace_return("ExtendedBuiltinFunctionCall(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ExtendedBuiltinFunctionCall(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_56()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(193)) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3_23()
 {
    if (jj_3R_44()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) jj_scanpos = xsp;
    if (jj_3R_57()) return true;
    xsp = jj_scanpos;
    if (jj_3R_58()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_270()
 {
    if (!jj_rescan) trace_call("TableRef2(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3R_356()) {
    jj_scanpos = xsp;
    if (jj_3R_357()) {
    jj_scanpos = xsp;
    if (jj_3_25()) { if (!jj_rescan) trace_return("TableRef2(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("TableRef2(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_57()
 {
    if (jj_scan_token(IMMEDIATELY)) return true;
    if (jj_scan_token(PRECEDES)) return true;
    return false;
  }

  private boolean jj_3R_57()
 {
    if (!jj_rescan) trace_call("TableOverOpt(LOOKING AHEAD...)");
    { if (!jj_rescan) trace_return("TableOverOpt(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_250()
 {
    if (jj_3R_324()) return true;
    return false;
  }

  private boolean jj_3R_62()
 {
    if (!jj_rescan) trace_call("ExtendedTableRef(LOOKING AHEAD...)");
    if (jj_3R_134()) { if (!jj_rescan) trace_return("ExtendedTableRef(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ExtendedTableRef(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_106()
 {
    if (!jj_rescan) trace_call("JsonValueExpression(LOOKING AHEAD...)");
    if (jj_3R_42()) { if (!jj_rescan) trace_return("JsonValueExpression(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_250()) jj_scanpos = xsp;
    { if (!jj_rescan) trace_return("JsonValueExpression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_123()
 {
    if (!jj_rescan) trace_call("TableRef(LOOKING AHEAD...)");
    if (jj_3R_270()) { if (!jj_rescan) trace_return("TableRef(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("TableRef(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_53()
 {
    if (jj_scan_token(OUTER)) return true;
    if (jj_scan_token(APPLY)) return true;
    return false;
  }

  private boolean jj_3R_324()
 {
    if (!jj_rescan) trace_call("JsonInputClause(LOOKING AHEAD...)");
    if (jj_scan_token(FORMAT)) { if (!jj_rescan) trace_return("JsonInputClause(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("JsonInputClause(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_52()
 {
    if (jj_scan_token(CROSS)) return true;
    if (jj_scan_token(APPLY)) return true;
    return false;
  }

  private boolean jj_3_54()
 {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_51()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_123()) return true;
    return false;
  }

  private boolean jj_3R_273()
 {
    if (jj_scan_token(ROW)) return true;
    return false;
  }

  private boolean jj_3R_139()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_273()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_214()
 {
    if (jj_3R_315()) return true;
    return false;
  }

  private boolean jj_3R_213()
 {
    if (jj_3R_314()) return true;
    return false;
  }

  private boolean jj_3R_212()
 {
    if (jj_3R_313()) return true;
    return false;
  }

  private boolean jj_3R_211()
 {
    if (jj_3R_312()) return true;
    return false;
  }

  private boolean jj_3R_210()
 {
    if (jj_3R_311()) return true;
    return false;
  }

  private boolean jj_3_56()
 {
    if (jj_scan_token(ROW)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_209()
 {
    if (jj_3R_310()) return true;
    return false;
  }

  private boolean jj_3R_138()
 {
    if (jj_3R_272()) return true;
    return false;
  }

  private boolean jj_3R_208()
 {
    if (jj_3R_309()) return true;
    return false;
  }

  private boolean jj_3R_207()
 {
    if (jj_3R_308()) return true;
    return false;
  }

  private boolean jj_3R_206()
 {
    if (jj_3R_307()) return true;
    return false;
  }

  private boolean jj_3_55()
 {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_72()
 {
    if (!jj_rescan) trace_call("Expression3(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_55()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3_56()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) { if (!jj_rescan) trace_return("Expression3(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    { if (!jj_rescan) trace_return("Expression3(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_205()
 {
    if (jj_3R_306()) return true;
    return false;
  }

  private boolean jj_3R_204()
 {
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3_74()
 {
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_203()
 {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_202()
 {
    if (jj_3R_304()) return true;
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_280()
 {
    if (jj_scan_token(NE2)) return true;
    return false;
  }

  private boolean jj_3R_279()
 {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  private boolean jj_3R_103()
 {
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_278()
 {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3R_277()
 {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3R_276()
 {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_275()
 {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_102()
 {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  private boolean jj_3R_140()
 {
    if (!jj_rescan) trace_call("comp(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) {
    jj_scanpos = xsp;
    if (jj_3R_276()) {
    jj_scanpos = xsp;
    if (jj_3R_277()) {
    jj_scanpos = xsp;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) {
    jj_scanpos = xsp;
    if (jj_3R_280()) { if (!jj_rescan) trace_return("comp(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("comp(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_274()
 {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3_72()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_246()
 {
    if (jj_scan_token(LEADING)) return true;
    return false;
  }

  private boolean jj_3R_399()
 {
    return false;
  }

  private boolean jj_3R_245()
 {
    if (jj_scan_token(TRAILING)) return true;
    return false;
  }

  private boolean jj_3R_86()
 {
    if (jj_3R_173()) return true;
    return false;
  }

  private boolean jj_3R_101()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_244()
 {
    if (jj_scan_token(BOTH)) return true;
    return false;
  }

  private boolean jj_3_48()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3_73()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_101()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_72()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    return false;
  }

  private boolean jj_3R_85()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_201()
 {
    if (jj_scan_token(TRIM)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_52()
 {
    if (jj_3R_84()) return true;
    if (jj_3R_79()) return true;
    return false;
  }

  private boolean jj_3_47()
 {
    if (jj_scan_token(ESCAPE)) return true;
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_82()
 {
    if (jj_scan_token(SIMILAR)) return true;
    if (jj_scan_token(TO)) return true;
    return false;
  }

  private boolean jj_3R_147()
 {
    if (jj_scan_token(SIMILAR)) return true;
    return false;
  }

  private boolean jj_3R_200()
 {
    if (jj_scan_token(SUBSTRING)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_81()
 {
    if (jj_scan_token(LIKE)) return true;
    return false;
  }

  private boolean jj_3R_146()
 {
    if (jj_scan_token(LIKE)) return true;
    return false;
  }

  private boolean jj_3R_199()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) return true;
    }
    if (jj_3R_303()) return true;
    return false;
  }

  private boolean jj_3R_80()
 {
    if (jj_scan_token(NOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) return true;
    }
    return false;
  }

  private boolean jj_3R_198()
 {
    if (jj_scan_token(FLOOR)) return true;
    if (jj_3R_303()) return true;
    return false;
  }

  private boolean jj_3_51()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    }
    }
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_144()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_281()) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) return true;
    }
    return false;
  }

  private boolean jj_3R_281()
 {
    if (jj_scan_token(SYMMETRIC)) return true;
    return false;
  }

  private boolean jj_3R_131()
 {
    if (jj_scan_token(CROSS)) return true;
    return false;
  }

  private boolean jj_3R_130()
 {
    if (jj_scan_token(FULL)) return true;
    return false;
  }

  private boolean jj_3R_197()
 {
    if (jj_scan_token(OVERLAY)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_78()
 {
    if (jj_scan_token(BETWEEN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_129()
 {
    if (jj_scan_token(RIGHT)) return true;
    return false;
  }

  private boolean jj_3R_128()
 {
    if (jj_scan_token(LEFT)) return true;
    return false;
  }

  private boolean jj_3R_127()
 {
    if (jj_scan_token(INNER)) return true;
    return false;
  }

  private boolean jj_3R_126()
 {
    if (jj_scan_token(JOIN)) return true;
    return false;
  }

  private boolean jj_3R_77()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(BETWEEN)) return true;
    return false;
  }

  private boolean jj_3R_55()
 {
    if (!jj_rescan) trace_call("JoinType(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) { if (!jj_rescan) trace_return("JoinType(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("JoinType(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3_50()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    }
    if (jj_3R_79()) return true;
    return false;
  }

  private boolean jj_3R_125()
 {
    return false;
  }

  private boolean jj_3R_124()
 {
    if (jj_scan_token(NATURAL)) return true;
    return false;
  }

  private boolean jj_3R_54()
 {
    if (!jj_rescan) trace_call("Natural(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) { if (!jj_rescan) trace_return("Natural(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("Natural(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_196()
 {
    if (jj_scan_token(TRANSLATE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_143()
 {
    if (jj_scan_token(ALL)) return true;
    return false;
  }

  private boolean jj_3R_142()
 {
    if (jj_scan_token(ANY)) return true;
    return false;
  }

  private boolean jj_3R_141()
 {
    if (jj_scan_token(SOME)) return true;
    return false;
  }

  private boolean jj_3R_195()
 {
    if (jj_scan_token(CONVERT)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_75()
 {
    if (jj_3R_140()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_74()
 {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_73()
 {
    if (jj_scan_token(NOT)) return true;
    if (jj_scan_token(IN)) return true;
    return false;
  }

  private boolean jj_3R_194()
 {
    if (jj_scan_token(POSITION)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_49()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    }
    if (jj_3R_76()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SqlParserImplTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[333];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static private int[] jj_la1_8;
  static private int[] jj_la1_9;
  static private int[] jj_la1_10;
  static private int[] jj_la1_11;
  static private int[] jj_la1_12;
  static private int[] jj_la1_13;
  static private int[] jj_la1_14;
  static private int[] jj_la1_15;
  static private int[] jj_la1_16;
  static private int[] jj_la1_17;
  static private int[] jj_la1_18;
  static private int[] jj_la1_19;
  static private int[] jj_la1_20;
  static private int[] jj_la1_21;
  static private int[] jj_la1_22;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	   jj_la1_init_3();
	   jj_la1_init_4();
	   jj_la1_init_5();
	   jj_la1_init_6();
	   jj_la1_init_7();
	   jj_la1_init_8();
	   jj_la1_init_9();
	   jj_la1_init_10();
	   jj_la1_init_11();
	   jj_la1_init_12();
	   jj_la1_init_13();
	   jj_la1_init_14();
	   jj_la1_init_15();
	   jj_la1_init_16();
	   jj_la1_init_17();
	   jj_la1_init_18();
	   jj_la1_init_19();
	   jj_la1_init_20();
	   jj_la1_init_21();
	   jj_la1_init_22();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x400,0x0,0x0,0x0,0x2000,0x0,0x0,0x400,0x400,0x0,0x0,0x200000,0x0,0x0,0x400,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x636243fa,0x0,0x0,0x200000,0x636243fa,0x0,0x0,0x0,0x200000,0x636243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x636243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x636243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634343fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,0x0,0x400000,0x400000,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x634243fa,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10400,0x0,0x4000000,0x4000000,0x4000000,0x4000000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x634243fa,0x0,0x0,0x0,0x634243fa,0x634247fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634343fa,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x80000,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x8,0x8,0x0,0x8,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x634243fa,0x0,0x0,0x634243fa,0x0,0x634243fe,0x4,0x0,0x634243fe,0x0,0x0,0x634243fe,0x400,0x400,0x0,0x400,0x0,0x400,0x400,0x400,0x400,0x400,0x400,0x0,0x8000,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x2,0x634243fa,0x2020122,0x20400248,0x41004090,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x20,0x0,0x20,0x0,0x0,0x0,0x0,0xb988a9a2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x19a8a022,0x0,0x0,0x0,0x1988a022,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x1988a022,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x1988a022,0xa0000000,0x0,0x0,0x0,0x0,0x0,0xa0000980,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x100,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x20000980,0xb988a9a2,0x0,0x0,0x0,0x0,0x6000000,0x0,0x0,0x0,0x1000,0x1000,0x0,0x6400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x0,0x0,0x1988a022,0x0,0x5d8ca023,0x44040001,0x0,0x5d8ca023,0x0,0x0,0x5d8ca023,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1988a022,0x1008002,0x8080020,0x10802000,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x6d73d13e,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x0,0x0,0x6d73d13e,0x0,0x6d77d93f,0x40801,0x0,0x6d77d93f,0x0,0x0,0x6d77d93f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d73d13e,0x48211012,0x4424024,0x21108108,};
	}
	private static void jj_la1_init_3() {
	   jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x577e005f,0x0,0x0,0x20000,0x4000005f,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x0,0x0,0x4000005f,0x0,0x46091c5f,0x6091c00,0x177c0000,0x46091c5f,0x0,0x0,0x46091cdf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000005f,0x44,0x40000009,0x12,};
	}
	private static void jj_la1_init_4() {
	   jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x800,0x0,0x0,0x0,0x800,0x800,0x0,0x2080000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x2,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7739f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x0,0x0,0x1000000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x2da7711b,0x0,0x0,0x0,0x2da7711f,0x2da7711b,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x120,0x20,0x0,0x2da7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x280,0x0,0x0,0x0,0x284,0x0,0x0,0x4,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x204,0x2da7739f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x0,0x0,0x2da7711b,0x0,0x2db7711b,0x100000,0x0,0x2db7711b,0x0,0x0,0x2db7711b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2da7711b,0x21044102,0x4211008,0x8822011,};
	}
	private static void jj_la1_init_5() {
	   jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x8000000,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe28433d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x1000000,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0xe284335,0x0,0x1000,0x0,0xe284335,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80030,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x8,0xe28433d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x200000,0x200000,0x200000,0x202000,0x0,0x200000,0x200000,0x2000,0x202000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x202000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe284335,0x0,0x0,0xe284335,0x0,0x8e284b35,0x80000800,0x0,0x8e284b35,0x0,0x0,0x8e284b35,0x2,0x2,0x1000000,0x2,0x1000000,0x2,0x2,0x2,0x2,0x2,0x2,0x1000000,0x0,0x0,0x100000,0x0,0x40000000,0x2000,0x0,0x2000,0x0,0x2000,0xe284335,0x8200210,0x2004021,0x4080104,};
	}
	private static void jj_la1_init_6() {
	   jj_la1_6 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x2,0x2,0x2,0x0,0x9e075180,0x2,0x2,0x0,0x9e075180,0x0,0x2,0x2,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x2,0x2,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075580,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x9e075190,0x9e075180,0x0,0x0,0x10,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9e075180,0x0,0x0,0x0,0x0,0x0,0x0,0x10000400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x400,0x9e075580,0x200000,0x0,0x0,0x2000,0x0,0x200000,0x2000,0x2000,0x0,0x0,0x200000,0x808,0x180,0x0,0x0,0x4000,0x4000,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x80,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x9e075180,0x0,0x0,0x9e075180,0x0,0x9f075b80,0x1000a00,0x0,0x9f075b80,0x0,0x0,0x9f075b80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x10,0x0,0x10,0x9e075180,0x84021000,0x8044080,0x12010100,};
	}
	private static void jj_la1_init_7() {
	   jj_la1_7 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x10000,0x0,0x2000000,0x0,0x0,0x10000,0x0,0x0,0xc933885,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c933885,0x0,0x0,0x0,0x8,0x0,0x40,0x0,0xc933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9000,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0xc933885,0xc933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x200,0x0,0xc933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0x0,0x30000000,0x0,0x0,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x3c933885,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x0,0x0,0xc933885,0x0,0xc933a95,0x210,0x0,0xe933a95,0x0,0x0,0xe933a95,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0xc933885,0x8102080,0x810801,0x4021004,};
	}
	private static void jj_la1_init_8() {
	   jj_la1_8 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x40000000,0x40000000,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x11f342f5,0x11f342f4,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100ffc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11f342f4,0x0,0x0,0x11f342f4,0x0,0xb3f342f4,0xa2000000,0x0,0xb3f342f4,0x0,0x0,0xb3f342f4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x200,0x0,0x200,0x200,0x11f342f4,0x10404220,0x910044,0x1220090,};
	}
	private static void jj_la1_init_9() {
	   jj_la1_9 = new int[] {0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x1000020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42dc1c,0x0,0x0,0x0,0xdc42d01c,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x40000000,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x0,0x0,0xdc42d01c,0x0,0xdc62fd1c,0x202d00,0xc00,0xdc62fd1c,0x0,0x0,0xdc62fd1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc42d01c,0x50008010,0x84021004,0x8404008,};
	}
	private static void jj_la1_init_10() {
	   jj_la1_10 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0xa1043f09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x2000000,0x0,0x0,0x0,0x0,0x2000000,0x0,0x2000000,0x0,0x2000200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x200,0x0,0xa11c3d09,0x0,0x0,0x100000,0xb1043d09,0xa1043d09,0x0,0x0,0x10000000,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x84,0x85,0x2084,0x0,0xa1043d09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0xa1043f09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa1043f09,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x10000000,0x0,0x10000000,0x10000000,0x0,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0xa1043d09,0x0,0x0,0xa1043d09,0x0,0xed043d9f,0x4c000096,0x0,0xed043d9f,0x0,0x0,0xed043d9f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x200,0x2000000,0x10000000,0x0,0x10000000,0x0,0x12000000,0xa1043d09,0x80040808,0x1001100,0x20002401,};
	}
	private static void jj_la1_init_11() {
	   jj_la1_11 = new int[] {0x20000,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x400000,0x400000,0x400000,0x0,0x400,0x400,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc027,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x800,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2010000,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0xd89cc425,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x0,0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0xd89cc027,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x1000000,0x0,0xd89cc025,0x1000000,0xd89cc035,0x10,0x0,0xd89cc035,0x0,0x0,0xd89cc035,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd89cc025,0x40840020,0x88084001,0x10108004,};
	}
	private static void jj_la1_init_12() {
	   jj_la1_12 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x483807df,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483c07df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483c07df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x20000,0x483807df,0x0,0x0,0x0,0x483807df,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x483807df,0x0,0x0,0x483807df,0x0,0x4a3907df,0x2010000,0x0,0x4a3907df,0x0,0x0,0x4a3907df,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x483807df,0x8080112,0x40100244,0x200489,};
	}
	private static void jj_la1_init_13() {
	   jj_la1_13 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x6d000536,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x40,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x6d000136,0x6d000136,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x400,0x6d000536,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x0,0x0,0x6d000136,0x0,0x6da201b6,0xa20080,0x0,0x6da201b6,0x0,0x0,0x6da201b6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d000136,0x8000104,0x21000010,0x44000022,};
	}
	private static void jj_la1_init_14() {
	   jj_la1_14 = new int[] {0x0,0x0,0x0,0x90000,0x90000,0x0,0x0,0x90000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x10000,0x0,0x0,0x800,0x0,0x0,0x3bc2f23e,0x0,0x0,0x80000,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x3bc2f23e,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x0,0x0,0x3bc2f23e,0x0,0x3bc6f23e,0x40000,0x0,0x3bc6f23e,0x0,0x0,0x3bc6f23e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3bc2f23e,0x8809012,0x11022024,0x22404208,};
	}
	private static void jj_la1_init_15() {
	   jj_la1_15 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5ac4fa6,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x8000,0x0,0x10,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c5fa6,0x0,0x0,0x0,0x58c4fa6,0x58c4fa6,0x2000,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x200000,0x5ac4fa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x58c4fa6,0x0,0x0,0x58c4fa6,0x0,0x58c4fa7,0x1,0x1000,0x58c4fa7,0x0,0x0,0x58c4fa7,0x0,0x0,0x8000,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58c4fa6,0x1040482,0x4080904,0x804220,};
	}
	private static void jj_la1_init_16() {
	   jj_la1_16 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x80,0x0,0x0,0x100,0x40000000,0x10,0x800,0x2,0x0,0x0,0x0,0x1,0x0,0x200,0x400,0x41ffffb3,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x92492492,0x28924924,0x45249249,};
	}
	private static void jj_la1_init_17() {
	   jj_la1_17 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x4e19ffff,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fe0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x4,0x8,0x0,0x0,0x0,0x0,0x0,0x8000,0x10,0x2,0x0,0x1,0x0,0x0,0x1801f,0x4e19ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x0,0x0,0x4e19ffff,0x0,0x4edbffff,0xc20000,0x0,0xcedbffff,0x0,0x0,0xcedbffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e19ffff,0x4084924,0x8109249,0x42012492,};
	}
	private static void jj_la1_init_18() {
	   jj_la1_18 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x1fa19500,0x10,0x0,0x10,0x200,0x0,0x0,0x0,0x1fa9f500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x8,0x8,0x8,0x8,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x6000,0x0,0x0,0x1fa19540,0x0,0x0,0x0,0x1fa1f500,0x1fa19500,0x0,0x10,0x6000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x0,0x0,0x0,0x0,0x0,0x86000,0x0,0x0,0x0,0x2000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x86000,0x1fa9f500,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x400000,0x0,0x20018000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x0,0x100000,0x1fa19500,0x0,0x1fa19504,0x4,0x40,0x1fa19504,0x0,0x8000,0x1fa19504,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1fa19500,0x4808100,0x9010400,0x12201000,};
	}
	private static void jj_la1_init_19() {
	   jj_la1_19 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x500000,0x0,0x0,0x0,0x0,0x0,0x0,0x500000,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20080,0x0,0x0,0xdf847a1c,0x0,0x0,0x0,0xde867a9c,0xde847a1c,0x0,0x0,0x20080,0x0,0x0,0x20080,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x20080,0x20080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xde847a1c,0x0,0x0,0xde847a1c,0x0,0xdfa47b1c,0x1200100,0x1000000,0xdfa47b1c,0x0,0x0,0xdfa47b1c,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x20080,0x0,0x20080,0x0,0x20080,0xde847a1c,0x88802204,0x12004808,0x44041010,};
	}
	private static void jj_la1_init_20() {
	   jj_la1_20 = new int[] {0x0,0x38000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x140000,0x0,0x0,0x0,0x0,0x5e01a01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5e01a01,0x0,0x0,0x0,0x5e01a01,0x0,0x0,0x0,0x0,0x5e01a01,0x2000,0x2000,0x0,0x0,0x0,0x0,0x0,0x5e01a01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x5e01a01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5e01ac1,0x0,0x0,0x8000,0x0,0x0,0x0,0x20000,0x5e01a01,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5e01a01,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x5e01a01,0x38000000,0x0,0x38000000,0x0,0x0,0x0,0x0,0x5e01a01,0x0,0x0,0x40000,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x38000000,0x38000000,0x0,0x0,0x5e01a01,0x2000,0x0,0x0,0x3de01a01,0x5e01a01,0x0,0x0,0x38000000,0x38000000,0x38000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x2001000,0x2001000,0x0,0x5e01a01,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x5e01a01,0x0,0x100,0x0,0x0,0x100,0x0,0xc0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x5e01ac1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x40000,0x140000,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x5e01a01,0x0,0x0,0x5e01a01,0x0,0x7e01a31,0x2000030,0x0,0x7e01a31,0x0,0x0,0x7e01a31,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5e01a01,0x4200800,0x801001,0x1400200,};
	}
	private static void jj_la1_init_21() {
	   jj_la1_21 = new int[] {0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x80000,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x0,0x80000,0x0,0x80,0x0,0x0,0x0,0x0,0x80000,0x80,0x100,0x80000,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x2080,0x0,0x80000,0x40080000,0xa0802000,0x800000,0xa0802000,0x80000,0x2080,0x80000,0x80000,0x0,0x0,0x80000,0x0,0x60000000,0x0,0x1e700000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0xfe708000,0x1e700000,0x0,0x0,0x80,0x0,0x0,0x800000,0x60800e1e,0x1000,0x0,0x0,0x0,0x0,0x0,0x60000e1e,0x0,0x0,0x0,0x60000e1e,0x0,0x60000000,0x0,0x4,0x1c,0x4,0x0,0x1e,0xe00,0x80000,0x8000,0x8080,0x8080,0x60000000,0x60000000,0x80,0x80,0x80,0x80,0x0,0x80,0x80,0x0,0x80,0x80,0x80000,0x80,0x0,0x0,0x0,0x0,0x0,0x80000,0x80000,0x20000000,0x60000000,0x80000,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x80100,0x0,0x0,0x80000,0x80000,0x80000,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x80000,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x80000,0x0,0x80,0x0,0x0,0x80,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe700000,0x0,0x0,0x0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	}
	private static void jj_la1_init_22() {
	   jj_la1_22 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x100,0x200,0x0,0x0,0x0,0x80,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x6e00000,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00000,0x0,0x0,0x6e00000,0x0,0x6e00000,0x0,0x0,0x6e00000,0x0,0x0,0x6e00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[96];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  {
      enable_tracing();
  }
  /** Constructor with InputStream. */
  public SqlParserImpl(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SqlParserImpl(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new SqlParserImplTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 333; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 333; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SqlParserImpl(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new SqlParserImplTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 333; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new SqlParserImplTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 333; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SqlParserImpl(SqlParserImplTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 333; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SqlParserImplTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 333; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   trace_token(token, "");
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 } else {
	   trace_scan(jj_scanpos, kind);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	   trace_token(token, " (in getNextToken)");
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = jj_lookingAhead ? jj_scanpos : token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[734];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 333; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		   if ((jj_la1_3[i] & (1<<j)) != 0) {
			 la1tokens[96+j] = true;
		   }
		   if ((jj_la1_4[i] & (1<<j)) != 0) {
			 la1tokens[128+j] = true;
		   }
		   if ((jj_la1_5[i] & (1<<j)) != 0) {
			 la1tokens[160+j] = true;
		   }
		   if ((jj_la1_6[i] & (1<<j)) != 0) {
			 la1tokens[192+j] = true;
		   }
		   if ((jj_la1_7[i] & (1<<j)) != 0) {
			 la1tokens[224+j] = true;
		   }
		   if ((jj_la1_8[i] & (1<<j)) != 0) {
			 la1tokens[256+j] = true;
		   }
		   if ((jj_la1_9[i] & (1<<j)) != 0) {
			 la1tokens[288+j] = true;
		   }
		   if ((jj_la1_10[i] & (1<<j)) != 0) {
			 la1tokens[320+j] = true;
		   }
		   if ((jj_la1_11[i] & (1<<j)) != 0) {
			 la1tokens[352+j] = true;
		   }
		   if ((jj_la1_12[i] & (1<<j)) != 0) {
			 la1tokens[384+j] = true;
		   }
		   if ((jj_la1_13[i] & (1<<j)) != 0) {
			 la1tokens[416+j] = true;
		   }
		   if ((jj_la1_14[i] & (1<<j)) != 0) {
			 la1tokens[448+j] = true;
		   }
		   if ((jj_la1_15[i] & (1<<j)) != 0) {
			 la1tokens[480+j] = true;
		   }
		   if ((jj_la1_16[i] & (1<<j)) != 0) {
			 la1tokens[512+j] = true;
		   }
		   if ((jj_la1_17[i] & (1<<j)) != 0) {
			 la1tokens[544+j] = true;
		   }
		   if ((jj_la1_18[i] & (1<<j)) != 0) {
			 la1tokens[576+j] = true;
		   }
		   if ((jj_la1_19[i] & (1<<j)) != 0) {
			 la1tokens[608+j] = true;
		   }
		   if ((jj_la1_20[i] & (1<<j)) != 0) {
			 la1tokens[640+j] = true;
		   }
		   if ((jj_la1_21[i] & (1<<j)) != 0) {
			 la1tokens[672+j] = true;
		   }
		   if ((jj_la1_22[i] & (1<<j)) != 0) {
			 la1tokens[704+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 734; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

/** Enable tracing. */
  final public void enable_tracing() {
	 trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
	 trace_enabled = false;
  }

  protected void trace_call(String s) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.println("Call:	" + s);
	 }
	 trace_indent = trace_indent + 2;
  }

  protected void trace_return(String s) {
	 trace_indent = trace_indent - 2;
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.println("Return: " + s);
	 }
  }

  protected void trace_token(Token t, String where) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.print("Consumed token: <" + tokenImage[t.kind]);
	   if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
		 System.out.print(": \"" + TokenMgrError.addEscapes(t.image) + "\"");
	   }
	   System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
	 }
  }

  protected void trace_scan(Token t1, int t2) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.print("Visited token: <" + tokenImage[t1.kind]);
	   if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
		 System.out.print(": \"" + TokenMgrError.addEscapes(t1.image) + "\"");
	   }
	   System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
	 }
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 96; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			   case 12: jj_3_13(); break;
			   case 13: jj_3_14(); break;
			   case 14: jj_3_15(); break;
			   case 15: jj_3_16(); break;
			   case 16: jj_3_17(); break;
			   case 17: jj_3_18(); break;
			   case 18: jj_3_19(); break;
			   case 19: jj_3_20(); break;
			   case 20: jj_3_21(); break;
			   case 21: jj_3_22(); break;
			   case 22: jj_3_23(); break;
			   case 23: jj_3_24(); break;
			   case 24: jj_3_25(); break;
			   case 25: jj_3_26(); break;
			   case 26: jj_3_27(); break;
			   case 27: jj_3_28(); break;
			   case 28: jj_3_29(); break;
			   case 29: jj_3_30(); break;
			   case 30: jj_3_31(); break;
			   case 31: jj_3_32(); break;
			   case 32: jj_3_33(); break;
			   case 33: jj_3_34(); break;
			   case 34: jj_3_35(); break;
			   case 35: jj_3_36(); break;
			   case 36: jj_3_37(); break;
			   case 37: jj_3_38(); break;
			   case 38: jj_3_39(); break;
			   case 39: jj_3_40(); break;
			   case 40: jj_3_41(); break;
			   case 41: jj_3_42(); break;
			   case 42: jj_3_43(); break;
			   case 43: jj_3_44(); break;
			   case 44: jj_3_45(); break;
			   case 45: jj_3_46(); break;
			   case 46: jj_3_47(); break;
			   case 47: jj_3_48(); break;
			   case 48: jj_3_49(); break;
			   case 49: jj_3_50(); break;
			   case 50: jj_3_51(); break;
			   case 51: jj_3_52(); break;
			   case 52: jj_3_53(); break;
			   case 53: jj_3_54(); break;
			   case 54: jj_3_55(); break;
			   case 55: jj_3_56(); break;
			   case 56: jj_3_57(); break;
			   case 57: jj_3_58(); break;
			   case 58: jj_3_59(); break;
			   case 59: jj_3_60(); break;
			   case 60: jj_3_61(); break;
			   case 61: jj_3_62(); break;
			   case 62: jj_3_63(); break;
			   case 63: jj_3_64(); break;
			   case 64: jj_3_65(); break;
			   case 65: jj_3_66(); break;
			   case 66: jj_3_67(); break;
			   case 67: jj_3_68(); break;
			   case 68: jj_3_69(); break;
			   case 69: jj_3_70(); break;
			   case 70: jj_3_71(); break;
			   case 71: jj_3_72(); break;
			   case 72: jj_3_73(); break;
			   case 73: jj_3_74(); break;
			   case 74: jj_3_75(); break;
			   case 75: jj_3_76(); break;
			   case 76: jj_3_77(); break;
			   case 77: jj_3_78(); break;
			   case 78: jj_3_79(); break;
			   case 79: jj_3_80(); break;
			   case 80: jj_3_81(); break;
			   case 81: jj_3_82(); break;
			   case 82: jj_3_83(); break;
			   case 83: jj_3_84(); break;
			   case 84: jj_3_85(); break;
			   case 85: jj_3_86(); break;
			   case 86: jj_3_87(); break;
			   case 87: jj_3_88(); break;
			   case 88: jj_3_89(); break;
			   case 89: jj_3_90(); break;
			   case 90: jj_3_91(); break;
			   case 91: jj_3_92(); break;
			   case 92: jj_3_93(); break;
			   case 93: jj_3_94(); break;
			   case 94: jj_3_95(); break;
			   case 95: jj_3_96(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}